#if (UNITY_STANDALONE_OSX && !UNITY_EDITOR) || UNITY_EDITOR_OSX
//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


public partial class AkUnitySoundEngine {
  public static uint JoystickIdToWwiseId(uint joyStickID) { return AkUnitySoundEnginePINVOKE.CSharp_JoystickIdToWwiseId(joyStickID); }

  public static uint AK_INVALID_SHARE_SET_ID { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INVALID_SHARE_SET_ID_get(); } 
  }

  public static ulong AK_INVALID_CACHE_ID { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INVALID_CACHE_ID_get(); } 
  }

  public static uint AK_INVALID_PIPELINE_ID { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INVALID_PIPELINE_ID_get(); } 
  }

  public static ulong AK_INVALID_AUDIO_OBJECT_ID { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INVALID_AUDIO_OBJECT_ID_get(); } 
  }

  public static ulong AK_TRANSPORT_GAME_OBJECT { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_TRANSPORT_GAME_OBJECT_get(); } 
  }

  public static ulong AK_DIRECT_GAME_OBJECT { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_DIRECT_GAME_OBJECT_get(); } 
  }

  public static uint AK_SOUNDBANK_VERSION { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_SOUNDBANK_VERSION_get(); } 
  }

  public static uint AkJobType_Generic { get { return AkUnitySoundEnginePINVOKE.CSharp_AkJobType_Generic_get(); } 
  }

  public static uint AkJobType_AudioProcessing { get { return AkUnitySoundEnginePINVOKE.CSharp_AkJobType_AudioProcessing_get(); } 
  }

  public static uint AkJobType_SpatialAudio { get { return AkUnitySoundEnginePINVOKE.CSharp_AkJobType_SpatialAudio_get(); } 
  }

  public static uint AK_NUM_JOB_TYPES { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_NUM_JOB_TYPES_get(); } 
  }

  public static AkTransform ConvertAkWorldTransformToAkTransform(AkWorldTransform in_) {
    AkTransform ret = new AkTransform(AkUnitySoundEnginePINVOKE.CSharp_ConvertAkWorldTransformToAkTransform(AkWorldTransform.getCPtr(in_)), true);
    return ret;
  }

  public static AkWorldTransform ConvertAkTransformToAkWorldTransform(AkTransform in_) {
    AkWorldTransform ret = new AkWorldTransform(AkUnitySoundEnginePINVOKE.CSharp_ConvertAkTransformToAkWorldTransform(AkTransform.getCPtr(in_)), true);
    return ret;
  }

  public static AkMultiPositionType MultiPositionType_SingleSource { get { return (AkMultiPositionType)AkUnitySoundEnginePINVOKE.CSharp_MultiPositionType_SingleSource_get(); } 
  }

  public static AkMultiPositionType MultiPositionType_MultiSources { get { return (AkMultiPositionType)AkUnitySoundEnginePINVOKE.CSharp_MultiPositionType_MultiSources_get(); } 
  }

  public static AkMultiPositionType MultiPositionType_MultiDirections { get { return (AkMultiPositionType)AkUnitySoundEnginePINVOKE.CSharp_MultiPositionType_MultiDirections_get(); } 
  }

  public static AkMultiPositionType MultiPositionType_Last { get { return (AkMultiPositionType)AkUnitySoundEnginePINVOKE.CSharp_MultiPositionType_Last_get(); } 
  }

  public static ushort AK_INT { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INT_get(); } 
  }

  public static ushort AK_FLOAT { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_FLOAT_get(); } 
  }

  public static byte AK_INTERLEAVED { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INTERLEAVED_get(); } 
  }

  public static byte AK_NONINTERLEAVED { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_NONINTERLEAVED_get(); } 
  }

  public static uint AK_LE_NATIVE_BITSPERSAMPLE { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_LE_NATIVE_BITSPERSAMPLE_get(); } 
  }

  public static uint AK_LE_NATIVE_SAMPLETYPE { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_LE_NATIVE_SAMPLETYPE_get(); } 
  }

  public static uint AK_LE_NATIVE_INTERLEAVE { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_LE_NATIVE_INTERLEAVE_get(); } 
  }

  public static bool IsBankCodecID(uint in_codecID) { return AkUnitySoundEnginePINVOKE.CSharp_IsBankCodecID(in_codecID); }

  public static byte AK_INVALID_MIDI_CHANNEL { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INVALID_MIDI_CHANNEL_get(); } 
  }

  public static byte AK_INVALID_MIDI_NOTE { get { return AkUnitySoundEnginePINVOKE.CSharp_AK_INVALID_MIDI_NOTE_get(); } 
  }

  public static AkDynamicSequenceType DynamicSequenceType_SampleAccurate { get { return (AkDynamicSequenceType)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceType_SampleAccurate_get(); } 
  }

  public static AkDynamicSequenceType DynamicSequenceType_NormalTransition { get { return (AkDynamicSequenceType)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceType_NormalTransition_get(); } 
  }

  public static AkDynamicSequenceType DynamicSequenceType_Last { get { return (AkDynamicSequenceType)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceType_Last_get(); } 
  }

  ///  Open a new Dynamic Sequence.
  /// <returns>Playing ID of the dynamic sequence, or AK_INVALID_PLAYING_ID in failure case and an error message in the debug console and Wwise Profiler</returns> 
  ///  If ``AK_DynamicSequenceSelect`` bit is set in ``in_uFlags``, the dynamic sequence uses the callback for determining the next item to play.
  ///  If this bit is not set, then the dynamic sequence uses the Playlist to determine the next item to play.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.DynamicSequence.DynamicSequenceType"/>
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information;</param> 
  /// <param name="in_eDynamicSequenceType"> See : \ref AkDynamicSequenceType</param>
  public static uint DynamicSequenceOpen(ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie, AkDynamicSequenceType in_eDynamicSequenceType) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceOpen__SWIG_0(in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, (int)in_eDynamicSequenceType);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Open a new Dynamic Sequence.
  /// <returns>Playing ID of the dynamic sequence, or AK_INVALID_PLAYING_ID in failure case and an error message in the debug console and Wwise Profiler</returns> 
  ///  If ``AK_DynamicSequenceSelect`` bit is set in ``in_uFlags``, the dynamic sequence uses the callback for determining the next item to play.
  ///  If this bit is not set, then the dynamic sequence uses the Playlist to determine the next item to play.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.DynamicSequence.DynamicSequenceType"/>
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information;</param>
  public static uint DynamicSequenceOpen(ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceOpen__SWIG_1(in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Open a new Dynamic Sequence.
  /// <returns>Playing ID of the dynamic sequence, or AK_INVALID_PLAYING_ID in failure case and an error message in the debug console and Wwise Profiler</returns> 
  ///  If ``AK_DynamicSequenceSelect`` bit is set in ``in_uFlags``, the dynamic sequence uses the callback for determining the next item to play.
  ///  If this bit is not set, then the dynamic sequence uses the Playlist to determine the next item to play.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.DynamicSequence.DynamicSequenceType"/>
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static uint DynamicSequenceOpen(ulong in_gameObjectID) {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceOpen__SWIG_2(in_gameObjectID);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}

  ///  Close specified Dynamic Sequence. The Dynamic Sequence will play until finished and then
  ///  deallocate itself.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequenceClose(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceClose(in_playingID); }

  ///  Play specified Dynamic Sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static AKRESULT DynamicSequencePlay(uint in_playingID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequencePlay__SWIG_0(in_playingID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Play specified Dynamic Sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static AKRESULT DynamicSequencePlay(uint in_playingID, int in_uTransitionDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequencePlay__SWIG_1(in_playingID, in_uTransitionDuration); }

  ///  Play specified Dynamic Sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequencePlay(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequencePlay__SWIG_2(in_playingID); }

  ///  Pause specified Dynamic Sequence.
  ///  To restart the sequence, call Resume.  The item paused will resume its playback, followed by the rest of the sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static AKRESULT DynamicSequencePause(uint in_playingID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequencePause__SWIG_0(in_playingID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Pause specified Dynamic Sequence.
  ///  To restart the sequence, call Resume.  The item paused will resume its playback, followed by the rest of the sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static AKRESULT DynamicSequencePause(uint in_playingID, int in_uTransitionDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequencePause__SWIG_1(in_playingID, in_uTransitionDuration); }

  ///  Pause specified Dynamic Sequence.
  ///  To restart the sequence, call Resume.  The item paused will resume its playback, followed by the rest of the sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequencePause(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequencePause__SWIG_2(in_playingID); }

  ///  Resume specified Dynamic Sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static AKRESULT DynamicSequenceResume(uint in_playingID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceResume__SWIG_0(in_playingID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Resume specified Dynamic Sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static AKRESULT DynamicSequenceResume(uint in_playingID, int in_uTransitionDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceResume__SWIG_1(in_playingID, in_uTransitionDuration); }

  ///  Resume specified Dynamic Sequence.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequenceResume(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceResume__SWIG_2(in_playingID); }

  ///  Stop specified Dynamic Sequence immediately.
  ///  To restart the sequence, call Play. The sequence will restart with the item that was in the
  ///  playlist after the item that was stopped.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static AKRESULT DynamicSequenceStop(uint in_playingID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceStop__SWIG_0(in_playingID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Stop specified Dynamic Sequence immediately.
  ///  To restart the sequence, call Play. The sequence will restart with the item that was in the
  ///  playlist after the item that was stopped.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static AKRESULT DynamicSequenceStop(uint in_playingID, int in_uTransitionDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceStop__SWIG_1(in_playingID, in_uTransitionDuration); }

  ///  Stop specified Dynamic Sequence immediately.
  ///  To restart the sequence, call Play. The sequence will restart with the item that was in the
  ///  playlist after the item that was stopped.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequenceStop(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceStop__SWIG_2(in_playingID); }

  ///  Break specified Dynamic Sequence.  The sequence will stop after the current item.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequenceBreak(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceBreak(in_playingID); }

  ///  Seek inside specified Dynamic Sequence.
  ///  It is only possible to seek in the first item of the sequence.
  ///  If you seek past the duration of the first item, it will be skipped and an error will reported in the Capture Log and debug output.
  ///  All the other items in the sequence will continue to play normally.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_iPosition"> Position into the the sound, in milliseconds</param> 
  /// <param name="in_bSeekToNearestMarker"> Snap to the marker nearest to the seek position.</param>
  public static AKRESULT Seek(uint in_playingID, int in_iPosition, bool in_bSeekToNearestMarker) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_Seek__SWIG_0(in_playingID, in_iPosition, in_bSeekToNearestMarker); }

  ///  Seek inside specified Dynamic Sequence.
  ///  It is only possible to seek in the first item of the sequence.
  ///  If you seek past the duration of the first item, it will be skipped and an error will reported in the Capture Log and debug output.
  ///  All the other items in the sequence will continue to play normally.
  /// <returns>
  ///      - AK_Success if the command was successfully queued
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="in_fPercent"> Position into the the sound, in percentage of the whole duration.</param> 
  /// <param name="in_bSeekToNearestMarker"> Snap to the marker nearest to the seek position.</param>
  public static AKRESULT Seek(uint in_playingID, float in_fPercent, bool in_bSeekToNearestMarker) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_Seek__SWIG_1(in_playingID, in_fPercent, in_bSeekToNearestMarker); }

  ///  Get pause times.
  /// <returns>
  ///      - AK_Success if successful
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param> 
  /// <param name="out_uTime"> If sequence is currently paused, returns time when pause started, else 0.</param> 
  /// <param name="out_uDuration"> Returns total pause duration since last call to GetPauseTimes, excluding the time elapsed in the current pause.</param>
  public static AKRESULT DynamicSequenceGetPauseTimes(uint in_playingID, out uint out_uTime, out uint out_uDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceGetPauseTimes(in_playingID, out out_uTime, out out_uDuration); }

  ///  Lock the Playlist for editing. Needs a corresponding UnlockPlaylist call.
  /// <returns>Pointer to locked Playlist if successful, NULL otherwise (in_playingID not found)</returns> 
  ///  When opening a dynamic sequence with the callback flag ``AK_DynamicSequenceSelect``, the callback is the ONLY way to determine the next item to play.
  ///  ``AK::SoundEngine::DynamicSequence::LockPlaylist`` always returns ``NULL`` for dynamic sequences opened with ``AK_DynamicSequenceSelect``.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.DynamicSequence.UnlockPlaylist"/>
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AkPlaylist DynamicSequenceLockPlaylist(uint in_playingID) {
    global::System.IntPtr cPtr = AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceLockPlaylist(in_playingID);
    AkPlaylist ret = (cPtr == global::System.IntPtr.Zero) ? null : new AkPlaylist(cPtr, false);
    return ret;
  }

  ///  Unlock the playlist.
  /// <returns>
  ///      - AK_Success if successful
  ///      - AK_PlayingIDNotFound if the playing ID does not match to any open Dynamic Sequence</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.DynamicSequence.LockPlaylist"/>
  /// <param name="in_playingID"> AkPlayingID returned by DynamicSequence::Open</param>
  public static AKRESULT DynamicSequenceUnlockPlaylist(uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_DynamicSequenceUnlockPlaylist(in_playingID); }

  ///  Query whether or not the sound engine has been successfully initialized.
  /// <remarks>This function is not thread-safe. It should not be called at the same time as </remarks><returns>``True`` if the sound engine has been initialized, ``False`` otherwise.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_integration_init_advanced
  ///  - AK.SoundEngine.Init"/>
  public static bool IsInitialized() { return AkUnitySoundEnginePINVOKE.CSharp_IsInitialized(); }

  ///  Gets the configured audio settings.
  ///  Call this function to get the configured audio settings.
  ///
  /// <remarks>This function is not thread-safe.</remarks><remarks>Call this function only after the sound engine has been properly initialized.</remarks><returns>
  ///      - ``AK_NotInitialized`` if AK::SoundEngine::Init() was not called
  ///      - ``AK_Success`` otherwise.		</returns> 
  /// <param name="out_audioSettings"> Returned audio settings</param>
  public static AKRESULT GetAudioSettings(AkAudioSettings out_audioSettings) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetAudioSettings(AkAudioSettings.getCPtr(out_audioSettings)); }

  ///  Gets the output speaker configuration of the specified output.
  ///  Call this function to get the speaker configuration of the output (which may not correspond
  ///  to the physical output format of the platform, in the case of downmixing provided by the platform itself).
  ///  You may initialize the sound engine with a user-specified configuration, but the resulting
  ///  configuration is determined by the sound engine, based on the platform, output type and
  ///  platform settings (for e.g. system menu or control panel option).
  ///  If the speaker configuration of the output is object-based, the speaker configuration of the
  ///  main mix is returned. To query more information on object-based output devices, see AK::SoundEngine::GetOutputDeviceConfiguration.
  ///  It is recommended to call GetSpeakerConfiguration anytime after receiving a callback from RegisterAudioDeviceStatusCallback to know if the channel configuration has changed.
  ///
  /// <remarks>Call this function only after the sound engine has been properly initialized. </remarks><returns>The output configuration. An empty AkChannelConfig not AkChannelConfig::IsValid() if device does not exist or if the Init.bnk was not loaded yet.		</returns> 
  /// <seealso cref="
  ///  - AkSpeakerConfig.h
  ///  - AkOutputSettings
  ///  - AK.SoundEngine.GetOutputDeviceConfiguration"/>
  /// <param name="in_idOutput"> Output ID to set the bus on.  As returned from AddOutput or GetOutputID.  You can pass 0 for the main (default) output	</param>
  public static AkChannelConfig GetSpeakerConfiguration(ulong in_idOutput) {
    AkChannelConfig ret = new AkChannelConfig(AkUnitySoundEnginePINVOKE.CSharp_GetSpeakerConfiguration__SWIG_0(in_idOutput), true);
    return ret;
  }

  ///  Gets the output speaker configuration of the specified output.
  ///  Call this function to get the speaker configuration of the output (which may not correspond
  ///  to the physical output format of the platform, in the case of downmixing provided by the platform itself).
  ///  You may initialize the sound engine with a user-specified configuration, but the resulting
  ///  configuration is determined by the sound engine, based on the platform, output type and
  ///  platform settings (for e.g. system menu or control panel option).
  ///  If the speaker configuration of the output is object-based, the speaker configuration of the
  ///  main mix is returned. To query more information on object-based output devices, see AK::SoundEngine::GetOutputDeviceConfiguration.
  ///  It is recommended to call GetSpeakerConfiguration anytime after receiving a callback from RegisterAudioDeviceStatusCallback to know if the channel configuration has changed.
  ///
  /// <remarks>Call this function only after the sound engine has been properly initialized. </remarks><returns>The output configuration. An empty AkChannelConfig not AkChannelConfig::IsValid() if device does not exist or if the Init.bnk was not loaded yet.		</returns> 
  /// <seealso cref="
  ///  - AkSpeakerConfig.h
  ///  - AkOutputSettings
  ///  - AK.SoundEngine.GetOutputDeviceConfiguration"/>
  public static AkChannelConfig GetSpeakerConfiguration() {
    AkChannelConfig ret = new AkChannelConfig(AkUnitySoundEnginePINVOKE.CSharp_GetSpeakerConfiguration__SWIG_1(), true);
    return ret;
  }

  ///  Gets the configuration of the specified output device.
  ///  Call this function to get the channel configuration of the output device as well as its 3D audio capabilities.
  ///  If the configuration of the output device is object-based (io_channelConfig.eConfigType == AK_ChannelConfigType_Objects),
  ///  io_capabilities can be inspected to determine the channel configuration of the main mix (Ak3DAudioSinkCapabilities::channelConfig),
  ///  whether or not the output device uses a passthrough mix (Ak3DAudioSinkCapabilities::bPassthrough) and the maximum number of objects
  ///  that can play simultaneously on this output device (Ak3DAudioSinkCapabilities::uMax3DAudioObjects). Note that if
  ///  Ak3DAudioSinkCapabilities::bMultiChannelObjects is false, multi-channel objects will be split into multiple mono objects
  ///  before being sent to the output device.
  ///
  /// <remarks>Call this function only after the sound engine has been properly initialized. If you are initializing the sound engine with AkInitSettings::bUseLEngineThread to false, it is required to call RenderAudio() at least once before calling this function to complete the sound engine initialization.</remarks><returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_IDNotFound`` is the output was not found in the system.
  ///      - ``AK_NotInitialized`` if the sound engine is not initialized</returns> 
  /// <seealso cref="
  ///  - AkSpeakerConfig.h
  ///  - AkOutputSettings
  ///  - AK.SoundEngine.GetSpeakerConfiguration"/>
  public static AKRESULT GetOutputDeviceConfiguration(ulong in_idOutput, AkChannelConfig io_channelConfig, Ak3DAudioSinkCapabilities io_capabilities) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetOutputDeviceConfiguration(in_idOutput, AkChannelConfig.getCPtr(io_channelConfig), Ak3DAudioSinkCapabilities.getCPtr(io_capabilities)); }

  ///  Gets the panning rule of the specified output.
  /// <remarks>Call this function only after the sound engine has been properly initialized.</remarks><returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_IDNotFound`` is the output was not found in the system.
  ///      - ``AK_NotInitialized`` if the sound engine is not initialized</returns> 
  /// <seealso cref="
  ///  - AkSpeakerConfig.h"/>
  /// <param name="out_ePanningRule"> Returned panning rule (AkPanningRule_Speakers or AkPanningRule_Headphone) for given output.</param> 
  /// <param name="in_idOutput"> Output ID to set the bus on.  As returned from AddOutput or GetOutputID.  You can pass 0 for the main (default) output	</param>
  public static AKRESULT GetPanningRule(out int out_ePanningRule, ulong in_idOutput) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPanningRule__SWIG_0(out out_ePanningRule, in_idOutput); }

  ///  Gets the panning rule of the specified output.
  /// <remarks>Call this function only after the sound engine has been properly initialized.</remarks><returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_IDNotFound`` is the output was not found in the system.
  ///      - ``AK_NotInitialized`` if the sound engine is not initialized</returns> 
  /// <seealso cref="
  ///  - AkSpeakerConfig.h"/>
  /// <param name="out_ePanningRule"> Returned panning rule (AkPanningRule_Speakers or AkPanningRule_Headphone) for given output.</param>
  public static AKRESULT GetPanningRule(out int out_ePanningRule) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPanningRule__SWIG_1(out out_ePanningRule); }

  ///  Sets the panning rule of the specified output.
  ///  This may be changed anytime once the sound engine is initialized.
  /// <remarks>This function posts a message through the sound engine's internal message queue, whereas GetPanningRule() queries the current panning rule directly.</remarks><param name="in_ePanningRule"> Panning rule.</param> 
  /// <param name="in_idOutput"> Output ID to set the bus on.  As returned from AddOutput or GetOutputID.  You can pass 0 for the main (default) output	</param>
  public static AKRESULT SetPanningRule(AkPanningRule in_ePanningRule, ulong in_idOutput) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetPanningRule__SWIG_0((int)in_ePanningRule, in_idOutput); }

  ///  Sets the panning rule of the specified output.
  ///  This may be changed anytime once the sound engine is initialized.
  /// <remarks>This function posts a message through the sound engine's internal message queue, whereas GetPanningRule() queries the current panning rule directly.</remarks><param name="in_ePanningRule"> Panning rule.</param>
  public static AKRESULT SetPanningRule(AkPanningRule in_ePanningRule) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetPanningRule__SWIG_1((int)in_ePanningRule); }

  ///  Gets speaker angles of the specified device. Speaker angles are used for 3D positioning of sounds over standard configurations.
  ///  Note that the current version of Wwise only supports positioning on the plane.
  ///  The speaker angles are expressed as an array of loudspeaker pairs, in degrees, relative to azimuth ]0,180].
  ///  Supported loudspeaker setups are always symmetric; the center speaker is always in the middle and thus not specified by angles.
  ///  Angles must be set in ascending order.
  ///  You may call this function with io_pfSpeakerAngles set to NULL to get the expected number of angle values in io_uNumAngles,
  ///  in order to allocate your array correctly. You may also obtain this number by calling
  ///  AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ).
  ///  If io_pfSpeakerAngles is not NULL, the array is filled with up to io_uNumAngles.
  ///  Typical usage:
  ///  - AkUInt32 uNumAngles;
  ///  - GetSpeakerAngles( NULL, uNumAngles, AkOutput_Main );
  ///  - AkReal32 * pfSpeakerAngles = AkAlloca( uNumAngles * sizeof(AkReal32) );
  ///  - GetSpeakerAngles( pfSpeakerAngles, uNumAngles, AkOutput_Main );
  ///
  /// 	On most platforms, the angle set on the plane consists of 3 angles, to account for 7.1.
  ///  - When panning to stereo (speaker mode, see AK::SoundEngine::SetPanningRule()), only angle[0] is used, and 3D sounds in the back of the listener are mirrored to the front.
  ///  - When panning to 5.1, the front speakers use angle[0], and the surround speakers use (angle[2] + angle[1]) / 2.
  /// <remarks>Call this function only after the sound engine has been properly initialized.</remarks><returns>AK_Success if device exists.</returns> 
  /// <seealso cref="SetSpeakerAngles"/>
  /// <param name="io_pfSpeakerAngles"> Returned array of loudspeaker pair angles, in degrees relative to azimuth [0,180]. Pass NULL to get the required size of the array.</param> 
  /// <param name="io_uNumAngles"> Returned number of angles in io_pfSpeakerAngles, which is the minimum between the value that you pass in, and the number of angles corresponding to AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ), or just the latter if io_pfSpeakerAngles is NULL.</param> 
  /// <param name="out_fHeightAngle"> Elevation of the height layer, in degrees relative to the plane [-90,90].</param> 
  /// <param name="in_idOutput"> Output ID to set the bus on.  As returned from AddOutput or GetOutputID.  You can pass 0 for the main (default) output			</param>
  public static AKRESULT GetSpeakerAngles(float[] io_pfSpeakerAngles, ref uint io_uNumAngles, out float out_fHeightAngle, ulong in_idOutput) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSpeakerAngles__SWIG_0(io_pfSpeakerAngles, ref io_uNumAngles, out out_fHeightAngle, in_idOutput); }

  ///  Gets speaker angles of the specified device. Speaker angles are used for 3D positioning of sounds over standard configurations.
  ///  Note that the current version of Wwise only supports positioning on the plane.
  ///  The speaker angles are expressed as an array of loudspeaker pairs, in degrees, relative to azimuth ]0,180].
  ///  Supported loudspeaker setups are always symmetric; the center speaker is always in the middle and thus not specified by angles.
  ///  Angles must be set in ascending order.
  ///  You may call this function with io_pfSpeakerAngles set to NULL to get the expected number of angle values in io_uNumAngles,
  ///  in order to allocate your array correctly. You may also obtain this number by calling
  ///  AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ).
  ///  If io_pfSpeakerAngles is not NULL, the array is filled with up to io_uNumAngles.
  ///  Typical usage:
  ///  - AkUInt32 uNumAngles;
  ///  - GetSpeakerAngles( NULL, uNumAngles, AkOutput_Main );
  ///  - AkReal32 * pfSpeakerAngles = AkAlloca( uNumAngles * sizeof(AkReal32) );
  ///  - GetSpeakerAngles( pfSpeakerAngles, uNumAngles, AkOutput_Main );
  ///
  /// 	On most platforms, the angle set on the plane consists of 3 angles, to account for 7.1.
  ///  - When panning to stereo (speaker mode, see AK::SoundEngine::SetPanningRule()), only angle[0] is used, and 3D sounds in the back of the listener are mirrored to the front.
  ///  - When panning to 5.1, the front speakers use angle[0], and the surround speakers use (angle[2] + angle[1]) / 2.
  /// <remarks>Call this function only after the sound engine has been properly initialized.</remarks><returns>AK_Success if device exists.</returns> 
  /// <seealso cref="SetSpeakerAngles"/>
  /// <param name="io_pfSpeakerAngles"> Returned array of loudspeaker pair angles, in degrees relative to azimuth [0,180]. Pass NULL to get the required size of the array.</param> 
  /// <param name="io_uNumAngles"> Returned number of angles in io_pfSpeakerAngles, which is the minimum between the value that you pass in, and the number of angles corresponding to AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ), or just the latter if io_pfSpeakerAngles is NULL.</param> 
  /// <param name="out_fHeightAngle"> Elevation of the height layer, in degrees relative to the plane [-90,90].</param>
  public static AKRESULT GetSpeakerAngles(float[] io_pfSpeakerAngles, ref uint io_uNumAngles, out float out_fHeightAngle) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSpeakerAngles__SWIG_1(io_pfSpeakerAngles, ref io_uNumAngles, out out_fHeightAngle); }

  ///  Sets speaker angles of the specified device. Speaker angles are used for 3D positioning of sounds over standard configurations.
  ///  Note that the current version of Wwise only supports positioning on the plane.
  ///  The speaker angles are expressed as an array of loudspeaker pairs, in degrees, relative to azimuth ]0,180], for a 7.1 speaker configuration.
  ///  Supported loudspeaker setups are always symmetric; the center speaker is always in the middle and thus not specified by angles.
  ///  Angles must be set in ascending order.
  ///  Note:
  ///  - This function requires the minimum speaker angle between any pair of speakers to be at least 5 degrees.
  ///  - When setting angles for a 5.1 speaker layout, we recommend that you select an angle for the SL and SR channels, then subtract 15 degrees for in_pfSpeakerAngles[1] and add 15 degrees for in_pfSpeakerAngles[2] to set the arc appropriately.
  ///  Typical usage:
  ///  - Initialize the sound engine and/or add secondary output(s).
  ///  - Get number of speaker angles and their value into an array using GetSpeakerAngles().
  ///  - Modify the angles and call SetSpeakerAngles().
  ///  This function posts a message to the audio thread through the command queue, so it is thread safe. However the result may not be immediately read with GetSpeakerAngles().
  /// <remarks>This function only applies to configurations (or subset of these configurations) that are standard and whose speakers are on the plane (2D).</remarks><returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf
  ///      - ``AK_InsufficientMemory`` if there wasn't enough memory in the message queue
  ///      - ``AK_InvalidParameter`` one of the parameter is invalid, check the debug log. Speaker angles must be [0, 180] and height angle must be [-90, 90]. Height angle must not be 0, regardless if height channels are used.</returns> 
  /// <seealso cref="GetSpeakerAngles"/>
  /// <param name="in_pfSpeakerAngles"> Array of loudspeaker pair angles, in degrees relative to azimuth ]0,180].</param> 
  /// <param name="in_uNumAngles"> Number of elements in in_pfSpeakerAngles. It must correspond to AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ) (the value returned by GetSpeakerAngles()).</param> 
  /// <param name="in_fHeightAngle"> Elevation of the height layer, in degrees relative to the plane [-90,90], but it cannot be 0.</param> 
  /// <param name="in_idOutput"> Output ID to set the bus on.  As returned from AddOutput or GetOutputID.  You can pass 0 for the main (default) output</param>
  public static AKRESULT SetSpeakerAngles(float[] in_pfSpeakerAngles, uint in_uNumAngles, float in_fHeightAngle, ulong in_idOutput) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSpeakerAngles__SWIG_0(in_pfSpeakerAngles, in_uNumAngles, in_fHeightAngle, in_idOutput); }

  ///  Sets speaker angles of the specified device. Speaker angles are used for 3D positioning of sounds over standard configurations.
  ///  Note that the current version of Wwise only supports positioning on the plane.
  ///  The speaker angles are expressed as an array of loudspeaker pairs, in degrees, relative to azimuth ]0,180], for a 7.1 speaker configuration.
  ///  Supported loudspeaker setups are always symmetric; the center speaker is always in the middle and thus not specified by angles.
  ///  Angles must be set in ascending order.
  ///  Note:
  ///  - This function requires the minimum speaker angle between any pair of speakers to be at least 5 degrees.
  ///  - When setting angles for a 5.1 speaker layout, we recommend that you select an angle for the SL and SR channels, then subtract 15 degrees for in_pfSpeakerAngles[1] and add 15 degrees for in_pfSpeakerAngles[2] to set the arc appropriately.
  ///  Typical usage:
  ///  - Initialize the sound engine and/or add secondary output(s).
  ///  - Get number of speaker angles and their value into an array using GetSpeakerAngles().
  ///  - Modify the angles and call SetSpeakerAngles().
  ///  This function posts a message to the audio thread through the command queue, so it is thread safe. However the result may not be immediately read with GetSpeakerAngles().
  /// <remarks>This function only applies to configurations (or subset of these configurations) that are standard and whose speakers are on the plane (2D).</remarks><returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf
  ///      - ``AK_InsufficientMemory`` if there wasn't enough memory in the message queue
  ///      - ``AK_InvalidParameter`` one of the parameter is invalid, check the debug log. Speaker angles must be [0, 180] and height angle must be [-90, 90]. Height angle must not be 0, regardless if height channels are used.</returns> 
  /// <seealso cref="GetSpeakerAngles"/>
  /// <param name="in_pfSpeakerAngles"> Array of loudspeaker pair angles, in degrees relative to azimuth ]0,180].</param> 
  /// <param name="in_uNumAngles"> Number of elements in in_pfSpeakerAngles. It must correspond to AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ) (the value returned by GetSpeakerAngles()).</param> 
  /// <param name="in_fHeightAngle"> Elevation of the height layer, in degrees relative to the plane [-90,90], but it cannot be 0.</param>
  public static AKRESULT SetSpeakerAngles(float[] in_pfSpeakerAngles, uint in_uNumAngles, float in_fHeightAngle) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSpeakerAngles__SWIG_1(in_pfSpeakerAngles, in_uNumAngles, in_fHeightAngle); }

  ///  Sets speaker angles of the specified device. Speaker angles are used for 3D positioning of sounds over standard configurations.
  ///  Note that the current version of Wwise only supports positioning on the plane.
  ///  The speaker angles are expressed as an array of loudspeaker pairs, in degrees, relative to azimuth ]0,180], for a 7.1 speaker configuration.
  ///  Supported loudspeaker setups are always symmetric; the center speaker is always in the middle and thus not specified by angles.
  ///  Angles must be set in ascending order.
  ///  Note:
  ///  - This function requires the minimum speaker angle between any pair of speakers to be at least 5 degrees.
  ///  - When setting angles for a 5.1 speaker layout, we recommend that you select an angle for the SL and SR channels, then subtract 15 degrees for in_pfSpeakerAngles[1] and add 15 degrees for in_pfSpeakerAngles[2] to set the arc appropriately.
  ///  Typical usage:
  ///  - Initialize the sound engine and/or add secondary output(s).
  ///  - Get number of speaker angles and their value into an array using GetSpeakerAngles().
  ///  - Modify the angles and call SetSpeakerAngles().
  ///  This function posts a message to the audio thread through the command queue, so it is thread safe. However the result may not be immediately read with GetSpeakerAngles().
  /// <remarks>This function only applies to configurations (or subset of these configurations) that are standard and whose speakers are on the plane (2D).</remarks><returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf
  ///      - ``AK_InsufficientMemory`` if there wasn't enough memory in the message queue
  ///      - ``AK_InvalidParameter`` one of the parameter is invalid, check the debug log. Speaker angles must be [0, 180] and height angle must be [-90, 90]. Height angle must not be 0, regardless if height channels are used.</returns> 
  /// <seealso cref="GetSpeakerAngles"/>
  /// <param name="in_pfSpeakerAngles"> Array of loudspeaker pair angles, in degrees relative to azimuth ]0,180].</param> 
  /// <param name="in_uNumAngles"> Number of elements in in_pfSpeakerAngles. It must correspond to AK::GetNumberOfAnglesForConfig( AK_SPEAKER_SETUP_DEFAULT_PLANE ) (the value returned by GetSpeakerAngles()).</param>
  public static AKRESULT SetSpeakerAngles(float[] in_pfSpeakerAngles, uint in_uNumAngles) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSpeakerAngles__SWIG_2(in_pfSpeakerAngles, in_uNumAngles); }

  ///  Allows the game to set the volume threshold to be used by the sound engine to determine if a voice must go virtual.
  ///  This may be changed anytime once the sound engine was initialized.
  ///  If this function is not called, the used value will be the value specified in the platform specific project settings.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidParameter`` if the threshold was not between 0 and -96.3 dB.
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf</returns> 
  /// <param name="in_fVolumeThresholdDB"> Volume Threshold, must be a value between 0 and -96.3 dB</param>
  public static AKRESULT SetVolumeThreshold(float in_fVolumeThresholdDB) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetVolumeThreshold(in_fVolumeThresholdDB); }

  ///  Allows the game to set the maximum number of non virtual voices to be played simultaneously.
  ///  This may be changed anytime once the sound engine was initialized.
  ///  If this function is not called, the used value will be the value specified in the platform specific project settings.
  /// <returns>
  ///      - ``AK_InvalidParameter`` if the threshold was not between 1 and MaxUInt16.
  ///      - ``AK_Success`` if successful</returns> 
  /// <param name="in_maxNumberVoices"> Maximum number of non-virtual voices.</param>
  public static AKRESULT SetMaxNumVoicesLimit(ushort in_maxNumberVoices) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMaxNumVoicesLimit(in_maxNumberVoices); }

  ///  Allows the game to set new values for the maximum active workers for the job manager
  ///  This may be changed anytime once the sound engine was initialized.
  ///  This function may only be used if a worker function has been set via \ref AkJobMgrSettings.
  /// <returns>
  ///      - ``AK_InvalidParameter`` in_jobType is not a valid jobtype, or in_uNewMaxActiveWorkers is not greater than 0
  ///      - ``AK_NotInitialized`` JobMgr system was not already initialized with a function to request for workers
  ///      - ``AK_Success`` if successful</returns> 
  /// <param name="in_jobType"> JobType to set new uMaxActiveWorkers for</param> 
  /// <param name="in_uNewMaxActiveWorkers"> New maximum number of active workers will request</param>
  public static AKRESULT SetJobMgrMaxActiveWorkers(uint in_jobType, uint in_uNewMaxActiveWorkers) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetJobMgrMaxActiveWorkers(in_jobType, in_uNewMaxActiveWorkers); }

  ///  Processes all commands in the sound engine's command queue.
  ///  This method has to be called periodically (once per game frame).
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref soundengine_events
  ///  - AK.SoundEngine.PostEvent"/>
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_bAllowSyncRender"> When AkInitSettings::bUseLEngineThread is false, RenderAudio may generate an audio buffer -- unless in_bAllowSyncRender is set to false. Use in_bAllowSyncRender=false when calling RenderAudio from a Sound Engine callback.</param>
  public static AKRESULT RenderAudio(bool in_bAllowSyncRender) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RenderAudio__SWIG_0(in_bAllowSyncRender); }

  ///  Processes all commands in the sound engine's command queue.
  ///  This method has to be called periodically (once per game frame).
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref soundengine_events
  ///  - AK.SoundEngine.PostEvent"/>
  /// <returns>Always returns AK_Success</returns>
  public static AKRESULT RenderAudio() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RenderAudio__SWIG_1(); }

  ///  Loads a plug-in dynamic library and registers it with the sound engine.
  ///  With dynamic linking, all plugins are automatically registered.
  ///  The plug-in DLL must be in the OS-specific library path or in the same location as the executable. If not, set AkInitSettings.szPluginDLLPath.
  /// <returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_FileNotFound`` if the DLL is not found in the OS path or if it has extraneous dependencies not found.
  ///      - ``AK_InsufficientMemory`` if the system ran out of resources while loading the dynamic library
  ///      - ``AK_NotCompatible`` if the file was found but is not binary-compatible with the system's expected executable format
  ///      - ``AK_InvalidFile`` if the symbol g_pAKPluginList is not exported by the dynamic library
  ///      - ``AK_Fail`` if an unexpected system error was encountered</returns> 
  /// <param name="in_DllName"> Name of the DLL to load, without "lib" prefix or extension.</param> 
  /// <param name="in_DllPath"> Optional path to the DLL. Will override szPluginDLLPath that was set in AkInitSettings.</param>
  public static AKRESULT RegisterPluginDLL(string in_DllName, string in_DllPath) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RegisterPluginDLL__SWIG_0(in_DllName, in_DllPath); }

  ///  Loads a plug-in dynamic library and registers it with the sound engine.
  ///  With dynamic linking, all plugins are automatically registered.
  ///  The plug-in DLL must be in the OS-specific library path or in the same location as the executable. If not, set AkInitSettings.szPluginDLLPath.
  /// <returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_FileNotFound`` if the DLL is not found in the OS path or if it has extraneous dependencies not found.
  ///      - ``AK_InsufficientMemory`` if the system ran out of resources while loading the dynamic library
  ///      - ``AK_NotCompatible`` if the file was found but is not binary-compatible with the system's expected executable format
  ///      - ``AK_InvalidFile`` if the symbol g_pAKPluginList is not exported by the dynamic library
  ///      - ``AK_Fail`` if an unexpected system error was encountered</returns> 
  /// <param name="in_DllName"> Name of the DLL to load, without "lib" prefix or extension.</param>
  public static AKRESULT RegisterPluginDLL(string in_DllName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RegisterPluginDLL__SWIG_1(in_DllName); }

  ///  Query whether plug-in is registered with the sound engine.
  /// <returns>true when plug-in is registered, false otherwise.</returns> 
  /// <param name="in_eType"> Plug-in type (for example, source or effect)</param> 
  /// <param name="in_ulCompanyID"> Company identifier (as declared in the plug-in description XML file)</param> 
  /// <param name="in_ulPluginID"> Plug-in identifier (as declared in the plug-in description XML file)</param>
  public static bool IsPluginRegistered(AkPluginType in_eType, uint in_ulCompanyID, uint in_ulPluginID) { return AkUnitySoundEnginePINVOKE.CSharp_IsPluginRegistered((int)in_eType, in_ulCompanyID, in_ulPluginID); }

  ///  Universal converter from Unicode string to ID for the sound engine.
  ///  This function will hash the name based on a algorithm ( provided at : /AK/Tools/Common/AkFNVHash.h )
  ///  Note:
  /// 		This function does return a AkUInt32, which is totally compatible with:
  /// 		AkUniqueID, AkStateGroupID, AkStateID, AkSwitchGroupID, AkSwitchStateID, AkRtpcID, and so on...
  /// <seealso cref="
  ///  - AK.SoundEngine.PostEvent
  ///  - AK.SoundEngine.SetRTPCValue
  ///  - AK.SoundEngine.SetSwitch
  ///  - AK.SoundEngine.SetState
  ///  - AK.SoundEngine.PostTrigger
  ///  - AK.SoundEngine.SetGameObjectAuxSendValues
  ///  - AK.SoundEngine.LoadBank
  ///  - AK.SoundEngine.UnloadBank
  ///  - AK.SoundEngine.PrepareEvent
  ///  - AK.SoundEngine.PrepareGameSyncs"/>
  public static uint GetIDFromString(string in_pszString) { return AkUnitySoundEnginePINVOKE.CSharp_GetIDFromString__SWIG_0(in_pszString); }

  ///  Asynchronously posts an Event to the sound engine (by event ID).
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information</param> 
  /// <param name="in_cExternals"> Optional count of external source structures</param> 
  /// <param name="in_pExternalSources"> Optional array of external source resolution information</param> 
  /// <param name="in_PlayingID"> Optional (advanced users only) Specify the playing ID to target with the event. Will Cause active actions in this event to target an existing Playing ID. Let it be AK_INVALID_PLAYING_ID or do not specify any for normal playback.</param>
  public static uint PostEvent(uint in_eventID, ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie, uint in_cExternals, AkExternalSourceInfoArray in_pExternalSources, uint in_PlayingID) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_0(in_eventID, in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_cExternals, in_pExternalSources.GetBuffer(), in_PlayingID);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Asynchronously posts an Event to the sound engine (by event ID).
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information</param> 
  /// <param name="in_cExternals"> Optional count of external source structures</param> 
  /// <param name="in_pExternalSources"> Optional array of external source resolution information</param>
  public static uint PostEvent(uint in_eventID, ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie, uint in_cExternals, AkExternalSourceInfoArray in_pExternalSources) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_1(in_eventID, in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_cExternals, in_pExternalSources.GetBuffer());
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Asynchronously posts an Event to the sound engine (by event ID).
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information</param>
  public static uint PostEvent(uint in_eventID, ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_2(in_eventID, in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Asynchronously posts an Event to the sound engine (by event ID).
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static uint PostEvent(uint in_eventID, ulong in_gameObjectID) {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_3(in_eventID, in_gameObjectID);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}

  ///  Posts an Event to the sound engine (by Event name)
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information.</param> 
  /// <param name="in_cExternals"> Optional count of external source structures</param> 
  /// <param name="in_pExternalSources"> Optional array of external source resolution information</param> 
  /// <param name="in_PlayingID"> Optional (advanced users only) Specify the playing ID to target with the event. Will Cause active actions in this event to target an existing Playing ID. Let it be AK_INVALID_PLAYING_ID or do not specify any for normal playback.</param>
  public static uint PostEvent(string in_pszEventName, ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie, uint in_cExternals, AkExternalSourceInfoArray in_pExternalSources, uint in_PlayingID) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_4(in_pszEventName, in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_cExternals, in_pExternalSources.GetBuffer(), in_PlayingID);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Posts an Event to the sound engine (by Event name)
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information.</param> 
  /// <param name="in_cExternals"> Optional count of external source structures</param> 
  /// <param name="in_pExternalSources"> Optional array of external source resolution information</param>
  public static uint PostEvent(string in_pszEventName, ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie, uint in_cExternals, AkExternalSourceInfoArray in_pExternalSources) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_5(in_pszEventName, in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_cExternals, in_pExternalSources.GetBuffer());
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Posts an Event to the sound engine (by Event name)
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information.</param>
  public static uint PostEvent(string in_pszEventName, ulong in_gameObjectID, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_6(in_pszEventName, in_gameObjectID, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Posts an Event to the sound engine (by Event name)
  ///
  ///  The Event must be loaded through a SoundBank before the call to PostEvent.
  ///  The callback function can be used to be notified when markers are reached or when the event is finished (see \ref AkCallbackType).
  ///  An array of wave file sources can be provided to resolve External Sources triggered by the event.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <remarks> If used, the array of external sources should contain the information for each external source triggered by the event. When triggering an event with multiple external sources, you need to differentiate each source by using the cookie property in the External Source in the Wwise project and in AkExternalSourceInfo. If an event triggers the playback of more than one external source, they must be named uniquely in the project (therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. If Wwise Authoring is connected to the game and "Profile And Edit (Sync All)" is used, the required Event doesn't have to be loaded before this function is called. If the Event is missing, it will be requested from Wwise Authoring directly, which might cause additional latency.</remarks>
  /// <seealso cref="
  ///  - \ref concept_events
  ///  - \ref integrating_external_sources
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static uint PostEvent(string in_pszEventName, ulong in_gameObjectID) {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostEvent__SWIG_7(in_pszEventName, in_gameObjectID);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}

  public static AkActionOnEventType AkActionOnEventType_Stop { get { return (AkActionOnEventType)AkUnitySoundEnginePINVOKE.CSharp_AkActionOnEventType_Stop_get(); } 
  }

  public static AkActionOnEventType AkActionOnEventType_Pause { get { return (AkActionOnEventType)AkUnitySoundEnginePINVOKE.CSharp_AkActionOnEventType_Pause_get(); } 
  }

  public static AkActionOnEventType AkActionOnEventType_Resume { get { return (AkActionOnEventType)AkUnitySoundEnginePINVOKE.CSharp_AkActionOnEventType_Resume_get(); } 
  }

  public static AkActionOnEventType AkActionOnEventType_Break { get { return (AkActionOnEventType)AkUnitySoundEnginePINVOKE.CSharp_AkActionOnEventType_Break_get(); } 
  }

  public static AkActionOnEventType AkActionOnEventType_ReleaseEnvelope { get { return (AkActionOnEventType)AkUnitySoundEnginePINVOKE.CSharp_AkActionOnEventType_ReleaseEnvelope_get(); } 
  }

  public static AkActionOnEventType AkActionOnEventType_Last { get { return (AkActionOnEventType)AkUnitySoundEnginePINVOKE.CSharp_AkActionOnEventType_Last_get(); } 
  }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param> 
  /// <param name="in_PlayingID"> Associated PlayingID</param>
  public static AKRESULT ExecuteActionOnEvent(uint in_eventID, AkActionOnEventType in_ActionType, ulong in_gameObjectID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve, uint in_PlayingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_0(in_eventID, (int)in_ActionType, in_gameObjectID, in_uTransitionDuration, (int)in_eFadeCurve, in_PlayingID); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static AKRESULT ExecuteActionOnEvent(uint in_eventID, AkActionOnEventType in_ActionType, ulong in_gameObjectID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_1(in_eventID, (int)in_ActionType, in_gameObjectID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static AKRESULT ExecuteActionOnEvent(uint in_eventID, AkActionOnEventType in_ActionType, ulong in_gameObjectID, int in_uTransitionDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_2(in_eventID, (int)in_ActionType, in_gameObjectID, in_uTransitionDuration); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT ExecuteActionOnEvent(uint in_eventID, AkActionOnEventType in_ActionType, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_3(in_eventID, (int)in_ActionType, in_gameObjectID); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param>
  public static AKRESULT ExecuteActionOnEvent(uint in_eventID, AkActionOnEventType in_ActionType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_4(in_eventID, (int)in_ActionType); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param> 
  /// <param name="in_PlayingID"> Associated PlayingID</param>
  public static AKRESULT ExecuteActionOnEvent(string in_pszEventName, AkActionOnEventType in_ActionType, ulong in_gameObjectID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve, uint in_PlayingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_5(in_pszEventName, (int)in_ActionType, in_gameObjectID, in_uTransitionDuration, (int)in_eFadeCurve, in_PlayingID); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static AKRESULT ExecuteActionOnEvent(string in_pszEventName, AkActionOnEventType in_ActionType, ulong in_gameObjectID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_6(in_pszEventName, (int)in_ActionType, in_gameObjectID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static AKRESULT ExecuteActionOnEvent(string in_pszEventName, AkActionOnEventType in_ActionType, ulong in_gameObjectID, int in_uTransitionDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_7(in_pszEventName, (int)in_ActionType, in_gameObjectID, in_uTransitionDuration); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT ExecuteActionOnEvent(string in_pszEventName, AkActionOnEventType in_ActionType, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_8(in_pszEventName, (int)in_ActionType, in_gameObjectID); }

  ///  Executes an action on all nodes that are referenced in the specified event in an action of type play.
  /// <returns>
  ///      - ``AK_Success`` if the action was successfully queued.
  ///      - ``AK_IDNotFound`` if the Event was not found (not loaded or there is a typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_ActionType"> Action to execute on all the elements that were played using the specified event.</param>
  public static AKRESULT ExecuteActionOnEvent(string in_pszEventName, AkActionOnEventType in_ActionType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnEvent__SWIG_9(in_pszEventName, (int)in_ActionType); }

  ///  Executes a number of MIDI Events on all nodes that are referenced in the specified Event in an Action of type Play.
  ///  The time at which a MIDI Event is posted is determined by in_bAbsoluteOffsets. If false, each MIDI event will be
  ///  posted in AkMIDIPost::uOffset samples from the start of the current frame. If true, each MIDI event will be posted
  ///  at the absolute time AkMIDIPost::uOffset samples.
  ///  To obtain the current absolute time, see AK::SoundEngine::GetSampleTick.
  ///  The duration of a sample can be determined from the sound engine's audio settings, via a call to AK::SoundEngine::GetAudioSettings.
  ///  If a playing ID is specified then that playing ID must be active. Otherwise a new playing ID will be assigned.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.GetAudioSettings
  ///  - AK.SoundEngine.GetSampleTick
  ///  - AK.SoundEngine.StopMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_pPosts"> MIDI Events to post</param> 
  /// <param name="in_uNumPosts"> Number of MIDI Events to post</param> 
  /// <param name="in_bAbsoluteOffsets"> Set to true when AkMIDIPost::uOffset are absolute, false when relative to current frame</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information</param> 
  /// <param name="in_playingID"> Target playing ID</param>
  public static uint PostMIDIOnEvent(uint in_eventID, ulong in_gameObjectID, AkMIDIPostArray in_pPosts, ushort in_uNumPosts, bool in_bAbsoluteOffsets, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie, uint in_playingID) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostMIDIOnEvent__SWIG_0(in_eventID, in_gameObjectID, in_pPosts.GetBuffer(), in_uNumPosts, in_bAbsoluteOffsets, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_playingID);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Executes a number of MIDI Events on all nodes that are referenced in the specified Event in an Action of type Play.
  ///  The time at which a MIDI Event is posted is determined by in_bAbsoluteOffsets. If false, each MIDI event will be
  ///  posted in AkMIDIPost::uOffset samples from the start of the current frame. If true, each MIDI event will be posted
  ///  at the absolute time AkMIDIPost::uOffset samples.
  ///  To obtain the current absolute time, see AK::SoundEngine::GetSampleTick.
  ///  The duration of a sample can be determined from the sound engine's audio settings, via a call to AK::SoundEngine::GetAudioSettings.
  ///  If a playing ID is specified then that playing ID must be active. Otherwise a new playing ID will be assigned.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.GetAudioSettings
  ///  - AK.SoundEngine.GetSampleTick
  ///  - AK.SoundEngine.StopMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_pPosts"> MIDI Events to post</param> 
  /// <param name="in_uNumPosts"> Number of MIDI Events to post</param> 
  /// <param name="in_bAbsoluteOffsets"> Set to true when AkMIDIPost::uOffset are absolute, false when relative to current frame</param> 
  /// <param name="in_uFlags"> Bitmask: see \ref AkCallbackType</param> 
  /// <param name="in_pfnCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie that will be sent to the callback function along with additional information</param>
  public static uint PostMIDIOnEvent(uint in_eventID, ulong in_gameObjectID, AkMIDIPostArray in_pPosts, ushort in_uNumPosts, bool in_bAbsoluteOffsets, uint in_uFlags, AkCallbackManager.EventCallback in_pfnCallback, object in_pCookie) {
	in_pCookie = AkCallbackManager.EventCallbackPackage.Create(in_pfnCallback, in_pCookie, ref in_uFlags);
    {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostMIDIOnEvent__SWIG_1(in_eventID, in_gameObjectID, in_pPosts.GetBuffer(), in_uNumPosts, in_bAbsoluteOffsets, in_uFlags, in_uFlags != 0 ? (global::System.IntPtr)1 : global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}
  }

  ///  Executes a number of MIDI Events on all nodes that are referenced in the specified Event in an Action of type Play.
  ///  The time at which a MIDI Event is posted is determined by in_bAbsoluteOffsets. If false, each MIDI event will be
  ///  posted in AkMIDIPost::uOffset samples from the start of the current frame. If true, each MIDI event will be posted
  ///  at the absolute time AkMIDIPost::uOffset samples.
  ///  To obtain the current absolute time, see AK::SoundEngine::GetSampleTick.
  ///  The duration of a sample can be determined from the sound engine's audio settings, via a call to AK::SoundEngine::GetAudioSettings.
  ///  If a playing ID is specified then that playing ID must be active. Otherwise a new playing ID will be assigned.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.GetAudioSettings
  ///  - AK.SoundEngine.GetSampleTick
  ///  - AK.SoundEngine.StopMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_pPosts"> MIDI Events to post</param> 
  /// <param name="in_uNumPosts"> Number of MIDI Events to post</param> 
  /// <param name="in_bAbsoluteOffsets"> Set to true when AkMIDIPost::uOffset are absolute, false when relative to current frame</param>
  public static uint PostMIDIOnEvent(uint in_eventID, ulong in_gameObjectID, AkMIDIPostArray in_pPosts, ushort in_uNumPosts, bool in_bAbsoluteOffsets) {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostMIDIOnEvent__SWIG_2(in_eventID, in_gameObjectID, in_pPosts.GetBuffer(), in_uNumPosts, in_bAbsoluteOffsets);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}

  ///  Executes a number of MIDI Events on all nodes that are referenced in the specified Event in an Action of type Play.
  ///  The time at which a MIDI Event is posted is determined by in_bAbsoluteOffsets. If false, each MIDI event will be
  ///  posted in AkMIDIPost::uOffset samples from the start of the current frame. If true, each MIDI event will be posted
  ///  at the absolute time AkMIDIPost::uOffset samples.
  ///  To obtain the current absolute time, see AK::SoundEngine::GetSampleTick.
  ///  The duration of a sample can be determined from the sound engine's audio settings, via a call to AK::SoundEngine::GetAudioSettings.
  ///  If a playing ID is specified then that playing ID must be active. Otherwise a new playing ID will be assigned.
  /// <returns>The playing ID of the event launched, or AK_INVALID_PLAYING_ID if posting the event failed and an error will be displayed in the debug console and the Wwise Profiler.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.GetAudioSettings
  ///  - AK.SoundEngine.GetSampleTick
  ///  - AK.SoundEngine.StopMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_pPosts"> MIDI Events to post</param> 
  /// <param name="in_uNumPosts"> Number of MIDI Events to post</param>
  public static uint PostMIDIOnEvent(uint in_eventID, ulong in_gameObjectID, AkMIDIPostArray in_pPosts, ushort in_uNumPosts) {
		uint ret = AkUnitySoundEnginePINVOKE.CSharp_PostMIDIOnEvent__SWIG_3(in_eventID, in_gameObjectID, in_pPosts.GetBuffer(), in_uNumPosts);
		if (ret != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
		{
			AkCallbackManager.SetLastAddedPlayingID(ret);
		}
		else
		{
			AkCallbackManager.RemoveEventCallback(AkUnitySoundEngine.AK_INVALID_PLAYING_ID);
		}
		return ret;
	}

  ///  Stops MIDI notes on all nodes that are referenced in the specified event in an action of type play,
  ///  with the specified Game Object. Invalid parameters are interpreted as wildcards. For example, calling
  ///  this function with in_eventID set to AK_INVALID_UNIQUE_ID will stop all MIDI notes for Game Object
  ///  in_gameObjectID.
  /// <returns>
  ///      - ``AK_Success`` if the stop command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PostMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_playingID"> Target playing ID</param>
  public static AKRESULT StopMIDIOnEvent(uint in_eventID, ulong in_gameObjectID, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StopMIDIOnEvent__SWIG_0(in_eventID, in_gameObjectID, in_playingID); }

  ///  Stops MIDI notes on all nodes that are referenced in the specified event in an action of type play,
  ///  with the specified Game Object. Invalid parameters are interpreted as wildcards. For example, calling
  ///  this function with in_eventID set to AK_INVALID_UNIQUE_ID will stop all MIDI notes for Game Object
  ///  in_gameObjectID.
  /// <returns>
  ///      - ``AK_Success`` if the stop command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PostMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT StopMIDIOnEvent(uint in_eventID, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StopMIDIOnEvent__SWIG_1(in_eventID, in_gameObjectID); }

  ///  Stops MIDI notes on all nodes that are referenced in the specified event in an action of type play,
  ///  with the specified Game Object. Invalid parameters are interpreted as wildcards. For example, calling
  ///  this function with in_eventID set to AK_INVALID_UNIQUE_ID will stop all MIDI notes for Game Object
  ///  in_gameObjectID.
  /// <returns>
  ///      - ``AK_Success`` if the stop command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PostMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  /// <param name="in_eventID"> Unique ID of the Event</param>
  public static AKRESULT StopMIDIOnEvent(uint in_eventID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StopMIDIOnEvent__SWIG_2(in_eventID); }

  ///  Stops MIDI notes on all nodes that are referenced in the specified event in an action of type play,
  ///  with the specified Game Object. Invalid parameters are interpreted as wildcards. For example, calling
  ///  this function with in_eventID set to AK_INVALID_UNIQUE_ID will stop all MIDI notes for Game Object
  ///  in_gameObjectID.
  /// <returns>
  ///      - ``AK_Success`` if the stop command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PostMIDIOnEvent
  ///  - \ref soundengine_midi_event_playing_id"/>
  public static AKRESULT StopMIDIOnEvent() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StopMIDIOnEvent__SWIG_3(); }

  ///  Starts streaming the first part of all streamed files referenced by an Event into a cache buffer. Caching streams are serviced when no other streams require the
  ///  available bandwidth. The files will remain cached until UnpinEventInStreamCache is called, or a higher priority pinned file needs the space and the limit set by
  ///  uMaxCachePinnedBytes is exceeded.
  /// <remarks>The amount of data from the start of the file that will be pinned to cache is determined by the prefetch size. The prefetch size is set via the authoring tool and stored in the sound banks.</remarks>
  /// <remarks>It is possible to override the prefetch size stored in the sound bank via the low level IO. For more information see AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() and AkFileSystemFlags.</remarks>
  /// <remarks>If this function is called additional times with the same event, then the priority of the caching streams are updated. Note however that priority is passed down to the stream manager	on a file-by-file basis, and if another event is pinned to cache that references the same file but with a different priority, then the first priority will be updated with the most recent value.</remarks>
  /// <remarks>If the event references files that are chosen based on a State Group (via a switch container), all files in all states will be cached. Those in the current active state will get cached with active priority, while all other files will get cached with inactive priority.</remarks>
  /// <remarks>in_uInactivePriority is only relevant for events that reference switch containers that are assigned to State Groups. This parameter is ignored for all other events, including events that only reference switch containers that are assigned to Switch Groups. Files that are chosen based on a Switch Group have a different switch value per game object, and are all effectively considered active by the pin-to-cache system.</remarks>
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.GetBufferStatusForPinnedEvent
  ///  - AK.SoundEngine.UnpinEventInStreamCache
  ///  - AK.StreamMgr.IAkLowLevelIOHook.BatchOpen
  ///  - AkFileSystemFlags"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_uActivePriority"> Priority of active stream caching I/O</param> 
  /// <param name="in_uInactivePriority"> Priority of inactive stream caching I/O</param>
  public static AKRESULT PinEventInStreamCache(uint in_eventID, sbyte in_uActivePriority, sbyte in_uInactivePriority) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PinEventInStreamCache__SWIG_0(in_eventID, in_uActivePriority, in_uInactivePriority); }

  ///  Starts streaming the first part of all streamed files referenced by an event into a cache buffer. Caching streams are serviced when no other streams require the
  ///  available bandwidth. The files will remain cached until UnpinEventInStreamCache is called, or a higher priority pinned file needs the space and the limit set by
  ///  uMaxCachePinnedBytes is exceeded.
  /// <remarks>The amount of data from the start of the file that will be pinned to cache is determined by the prefetch size. The prefetch size is set via the authoring tool and stored in the sound banks.</remarks>
  /// <remarks>It is possible to override the prefetch size stored in the sound bank via the low level IO. For more information see AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() and AkFileSystemFlags.</remarks>
  /// <remarks>If this function is called additional times with the same event, then the priority of the caching streams are updated. Note however that priority is passed down to the stream manager	on a file-by-file basis, and if another event is pinned to cache that references the same file but with a different priority, then the first priority will be updated with the most recent value.</remarks>
  /// <remarks>If the event references files that are chosen based on a State Group (via a Switch Container), all files in all states will be cached. Those in the current active state will get cached with active priority, while all other files will get cached with inactive priority.</remarks>
  /// <remarks>in_uInactivePriority is only relevant for events that reference switch containers that are assigned to State Groups. This parameter is ignored for all other events, including events that only reference switch containers that are assigned to Switch Groups. Files that are chosen based on a Switch Group have a different switch value per game object, and are all effectively considered active by the pin-to-cache system.</remarks>
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.GetBufferStatusForPinnedEvent
  ///  - AK.SoundEngine.UnpinEventInStreamCache
  ///  - AK.StreamMgr.IAkLowLevelIOHook.BatchOpen
  ///  - AkFileSystemFlags"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_uActivePriority"> Priority of active stream caching I/O</param> 
  /// <param name="in_uInactivePriority"> Priority of inactive stream caching I/O</param>
  public static AKRESULT PinEventInStreamCache(string in_pszEventName, sbyte in_uActivePriority, sbyte in_uInactivePriority) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PinEventInStreamCache__SWIG_1(in_pszEventName, in_uActivePriority, in_uInactivePriority); }

  ///  Releases the set of files that were previously requested to be pinned into cache via AK::SoundEngine::PinEventInStreamCache(). The file may still remain in stream cache
  ///  after AK::SoundEngine::UnpinEventInStreamCache() is called, until the memory is reused by the streaming memory manager in accordance with to its cache management algorithm.
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PinEventInStreamCache
  ///  - AK.SoundEngine.GetBufferStatusForPinnedEvent"/>
  /// <param name="in_eventID"> Unique ID of the event</param>
  public static AKRESULT UnpinEventInStreamCache(uint in_eventID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnpinEventInStreamCache__SWIG_0(in_eventID); }

  ///  Releases the set of files that were previously requested to be pinned into cache via AK::SoundEngine::PinEventInStreamCache(). The file may still remain in stream cache
  ///  after AK::SoundEngine::UnpinEventInStreamCache() is called, until the memory is reused by the streaming memory manager in accordance with to its cache management algorithm.
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PinEventInStreamCache
  ///  - AK.SoundEngine.GetBufferStatusForPinnedEvent"/>
  /// <param name="in_pszEventName"> Name of the event</param>
  public static AKRESULT UnpinEventInStreamCache(string in_pszEventName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnpinEventInStreamCache__SWIG_1(in_pszEventName); }

  ///  Returns information about an Event that was requested to be pinned into cache via AK::SoundEngine::PinEventInStreamCache().
  ///  Retrieves the smallest buffer fill-percentage for each file referenced by the event, and whether
  ///  the cache-pinned memory limit is preventing any of the files from filling up their buffer.
  /// <remarks>To set the limit for the maximum number of bytes that can be pinned to cache, see ``AkDeviceSettings``</remarks>
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PinEventInStreamCache
  ///  - AK.SoundEngine.UnpinEventInStreamCache
  ///  - AkDeviceSettings"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="out_fPercentBuffered"> Fill-percentage (out of 100) of requested buffer size for least buffered file in the event.</param> 
  /// <param name="out_bCachePinnedMemoryFull"> True if at least one file can not complete buffering because the cache-pinned memory limit would be exceeded.</param>
  public static AKRESULT GetBufferStatusForPinnedEvent(uint in_eventID, out float out_fPercentBuffered, out int out_bCachePinnedMemoryFull) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetBufferStatusForPinnedEvent__SWIG_0(in_eventID, out out_fPercentBuffered, out out_bCachePinnedMemoryFull); }

  ///  Returns information about an Event that was requested to be pinned into cache via AK::SoundEngine::PinEventInStreamCache().
  ///  Retrieves the smallest buffer fill-percentage for each file referenced by the event, and whether
  ///  the cache-pinned memory limit is preventing any of the files from filling up their buffer.
  /// <remarks>To set the limit for the maximum number of bytes that can be pinned to cache, see AkDeviceSettings</remarks>
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PinEventInStreamCache
  ///  - AK.SoundEngine.UnpinEventInStreamCache
  ///  - AkDeviceSettings"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="out_fPercentBuffered"> Fill-percentage (out of 100) of requested buffer size for least buffered file in the event.</param> 
  /// <param name="out_bCachePinnedMemoryFull"> True if at least one file can not complete buffering because the cache-pinned memory limit would be exceeded.</param>
  public static AKRESULT GetBufferStatusForPinnedEvent(string in_pszEventName, out float out_fPercentBuffered, out int out_bCachePinnedMemoryFull) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetBufferStatusForPinnedEvent__SWIG_1(in_pszEventName, out out_fPercentBuffered, out out_bCachePinnedMemoryFull); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, including Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- Sounds/segments are stopped if in_iPosition is greater than their duration.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Music segments cannot be looped. You may want to listen to the AK_EndOfEvent notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during that time
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_iPosition"> Desired position where playback should restart, in milliseconds</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)</param> 
  /// <param name="in_PlayingID"> Specify the playing ID for the seek to be applied to. Will result in the seek happening only on active actions of the playing ID. Let it be AK_INVALID_PLAYING_ID or do not specify any, to seek on all active actions of this event ID.</param>
  public static AKRESULT SeekOnEvent(uint in_eventID, ulong in_gameObjectID, int in_iPosition, bool in_bSeekToNearestMarker, uint in_PlayingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_0(in_eventID, in_gameObjectID, in_iPosition, in_bSeekToNearestMarker, in_PlayingID); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, including Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- Sounds/segments are stopped if in_iPosition is greater than their duration.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Music segments cannot be looped. You may want to listen to the AK_EndOfEvent notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during that time
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_iPosition"> Desired position where playback should restart, in milliseconds</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)</param>
  public static AKRESULT SeekOnEvent(uint in_eventID, ulong in_gameObjectID, int in_iPosition, bool in_bSeekToNearestMarker) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_1(in_eventID, in_gameObjectID, in_iPosition, in_bSeekToNearestMarker); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, including Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- Sounds/segments are stopped if in_iPosition is greater than their duration.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Music segments cannot be looped. You may want to listen to the AK_EndOfEvent notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during that time
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_iPosition"> Desired position where playback should restart, in milliseconds</param>
  public static AKRESULT SeekOnEvent(uint in_eventID, ulong in_gameObjectID, int in_iPosition) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_2(in_eventID, in_gameObjectID, in_iPosition); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Sounds/segments are stopped if in_iPosition is greater than their duration.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Music segments cannot be looped. You may want to listen to the AK_EndOfEvent notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during that time
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_iPosition"> Desired position where playback should restart, in milliseconds</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)</param> 
  /// <param name="in_PlayingID"> Specify the playing ID for the seek to be applied to. Will result in the seek happening only on active actions of the playing ID. Let it be AK_INVALID_PLAYING_ID or do not specify any, to seek on all active actions of this event ID.	</param>
  public static AKRESULT SeekOnEvent(string in_pszEventName, ulong in_gameObjectID, int in_iPosition, bool in_bSeekToNearestMarker, uint in_PlayingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_3(in_pszEventName, in_gameObjectID, in_iPosition, in_bSeekToNearestMarker, in_PlayingID); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Sounds/segments are stopped if in_iPosition is greater than their duration.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Music segments cannot be looped. You may want to listen to the AK_EndOfEvent notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during that time
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_iPosition"> Desired position where playback should restart, in milliseconds</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)</param>
  public static AKRESULT SeekOnEvent(string in_pszEventName, ulong in_gameObjectID, int in_iPosition, bool in_bSeekToNearestMarker) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_4(in_pszEventName, in_gameObjectID, in_iPosition, in_bSeekToNearestMarker); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Sounds/segments are stopped if in_iPosition is greater than their duration.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, in_iPosition is relative to the Entry Cue, in milliseconds. Use a negative
  /// 			value to seek within the Pre-Entry.
  /// 		- Music segments cannot be looped. You may want to listen to the AK_EndOfEvent notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during that time
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  /// <returns>
  ///      - ``AK_Success`` if command was queued
  ///      - ``AK_IDNotFound`` if the Event ID is unknown (not loaded or typo in the ID)</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_iPosition"> Desired position where playback should restart, in milliseconds</param>
  public static AKRESULT SeekOnEvent(string in_pszEventName, ulong in_gameObjectID, int in_iPosition) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_5(in_pszEventName, in_gameObjectID, in_iPosition); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Seek position is specified as a percentage of the sound's total duration, and takes looping into account.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, ``in_fPercent`` is relative to the Entry Cue, and the segment's duration is the
  /// 			duration between its entry and exit cues. Consequently, you cannot seek within the pre-entry or
  /// 			post-exit of a segment using this method. Use absolute values instead.
  /// 		- Music Segments cannot be looped. You may want to listen to the ``AK_EndOfEvent`` notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during the time that period
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_fPercent"> Desired position where playback should restart, expressed in a percentage of the file's total duration, between 0 and 1.f (see note above about infinite looping sounds)</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)	</param> 
  /// <param name="in_PlayingID"> Specify the playing ID for the seek to be applied to. Will result in the seek happening only on active actions of the playing ID. Let it be AK_INVALID_PLAYING_ID or do not specify any, to seek on all active actions of this event ID.	</param>
  public static AKRESULT SeekOnEvent(uint in_eventID, ulong in_gameObjectID, float in_fPercent, bool in_bSeekToNearestMarker, uint in_PlayingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_9(in_eventID, in_gameObjectID, in_fPercent, in_bSeekToNearestMarker, in_PlayingID); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Seek position is specified as a percentage of the sound's total duration, and takes looping into account.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, ``in_fPercent`` is relative to the Entry Cue, and the segment's duration is the
  /// 			duration between its entry and exit cues. Consequently, you cannot seek within the pre-entry or
  /// 			post-exit of a segment using this method. Use absolute values instead.
  /// 		- Music Segments cannot be looped. You may want to listen to the ``AK_EndOfEvent`` notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during the time that period
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_fPercent"> Desired position where playback should restart, expressed in a percentage of the file's total duration, between 0 and 1.f (see note above about infinite looping sounds)</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)	</param>
  public static AKRESULT SeekOnEvent(uint in_eventID, ulong in_gameObjectID, float in_fPercent, bool in_bSeekToNearestMarker) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_10(in_eventID, in_gameObjectID, in_fPercent, in_bSeekToNearestMarker); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Seek position is specified as a percentage of the sound's total duration, and takes looping into account.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- in_iPosition is clamped internally to the beginning of the sound/segment.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, ``in_fPercent`` is relative to the Entry Cue, and the segment's duration is the
  /// 			duration between its entry and exit cues. Consequently, you cannot seek within the pre-entry or
  /// 			post-exit of a segment using this method. Use absolute values instead.
  /// 		- Music Segments cannot be looped. You may want to listen to the ``AK_EndOfEvent`` notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during the time that period
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_eventID"> Unique ID of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_fPercent"> Desired position where playback should restart, expressed in a percentage of the file's total duration, between 0 and 1.f (see note above about infinite looping sounds)</param>
  public static AKRESULT SeekOnEvent(uint in_eventID, ulong in_gameObjectID, float in_fPercent) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_11(in_eventID, in_gameObjectID, in_fPercent); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Seek position is specified as a percentage of the sound's total duration, and takes looping into account.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, ``in_fPercent`` is relative to the Entry Cue, and the segment's duration is the
  /// 			duration between its entry and exit cues. Consequently, you cannot seek within the pre-entry or
  /// 			post-exit of a segment using this method. Use absolute values instead.
  /// 		- Music Segments cannot be looped. You may want to listen to the ``AK_EndOfEvent`` notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during the time that period
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_fPercent"> Desired position where playback should restart, expressed in a percentage of the file's total duration, between 0 and 1.f (see note above about infinite looping sounds)</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)	</param> 
  /// <param name="in_PlayingID"> Specify the playing ID for the seek to be applied to. Will result in the seek happening only on active actions of the playing ID. Let it be AK_INVALID_PLAYING_ID or do not specify any, to seek on all active actions of this event ID.	</param>
  public static AKRESULT SeekOnEvent(string in_pszEventName, ulong in_gameObjectID, float in_fPercent, bool in_bSeekToNearestMarker, uint in_PlayingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_12(in_pszEventName, in_gameObjectID, in_fPercent, in_bSeekToNearestMarker, in_PlayingID); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Seek position is specified as a percentage of the sound's total duration, and takes looping into account.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, ``in_fPercent`` is relative to the Entry Cue, and the segment's duration is the
  /// 			duration between its entry and exit cues. Consequently, you cannot seek within the pre-entry or
  /// 			post-exit of a segment using this method. Use absolute values instead.
  /// 		- Music Segments cannot be looped. You may want to listen to the ``AK_EndOfEvent`` notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during the time that period
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_fPercent"> Desired position where playback should restart, expressed in a percentage of the file's total duration, between 0 and 1.f (see note above about infinite looping sounds)</param> 
  /// <param name="in_bSeekToNearestMarker"> If true, the final seeking position will be made equal to the nearest marker (see note above)	</param>
  public static AKRESULT SeekOnEvent(string in_pszEventName, ulong in_gameObjectID, float in_fPercent, bool in_bSeekToNearestMarker) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_13(in_pszEventName, in_gameObjectID, in_fPercent, in_bSeekToNearestMarker); }

  ///  Seeks inside all playing objects that are referenced in Play Actions of the specified Event.
  ///  Seek position is specified as a percentage of the sound's total duration, and takes looping into account.
  ///  Notes:
  /// 		- This works with all objects of the Containers hierarchy, and also with Music Segments and Music Switch Containers.
  /// 		- There is a restriction with sounds that play within a continuous sequence. Seeking is ignored
  /// 			if one of their ancestors is a continuous (random or sequence) container with crossfade or
  /// 			trigger rate transitions. Seeking is also ignored with sample-accurate transitions, unless
  /// 			the sound that is currently playing is the first sound of the sequence.
  /// 		- Seeking is also ignored with voices that can go virtual with "From Beginning" behavior.
  /// 		- If the option "Seek to nearest marker" is used, the seeking position snaps to the nearest marker.
  /// 			With objects of the Containers hierarchy, markers are embedded in wave files by an external wave editor.
  /// 			Note that looping regions ("sampler loop") are not considered as markers. Also, the "add file name marker" of the
  /// 			conversion settings dialog adds a marker at the beginning of the file, which is considered when seeking
  /// 			to nearest marker. In the case of interactive music objects (Music Segments, Music Switch Containers, and Music Playlist Containers), user (wave) markers are ignored:
  /// 			seeking occurs to the nearest segment cue (authored in the segment editor), including the Entry Cue, but excluding the Exit Cue.
  /// 		- This method posts a command in the sound engine queue, thus seeking will not occur before
  /// 			the audio thread consumes it (after a call to RenderAudio()).
  /// 	Notes specific to Music Segments:
  /// 		- With Music Segments, ``in_fPercent`` is relative to the Entry Cue, and the segment's duration is the
  /// 			duration between its entry and exit cues. Consequently, you cannot seek within the pre-entry or
  /// 			post-exit of a segment using this method. Use absolute values instead.
  /// 		- Music Segments cannot be looped. You may want to listen to the ``AK_EndOfEvent`` notification
  /// 			in order to restart them if required.
  /// 		- In order to restart at the correct location, with all their tracks synchronized, Music Segments
  /// 			take the "look-ahead time" property of their streamed tracks into account for seeking.
  /// 			Consequently, the resulting position after a call to SeekOnEvent() might be earlier than the
  /// 			value that was passed to the method. Use AK::SoundEngine::GetPlayingSegmentInfo() to query
  /// 			the exact position of a segment. Also, the segment will be silent during the time that period
  /// 			(so that it restarts precisely at the position that you specified). AK::SoundEngine::GetPlayingSegmentInfo()
  /// 			also informs you about the remaining look-ahead time.
  ///  Notes specific to Music Switch Containers:
  /// 		- Seeking triggers a music transition towards the current (or target) segment.
  /// 			This transition is subject to the container's transition rule that matches the current and defined in the container,
  /// 			so the moment when seeking occurs depends on the rule's "Exit At" property. On the other hand, the starting position
  /// 			in the target segment depends on both the desired seeking position and the rule's "Sync To" property.
  /// 		- If the specified time is greater than the destination segment's length, the modulo is taken.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.RenderAudio"/>
  /// <param name="in_pszEventName"> Name of the event</param> 
  /// <param name="in_gameObjectID"> Associated game object ID; use AK_INVALID_GAME_OBJECT to affect all game objects</param> 
  /// <param name="in_fPercent"> Desired position where playback should restart, expressed in a percentage of the file's total duration, between 0 and 1.f (see note above about infinite looping sounds)</param>
  public static AKRESULT SeekOnEvent(string in_pszEventName, ulong in_gameObjectID, float in_fPercent) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SeekOnEvent__SWIG_14(in_pszEventName, in_gameObjectID, in_fPercent); }

  ///  Cancels all Event callbacks associated with a specific callback cookie.
  /// <seealso cref="
  ///  - AK.SoundEngine.PostEvent"/>
  /// <param name="in_pCookie"> Callback cookie to be cancelled</param>
  public static void CancelEventCallbackCookie(object in_pCookie) {
		AkCallbackManager.RemoveEventCallbackCookie(in_pCookie);
	}

  ///  Cancels all Event callbacks associated with a specific game object.
  /// <seealso cref="
  ///  - AK.SoundEngine.PostEvent"/>
  /// <param name="in_gameObjectID"> ID of the game object to be cancelled</param>
  public static void CancelEventCallbackGameObject(ulong in_gameObjectID) { AkUnitySoundEnginePINVOKE.CSharp_CancelEventCallbackGameObject(in_gameObjectID); }

  ///  Cancels all Event callbacks for a specific playing ID.
  /// <seealso cref="
  ///  - AK.SoundEngine.PostEvent"/>
  /// <param name="in_playingID"> Playing ID of the event that must not use callbacks</param>
  public static void CancelEventCallback(uint in_playingID) {
		AkCallbackManager.RemoveEventCallback(in_playingID);
	}

  ///  Gets the current position of the source associated with this playing ID, obtained from PostEvent(). If more than one source is playing,
  ///  the first to play is returned.
  ///  Notes:
  ///  - The source's position is updated at every audio frame, and the time at which this occurs is stored.
  /// 		When you call this function from your thread, you therefore query the position that was updated in the previous audio frame.
  /// 		If in_bExtrapolate is true (default), the returned position is extrapolated using the elapsed time since last
  /// 		sound engine update and the source's playback rate.
  /// <returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_InvalidParameter`` if the provided pointer is not valid.
  ///      - ``AK_PlayingIDNotFound`` if the playing ID is invalid (not playing yet, or finished playing).</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_query_pos
  ///  - \ref concept_events"/>
  /// <param name="in_PlayingID"> Playing ID returned by AK::SoundEngine::PostEvent()</param> 
  /// <param name="out_puPosition"> Position of the source (in ms) associated with the specified playing ID</param> 
  /// <param name="in_bExtrapolate"> Position is extrapolated based on time elapsed since last sound engine update.</param>
  public static AKRESULT GetSourcePlayPosition(uint in_PlayingID, out int out_puPosition, bool in_bExtrapolate) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSourcePlayPosition__SWIG_0(in_PlayingID, out out_puPosition, in_bExtrapolate); }

  ///  Gets the current position of the source associated with this playing ID, obtained from PostEvent(). If more than one source is playing,
  ///  the first to play is returned.
  ///  Notes:
  ///  - The source's position is updated at every audio frame, and the time at which this occurs is stored.
  /// 		When you call this function from your thread, you therefore query the position that was updated in the previous audio frame.
  /// 		If in_bExtrapolate is true (default), the returned position is extrapolated using the elapsed time since last
  /// 		sound engine update and the source's playback rate.
  /// <returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_InvalidParameter`` if the provided pointer is not valid.
  ///      - ``AK_PlayingIDNotFound`` if the playing ID is invalid (not playing yet, or finished playing).</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_query_pos
  ///  - \ref concept_events"/>
  /// <param name="in_PlayingID"> Playing ID returned by AK::SoundEngine::PostEvent()</param> 
  /// <param name="out_puPosition"> Position of the source (in ms) associated with the specified playing ID</param>
  public static AKRESULT GetSourcePlayPosition(uint in_PlayingID, out int out_puPosition) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSourcePlayPosition__SWIG_1(in_PlayingID, out out_puPosition); }

  ///  Query information on the active segment of a music object that is playing. Use the playing ID
  ///  that was returned from AK::SoundEngine::PostEvent(), provided that the event contained a play
  ///  action that was targeting a music object. For any interactive music object (Music Segments, Music Switch Containers, and Music Playlist Containers),
  ///  there is only one segment that is active at a time.
  ///  To be able to query segment information, you must pass the AK_EnableGetMusicPlayPosition flag
  ///  to the AK::SoundEngine::PostEvent() method. This informs the sound engine that the source associated
  ///  with this event should be given special consideration because GetPlayingSegmentInfo() can be called
  ///  at any time for this AkPlayingID.
  ///  Notes:
  ///  - If the music object is a single segment, you will get negative values for AkSegmentInfo::iCurrentPosition
  /// 		during the pre-entry. This will never occur with other types of music objects because the
  /// 		pre-entry of a segment always overlaps another active segment.
  /// 	- The active segment during the pre-entry of the first segment of a Playlist Container or a Music Switch
  /// 		Container is "nothing", as well as during the post-exit of the last segment of a Playlist (and beyond).
  /// 	- When the active segment is "nothing", out_uSegmentInfo is filled with zeros.
  ///  - If in_bExtrapolate is true (default), AkSegmentInfo::iCurrentPosition is corrected by the amount of time elapsed
  /// 		since the beginning of the audio frame. It is thus possible that it slightly overshoots the total segment length.
  /// <returns>AK_Success if there is a playing music structure associated with the specified playing ID.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PostEvent
  ///  - AkSegmentInfo"/>
  /// <param name="in_PlayingID"> Playing ID returned by AK::SoundEngine::PostEvent().</param> 
  /// <param name="out_segmentInfo"> Structure containing information about the active segment of the music structure that is playing.</param> 
  /// <param name="in_bExtrapolate"> Position is extrapolated based on time elapsed since last sound engine update.</param>
  public static AKRESULT GetPlayingSegmentInfo(uint in_PlayingID, AkSegmentInfo out_segmentInfo, bool in_bExtrapolate) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPlayingSegmentInfo__SWIG_0(in_PlayingID, AkSegmentInfo.getCPtr(out_segmentInfo), in_bExtrapolate); }

  ///  Query information on the active segment of a music object that is playing. Use the playing ID
  ///  that was returned from AK::SoundEngine::PostEvent(), provided that the event contained a play
  ///  action that was targeting a music object. For any interactive music object (Music Segments, Music Switch Containers, and Music Playlist Containers),
  ///  there is only one segment that is active at a time.
  ///  To be able to query segment information, you must pass the AK_EnableGetMusicPlayPosition flag
  ///  to the AK::SoundEngine::PostEvent() method. This informs the sound engine that the source associated
  ///  with this event should be given special consideration because GetPlayingSegmentInfo() can be called
  ///  at any time for this AkPlayingID.
  ///  Notes:
  ///  - If the music object is a single segment, you will get negative values for AkSegmentInfo::iCurrentPosition
  /// 		during the pre-entry. This will never occur with other types of music objects because the
  /// 		pre-entry of a segment always overlaps another active segment.
  /// 	- The active segment during the pre-entry of the first segment of a Playlist Container or a Music Switch
  /// 		Container is "nothing", as well as during the post-exit of the last segment of a Playlist (and beyond).
  /// 	- When the active segment is "nothing", out_uSegmentInfo is filled with zeros.
  ///  - If in_bExtrapolate is true (default), AkSegmentInfo::iCurrentPosition is corrected by the amount of time elapsed
  /// 		since the beginning of the audio frame. It is thus possible that it slightly overshoots the total segment length.
  /// <returns>AK_Success if there is a playing music structure associated with the specified playing ID.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.PostEvent
  ///  - AkSegmentInfo"/>
  /// <param name="in_PlayingID"> Playing ID returned by AK::SoundEngine::PostEvent().</param> 
  /// <param name="out_segmentInfo"> Structure containing information about the active segment of the music structure that is playing.</param>
  public static AKRESULT GetPlayingSegmentInfo(uint in_PlayingID, AkSegmentInfo out_segmentInfo) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPlayingSegmentInfo__SWIG_1(in_PlayingID, AkSegmentInfo.getCPtr(out_segmentInfo)); }

  ///  Gets the stream buffering of the sources associated with this playing ID, obtained from PostEvent().
  ///  Notes:
  ///  - You need to pass AK_EnableGetSourceStreamBuffering to PostEvent() in order to use this function, otherwise
  ///  	it returns AK_Fail, even if the playing ID is valid.
  ///  - The sources stream buffering is updated at every audio frame. If there are multiple sources associated with this playing ID,
  /// 		the value returned corresponds to the least buffered source.
  ///  - The returned buffering status out_bIsBuffering will be true If any of the sources associated with the playing ID are actively being buffered.
  /// 		It will be false if all of them have reached the end of file, or have reached a state where they are buffered enough and streaming is temporarily idle.
  ///  - Purely in-memory sources are excluded from this database. If all sources are in-memory, GetSourceStreamBuffering() will return AK_PlayingIDNotFound.
  ///  - The returned buffering amount and state is not completely accurate with some hardware-accelerated codecs. In such cases, the amount of stream buffering is generally underestimated.
  /// 		On the other hand, it is not guaranteed that the source will be ready to produce data at the next audio frame even if out_bIsBuffering has turned to false.
  /// <returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_PlayingIDNotFound`` if the source data associated with this playing ID is not found, for example if PostEvent() was not called with AK_EnableGetSourceStreamBuffering, or if the header was not parsed.</returns> 
  /// <seealso cref="
  ///  - \ref concept_events"/>
  /// <param name="in_PlayingID"> Playing ID returned by AK::SoundEngine::PostEvent()</param> 
  /// <param name="out_buffering"> Returned amount of buffering (in ms) of the source (or one of the sources) associated with that playing ID</param> 
  /// <param name="out_bIsBuffering"> Returned buffering status of the source(s) associated with that playing ID</param>
  public static AKRESULT GetSourceStreamBuffering(uint in_PlayingID, out int out_buffering, out int out_bIsBuffering) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSourceStreamBuffering(in_PlayingID, out out_buffering, out out_bIsBuffering); }

  ///  Stops the current content playing associated to the specified game object ID.
  ///  If no game object is specified, all sounds will be stopped.
  /// <param name="in_gameObjectID"> (Optional)Specify a game object to stop only playback associated to the provided game object ID.</param>
  public static void StopAll(ulong in_gameObjectID) { AkUnitySoundEnginePINVOKE.CSharp_StopAll__SWIG_0(in_gameObjectID); }

  /// Stops the current content playing associated to the specified game object ID.
  /// If no game object is specified, all sounds will be stopped.
  public static void StopAll() { AkUnitySoundEnginePINVOKE.CSharp_StopAll__SWIG_1(); }

  ///  Stop the current content playing associated to the specified playing ID.
  ///
  /// 	This function is deprecated. It is functionally identical to ExecuteActionOnPlayingID() using AkActionOnEventType_Stop.
  ///  API call in Wwise Capture Log will show ExecuteActionOnPlayingID when calling this function.
  ///  Use ExecuteActionOnPlayingID() instead.
  /// <seealso cref="
  ///   - AK.SoundEngine.ExecuteActionOnPlayingID"/>
  /// <param name="in_playingID"> Playing ID to be stopped.</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static void StopPlayingID(uint in_playingID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { AkUnitySoundEnginePINVOKE.CSharp_StopPlayingID__SWIG_0(in_playingID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Stop the current content playing associated to the specified playing ID.
  ///
  /// 	This function is deprecated. It is functionally identical to ExecuteActionOnPlayingID() using AkActionOnEventType_Stop.
  ///  API call in Wwise Capture Log will show ExecuteActionOnPlayingID when calling this function.
  ///  Use ExecuteActionOnPlayingID() instead.
  /// <seealso cref="
  ///   - AK.SoundEngine.ExecuteActionOnPlayingID"/>
  /// <param name="in_playingID"> Playing ID to be stopped.</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static void StopPlayingID(uint in_playingID, int in_uTransitionDuration) { AkUnitySoundEnginePINVOKE.CSharp_StopPlayingID__SWIG_1(in_playingID, in_uTransitionDuration); }

  ///  Stop the current content playing associated to the specified playing ID.
  ///
  /// 	This function is deprecated. It is functionally identical to ExecuteActionOnPlayingID() using AkActionOnEventType_Stop.
  ///  API call in Wwise Capture Log will show ExecuteActionOnPlayingID when calling this function.
  ///  Use ExecuteActionOnPlayingID() instead.
  /// <seealso cref="
  ///   - AK.SoundEngine.ExecuteActionOnPlayingID"/>
  /// <param name="in_playingID"> Playing ID to be stopped.</param>
  public static void StopPlayingID(uint in_playingID) { AkUnitySoundEnginePINVOKE.CSharp_StopPlayingID__SWIG_2(in_playingID); }

  ///  Executes an Action on the content associated to the specified playing ID.
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_ActionType"> Action to execute on the specified playing ID.</param> 
  /// <param name="in_playingID"> Playing ID on which to execute the action.</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the transition</param>
  public static void ExecuteActionOnPlayingID(AkActionOnEventType in_ActionType, uint in_playingID, int in_uTransitionDuration, AkCurveInterpolation in_eFadeCurve) { AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnPlayingID__SWIG_0((int)in_ActionType, in_playingID, in_uTransitionDuration, (int)in_eFadeCurve); }

  ///  Executes an Action on the content associated to the specified playing ID.
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_ActionType"> Action to execute on the specified playing ID.</param> 
  /// <param name="in_playingID"> Playing ID on which to execute the action.</param> 
  /// <param name="in_uTransitionDuration"> Fade duration</param>
  public static void ExecuteActionOnPlayingID(AkActionOnEventType in_ActionType, uint in_playingID, int in_uTransitionDuration) { AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnPlayingID__SWIG_1((int)in_ActionType, in_playingID, in_uTransitionDuration); }

  ///  Executes an Action on the content associated to the specified playing ID.
  /// <seealso cref="
  ///  - AkActionOnEventType"/>
  /// <param name="in_ActionType"> Action to execute on the specified playing ID.</param> 
  /// <param name="in_playingID"> Playing ID on which to execute the action.</param>
  public static void ExecuteActionOnPlayingID(AkActionOnEventType in_ActionType, uint in_playingID) { AkUnitySoundEnginePINVOKE.CSharp_ExecuteActionOnPlayingID__SWIG_2((int)in_ActionType, in_playingID); }

  ///  Sets the random seed value. Can be used to synchronize randomness
  ///  across instances of the Sound Engine.
  /// <remarks>This seeds the number generator used for all container randomization         and the plug-in RNG; since it acts globally, this should be called right         before any PostEvent call where randomness synchronization is required,         and cannot guarantee similar results for continuous containers.</remarks>
  /// <seealso cref="
  ///  - AK.IAkPluginServiceRNG"/>
  /// <param name="in_uSeed"> Random seed.</param>
  public static void SetRandomSeed(uint in_uSeed) { AkUnitySoundEnginePINVOKE.CSharp_SetRandomSeed(in_uSeed); }

  ///  Mutes/Unmutes the busses tagged as background music.
  ///  This is automatically called for platforms that have user-music support.
  ///  This function is provided to give the same behavior on platforms that don't have user-music support.
  /// <param name="in_bMute"> Sets true to mute, false to unmute.</param>
  public static void MuteBackgroundMusic(bool in_bMute) { AkUnitySoundEnginePINVOKE.CSharp_MuteBackgroundMusic(in_bMute); }

  ///  Gets the state of the Background Music busses. This state is either set directly
  ///  with ``AK::SoundEngine::MuteBackgroundMusic`` or by the OS, if it has User Music services.
  /// <returns>true if the background music busses are muted, false if not.</returns>
  public static bool GetBackgroundMusicMute() { return AkUnitySoundEnginePINVOKE.CSharp_GetBackgroundMusicMute(); }

  ///  Sends custom game data to a plug-in that resides on a bus (insert Effect or mixer plug-in).
  ///  Data will be copied and stored into a separate list.
  ///  Previous entry is deleted when a new one is sent.
  ///  Sets the data pointer to NULL to clear item from the list.
  ///  The plug-in type and ID are passed and matched with plugins set on the desired bus.
  ///  This means that you cannot send different data to various instances of a plug-in on the same bus.
  /// <returns>AK_Success if data was sent successfully.</returns> 
  /// <param name="in_busID"> Bus ID</param> 
  /// <param name="in_busObjectID"> Bus Object ID. Pass AK_INVALID_GAME_OBJECT to send custom data with global scope. Game object scope supersedes global scope, as with RTPCs.</param> 
  /// <param name="in_eType"> Plug-in type (for example, source or effect)</param> 
  /// <param name="in_uCompanyID"> Company identifier (as declared in the plug-in description XML file)</param> 
  /// <param name="in_uPluginID"> Plug-in identifier (as declared in the plug-in description XML file)</param> 
  /// <param name="in_pData"> The data blob</param> 
  /// <param name="in_uSizeInBytes"> Size of data</param>
  public static AKRESULT SendPluginCustomGameData(uint in_busID, ulong in_busObjectID, AkPluginType in_eType, uint in_uCompanyID, uint in_uPluginID, global::System.IntPtr in_pData, uint in_uSizeInBytes) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SendPluginCustomGameData(in_busID, in_busObjectID, (int)in_eType, in_uCompanyID, in_uPluginID, in_pData, in_uSizeInBytes); }

  ///  Unregister all game objects, or all game objects with a particular matching set of property flags.
  ///  This function to can be used to unregister all game objects.
  /// <returns>
  ///      - ``AK_Success`` if successful</returns> 
  /// <remarks>Registering a game object twice does nothing. Unregistering it once unregisters it no			matter how many times it has been registered. Unregistering a game object while it is			in use is allowed, but the control over the parameters of this game object is lost.			For example, if a sound associated with this game object is a 3D moving sound, it will			stop moving once the game object is unregistered, and there will be no way to recover			the control over this game object.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.RegisterGameObj"/>
  public static AKRESULT UnregisterAllGameObj() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnregisterAllGameObj(); }

  ///  Sets multiple positions to a single game object.
  ///  Setting multiple positions on a single game object is a way to simulate multiple emission sources while using the resources of only one voice.
  ///  This can be used to simulate wall openings, area sounds, or multiple objects emitting the same sound in the same area.
  ///
  ///  - Calling AK::SoundEngine::SetMultiplePositions() with only one position is the same as calling AK::SoundEngine::SetPosition()
  ///  - If a sound has diffraction enabled, it is treated as AkMultiPositionType_MultiDirections. AkMultiPositionType_MultiSources is not supported in this case.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_CommandTooLarge`` if the number of positions is too large for the command queue. Reduce the number of positions.
  ///      - ``AK_InvalidParameter`` if parameters are not valid, for example:
  ///      + in_Position makes an invalid transform
  ///      + in_eFlags is not one of the valid enum values
  ///      + the game object ID is in the reserved ID range.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions
  ///  - \ref soundengine_3dpositions_multiplepos
  ///  - \ref AkMultiPositionType"/>
  /// <param name="in_GameObjectID"> Game Object identifier.</param> 
  /// <param name="in_pPositions"> Array of positions to apply.</param> 
  /// <param name="in_NumPositions"> Number of positions specified in the provided array.</param> 
  /// <param name="in_eMultiPositionType"> \ref AkMultiPositionType</param> 
  /// <param name="in_eFlags"> Optional flags to independently set the position of the emitter or listener component.</param>
  public static AKRESULT SetMultiplePositions(ulong in_GameObjectID, AkPositionArray in_pPositions, ushort in_NumPositions, AkMultiPositionType in_eMultiPositionType, AkSetPositionFlags in_eFlags) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultiplePositions__SWIG_0(in_GameObjectID, in_pPositions.m_Buffer, in_NumPositions, (int)in_eMultiPositionType, (int)in_eFlags); }

  ///  Sets multiple positions to a single game object.
  ///  Setting multiple positions on a single game object is a way to simulate multiple emission sources while using the resources of only one voice.
  ///  This can be used to simulate wall openings, area sounds, or multiple objects emitting the same sound in the same area.
  ///
  ///  - Calling AK::SoundEngine::SetMultiplePositions() with only one position is the same as calling AK::SoundEngine::SetPosition()
  ///  - If a sound has diffraction enabled, it is treated as AkMultiPositionType_MultiDirections. AkMultiPositionType_MultiSources is not supported in this case.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_CommandTooLarge`` if the number of positions is too large for the command queue. Reduce the number of positions.
  ///      - ``AK_InvalidParameter`` if parameters are not valid, for example:
  ///      + in_Position makes an invalid transform
  ///      + in_eFlags is not one of the valid enum values
  ///      + the game object ID is in the reserved ID range.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions
  ///  - \ref soundengine_3dpositions_multiplepos
  ///  - \ref AkMultiPositionType"/>
  /// <param name="in_GameObjectID"> Game Object identifier.</param> 
  /// <param name="in_pPositions"> Array of positions to apply.</param> 
  /// <param name="in_NumPositions"> Number of positions specified in the provided array.</param> 
  /// <param name="in_eMultiPositionType"> \ref AkMultiPositionType</param>
  public static AKRESULT SetMultiplePositions(ulong in_GameObjectID, AkPositionArray in_pPositions, ushort in_NumPositions, AkMultiPositionType in_eMultiPositionType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultiplePositions__SWIG_1(in_GameObjectID, in_pPositions.m_Buffer, in_NumPositions, (int)in_eMultiPositionType); }

  ///  Sets multiple positions to a single game object.
  ///  Setting multiple positions on a single game object is a way to simulate multiple emission sources while using the resources of only one voice.
  ///  This can be used to simulate wall openings, area sounds, or multiple objects emitting the same sound in the same area.
  ///
  ///  - Calling AK::SoundEngine::SetMultiplePositions() with only one position is the same as calling AK::SoundEngine::SetPosition()
  ///  - If a sound has diffraction enabled, it is treated as AkMultiPositionType_MultiDirections. AkMultiPositionType_MultiSources is not supported in this case.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_CommandTooLarge`` if the number of positions is too large for the command queue. Reduce the number of positions.
  ///      - ``AK_InvalidParameter`` if parameters are not valid, for example:
  ///      + in_Position makes an invalid transform
  ///      + in_eFlags is not one of the valid enum values
  ///      + the game object ID is in the reserved ID range.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions
  ///  - \ref soundengine_3dpositions_multiplepos
  ///  - \ref AkMultiPositionType"/>
  /// <param name="in_GameObjectID"> Game Object identifier.</param> 
  /// <param name="in_pPositions"> Array of positions to apply.</param> 
  /// <param name="in_NumPositions"> Number of positions specified in the provided array.</param>
  public static AKRESULT SetMultiplePositions(ulong in_GameObjectID, AkPositionArray in_pPositions, ushort in_NumPositions) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultiplePositions__SWIG_2(in_GameObjectID, in_pPositions.m_Buffer, in_NumPositions); }

  ///  Sets multiple positions to a single game object, with flexible assignment of input channels.
  ///  Setting multiple positions on a single game object is a way to simulate multiple emission sources while using the resources of only one voice.
  ///  This can be used to simulate wall openings, area sounds, or multiple objects emitting the same sound in the same area.
  ///  Calling AK::SoundEngine::SetMultiplePositions() with only one position is the same as calling AK::SoundEngine::SetPosition()
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_CommandTooLarge`` if the number of positions is too large for the command queue. Reduce the number of positions.
  ///      - ``AK_InvalidParameter`` if parameters are not valid.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions
  ///  - \ref soundengine_3dpositions_multiplepos
  ///  - \ref AkMultiPositionType"/>
  /// <param name="in_GameObjectID"> Game Object identifier.</param> 
  /// <param name="in_pPositions"> Array of positions to apply, each using its own channel mask.</param> 
  /// <param name="in_NumPositions"> Number of positions specified in the provided array.</param> 
  /// <param name="in_eMultiPositionType"> \ref AkMultiPositionType</param> 
  /// <param name="in_eFlags"> Optional flags to independently set the position of the emitter or listener component.</param>
  public static AKRESULT SetMultiplePositions(ulong in_GameObjectID, AkChannelEmitterArray in_pPositions, ushort in_NumPositions, AkMultiPositionType in_eMultiPositionType, AkSetPositionFlags in_eFlags) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultiplePositions__SWIG_3(in_GameObjectID, in_pPositions.m_Buffer, in_NumPositions, (int)in_eMultiPositionType, (int)in_eFlags); }

  ///  Sets multiple positions to a single game object, with flexible assignment of input channels.
  ///  Setting multiple positions on a single game object is a way to simulate multiple emission sources while using the resources of only one voice.
  ///  This can be used to simulate wall openings, area sounds, or multiple objects emitting the same sound in the same area.
  ///  Calling AK::SoundEngine::SetMultiplePositions() with only one position is the same as calling AK::SoundEngine::SetPosition()
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_CommandTooLarge`` if the number of positions is too large for the command queue. Reduce the number of positions.
  ///      - ``AK_InvalidParameter`` if parameters are not valid.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions
  ///  - \ref soundengine_3dpositions_multiplepos
  ///  - \ref AkMultiPositionType"/>
  /// <param name="in_GameObjectID"> Game Object identifier.</param> 
  /// <param name="in_pPositions"> Array of positions to apply, each using its own channel mask.</param> 
  /// <param name="in_NumPositions"> Number of positions specified in the provided array.</param> 
  /// <param name="in_eMultiPositionType"> \ref AkMultiPositionType</param>
  public static AKRESULT SetMultiplePositions(ulong in_GameObjectID, AkChannelEmitterArray in_pPositions, ushort in_NumPositions, AkMultiPositionType in_eMultiPositionType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultiplePositions__SWIG_4(in_GameObjectID, in_pPositions.m_Buffer, in_NumPositions, (int)in_eMultiPositionType); }

  ///  Sets multiple positions to a single game object, with flexible assignment of input channels.
  ///  Setting multiple positions on a single game object is a way to simulate multiple emission sources while using the resources of only one voice.
  ///  This can be used to simulate wall openings, area sounds, or multiple objects emitting the same sound in the same area.
  ///  Calling AK::SoundEngine::SetMultiplePositions() with only one position is the same as calling AK::SoundEngine::SetPosition()
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_CommandTooLarge`` if the number of positions is too large for the command queue. Reduce the number of positions.
  ///      - ``AK_InvalidParameter`` if parameters are not valid.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions
  ///  - \ref soundengine_3dpositions_multiplepos
  ///  - \ref AkMultiPositionType"/>
  /// <param name="in_GameObjectID"> Game Object identifier.</param> 
  /// <param name="in_pPositions"> Array of positions to apply, each using its own channel mask.</param> 
  /// <param name="in_NumPositions"> Number of positions specified in the provided array.</param>
  public static AKRESULT SetMultiplePositions(ulong in_GameObjectID, AkChannelEmitterArray in_pPositions, ushort in_NumPositions) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultiplePositions__SWIG_5(in_GameObjectID, in_pPositions.m_Buffer, in_NumPositions); }

  ///  Sets the scaling factor of a Game Object.
  ///  Modify the attenuation computations on this Game Object to simulate sounds with a larger or smaller area of effect.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidParameter`` if the scaling factor specified was 0 or negative.
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf</returns> 
  /// <param name="in_GameObjectID"> Game object identifier</param> 
  /// <param name="in_fAttenuationScalingFactor"> Scaling Factor, 1 means 100%, 0.5 means 50%, 2 means 200%, and so on.</param>
  public static AKRESULT SetScalingFactor(ulong in_GameObjectID, float in_fAttenuationScalingFactor) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetScalingFactor(in_GameObjectID, in_fAttenuationScalingFactor); }

  ///  Use the position of a separate game object for distance calculations for a specified listener.
  ///  When AK::SoundEngine::SetDistanceProbe() is called, Wwise calculates distance attenuation and filtering
  ///  based on the distance between the distance probe Game Object (``in_distanceProbeGameObjectID)`` and the emitter Game Object's position.
  ///  In third-person perspective applications, the distance probe Game Object may be set to the player character's position,
  ///  and the listener Game Object's position to that of the camera. In this scenario, attenuation is based on
  ///  the distance between the character and the sound, whereas panning, spatialization, and spread and focus calculations are base on the camera.
  ///  Both Game Objects, ``in_listenerGameObjectID`` and ``in_distanceProbeGameObjectID`` must have been previously registered using AK::SoundEngine::RegisterGameObj.
  ///  This function is optional. if AK::SoundEngine::SetDistanceProbe() is never called, distance calculations are based on the listener Game Object position.
  ///  To clear the distance probe, and revert to using the listener position for distance calculations, pass ``AK_INVALID_GAME_OBJECT`` to ``in_distanceProbeGameObjectID``.
  ///  If the distance probe Game Object is assigned multiple positions, then the first position is used for distance calculations by the listener.
  /// <returns>
  ///      - ``AK_Success`` when successful</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.SetPosition"/>
  /// <param name="in_listenerGameObjectID"> Game object identifier for the listener. Must have been previously registered via RegisterGameObj.</param> 
  /// <param name="in_distanceProbeGameObjectID"> Game object identifier for the distance probe, or ``AK_INVALID_GAME_OBJECT`` to reset distance probe.  If valid, must have been previously registered via RegisterGameObj.</param>
  public static AKRESULT SetDistanceProbe(ulong in_listenerGameObjectID, ulong in_distanceProbeGameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetDistanceProbe(in_listenerGameObjectID, in_distanceProbeGameObjectID); }

  ///  Processes all pending asynchronous bank operations.
  ///  This function must be called periodically (once per game frame) when using asynchronous bank-loading functions.
  ///  When AkInitSettings::bUseSoundBankMgrThread is false, this function processes all pending operations immediately on the calling thread.
  ///  When AkInitSettings::bUseSoundBankMgrThread is false, this function is not thread-safe. There should be a dedicated thread to call
  ///  this function every game frame. In addition, synchronous Bank and Prepare calls implicitely call this function. Therefore, synchronous Bank and Prepare
  ///  calls should always be called from the same thread that is calling AK::SoundEngine::ProcessBanks.
  ///
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank
  ///  - AK.SoundEngine.PrepareEvent
  ///  - \ref goingfurther_eventmgrthread"/>
  public static void ProcessBanks() { AkUnitySoundEnginePINVOKE.CSharp_ProcessBanks(); }

  ///  Unload all currently loaded banks.
  ///  It also internally calls ClearPreparedEvents() since at least one bank must have been loaded to allow preparing events.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized or if there is not enough memory to handle the command</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  public static AKRESULT ClearBanks() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ClearBanks(); }

  ///  Sets the I/O settings of the bank load and prepare event processes.
  ///  The sound engine uses default values unless explicitly set by calling this method.
  /// <remarks>This function must be called before loading banks.</remarks><returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_banks
  ///  - \ref streamingdevicemanager"/>
  /// <param name="in_fThroughput"> Average throughput of bank data streaming (bytes/ms) (the default value is AK_DEFAULT_BANK_THROUGHPUT)</param> 
  /// <param name="in_priority"> Priority of bank streaming (the default value is AK_DEFAULT_PRIORITY)</param>
  public static AKRESULT SetBankLoadIOSettings(float in_fThroughput, sbyte in_priority) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBankLoadIOSettings(in_fThroughput, in_priority); }

  ///  Load a bank synchronously (by Unicode string).
  ///
  ///  The bank name and type are passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console
  ///      - ``AK_InvalidBankType`` if the bank type parameter is out of range.
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure, check the debug console)</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The sound engine internally calls GetIDFromString(in_pszString) to return the correct bank ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. The path should be resolved in your implementation of the Stream Manager, or in the Low-Level I/O module if you use the default Stream Manager's implementation. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will return AK_Success even if the file is not found. The Capture Log will still report the missing file. For example, this will be the case when SoundBanks were not generated. If this option is selected, you can work without SoundBanks as long as Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pszString"> Name of the bank to load</param> 
  /// <param name="out_bankID"> Returned bank ID</param> 
  /// <param name="in_bankType"> Type of the bank to load</param>
  public static AKRESULT LoadBank(string in_pszString, out uint out_bankID, uint in_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_0(in_pszString, out out_bankID, in_bankType); }

  ///  Load a bank synchronously (by Unicode string).
  ///
  ///  The bank name and type are passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console
  ///      - ``AK_InvalidBankType`` if the bank type parameter is out of range.
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure, check the debug console)</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The sound engine internally calls GetIDFromString(in_pszString) to return the correct bank ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. The path should be resolved in your implementation of the Stream Manager, or in the Low-Level I/O module if you use the default Stream Manager's implementation. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will return AK_Success even if the file is not found. The Capture Log will still report the missing file. For example, this will be the case when SoundBanks were not generated. If this option is selected, you can work without SoundBanks as long as Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pszString"> Name of the bank to load</param> 
  /// <param name="out_bankID"> Returned bank ID</param>
  public static AKRESULT LoadBank(string in_pszString, out uint out_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_1(in_pszString, out out_bankID); }

  ///  Loads a bank synchronously (by ID).
  ///
  ///  Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  The bank ID is passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error. The bank is either shorter than expected or its data corrupted.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console or Wwise Profiler
  ///      - ``AK_InvalidBankType`` if the bank type parameter is out of range.
  ///      - ``AK_FileNotFound`` if the bank file was not found on disk.
  ///      - ``AK_FilePermissionError`` if the file permissions are wrong for the file
  ///      - ``AK_Fail``: Load or unload failed for any other reason. , check the debug console or Wwise Profiler</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will return AK_Success even if the file is not found. The Capture Log will still report the missing file. For example, this will be the case when SoundBanks were not generated. If this option is selected, you can work without SoundBanks as long as Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_bankID"> Bank ID of the bank to load</param> 
  /// <param name="in_bankType"> Type of the bank to load</param>
  public static AKRESULT LoadBank(uint in_bankID, uint in_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_4(in_bankID, in_bankType); }

  ///  Loads a bank synchronously (by ID).
  ///
  ///  Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  The bank ID is passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error. The bank is either shorter than expected or its data corrupted.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console or Wwise Profiler
  ///      - ``AK_InvalidBankType`` if the bank type parameter is out of range.
  ///      - ``AK_FileNotFound`` if the bank file was not found on disk.
  ///      - ``AK_FilePermissionError`` if the file permissions are wrong for the file
  ///      - ``AK_Fail``: Load or unload failed for any other reason. , check the debug console or Wwise Profiler</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will return AK_Success even if the file is not found. The Capture Log will still report the missing file. For example, this will be the case when SoundBanks were not generated. If this option is selected, you can work without SoundBanks as long as Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_bankID"> Bank ID of the bank to load</param>
  public static AKRESULT LoadBank(uint in_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_5(in_bankID); }

  ///  Loads a bank synchronously (from in-memory data, in-place, user bank only).
  ///  IMPORTANT: Banks loaded from memory with in-place data MUST be unloaded using the UnloadBank function
  ///  providing the same memory pointer. Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryView when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine.
  ///  In-memory loading is in-place: *** the memory must be valid until the bank is unloaded. ***
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      The bank ID, which is stored in the first few bytes of the bank file. You may use this
  ///      ID with UnloadBank().
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console
  ///      - ``AK_InvalidBankType`` if the bank is not a user-defined bank.
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The memory must be aligned on platform-specific AK_BANK_PLATFORM_DATA_ALIGNMENT bytes (see AkTypes.h). - Avoid using this function for banks containing a lot of events or structure data: this data will be unpacked into the sound engine heap,   making the supplied bank memory redundant. For event/structure-only banks, prefer LoadBankMemoryCopy().</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is stored in sound engine, memory must remain valid)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="out_bankID"> Returned bank ID</param>
  public static AKRESULT LoadBankMemoryView(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, out uint out_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryView__SWIG_0(in_pInMemoryBankPtr, in_uInMemoryBankSize, out out_bankID); }

  ///  Loads a bank synchronously (from in-memory data, in-place, any bank type).
  ///  IMPORTANT: Banks loaded from memory with in-place data MUST be unloaded using the UnloadBank function
  ///  providing the same memory pointer. Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryView when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine.
  ///  In-memory loading is in-place: *** the memory must be valid until the bank is unloaded. ***
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      The bank ID, which is stored in the first few bytes of the bank file. You may use this
  ///      ID with UnloadBank().
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The memory must be aligned on platform-specific AK_BANK_PLATFORM_DATA_ALIGNMENT bytes (see AkTypes.h). - Avoid using this function for banks containing a lot of events or structure data: this data will be unpacked into the sound engine heap,   making the supplied bank memory redundant. For event/structure-only banks, prefer LoadBankMemoryCopy().</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is stored in sound engine, memory must remain valid)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="out_bankID"> Returned bank ID</param> 
  /// <param name="out_bankType"> Returned bank type</param>
  public static AKRESULT LoadBankMemoryView(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, out uint out_bankID, out uint out_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryView__SWIG_1(in_pInMemoryBankPtr, in_uInMemoryBankSize, out out_bankID, out out_bankType); }

  ///  Loads a bank synchronously (from in-memory data, out-of-place, user bank only).
  ///  NOTE: Banks loaded from in-memory with out-of-place data must be unloaded using the standard UnloadBank function
  ///  (with no memory pointer). Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryCopy when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine, the media section of the bank will be copied into newly
  ///  allocated memory.
  ///  In-memory loading is out-of-place: the buffer can be release as soon as the function returns. The advantage of using this
  ///  over the in-place version is that there is no duplication of bank structures.
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      The bank ID, which is stored in the first few bytes of the bank file. You may use this
  ///      ID with UnloadBank().
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console
  ///      - ``AK_InvalidBankType`` if the bank is not a user-defined bank.
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is not stored in sound engine, memory can be released after return)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="out_bankID"> Returned bank ID</param>
  public static AKRESULT LoadBankMemoryCopy(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, out uint out_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryCopy__SWIG_0(in_pInMemoryBankPtr, in_uInMemoryBankSize, out out_bankID); }

  ///  Loads a bank synchronously (from in-memory data, out-of-place, any bank type).
  ///  NOTE: Banks loaded from in-memory with out-of-place data must be unloaded using the standard UnloadBank function
  ///  (with no memory pointer). Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryCopy when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine, the media section of the bank will be copied into newly
  ///  allocated memory.
  ///  In-memory loading is out-of-place: the buffer can be release as soon as the function returns. The advantage of using this
  ///  over the in-place version is that there is no duplication of bank structures.
  ///  A bank load request will be posted, and consumed by the Bank Manager thread.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      The bank ID, which is stored in the first few bytes of the bank file. You may use this
  ///      ID with UnloadBank().
  ///      - ``AK_Success``: Load or unload successful.
  ///      - ``AK_BankAlreadyLoaded``: This bank is already loaded, nothing done.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_NotInitialized`` if the sound engine was not correctly initialized
  ///      - ``AK_InvalidParameter`` if some parameters are invalid, check the debug console
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is not stored in sound engine, memory can be released after return)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="out_bankID"> Returned bank ID</param> 
  /// <param name="out_bankType"> Returned bank type</param>
  public static AKRESULT LoadBankMemoryCopy(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, out uint out_bankID, out uint out_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryCopy__SWIG_1(in_pInMemoryBankPtr, in_uInMemoryBankSize, out out_bankID, out out_bankType); }

  ///  Loads a bank asynchronously (by Unicode string).
  ///
  ///  The bank name is passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      AK_Success if the scheduling was successful, AK_Fail otherwise.
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The sound engine internally calls GetIDFromString(in_pszString) to return the correct bank ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. The path should be resolved in your implementation of the Stream Manager (AK::IAkStreamMgr::CreateStd()), or in the Low-Level I/O module (AK::StreamMgr::IAkLowLevelIOHook::BatchOpen()) if you use the default Stream Manager's implementation. - The cookie (in_pCookie) is passed to the Low-Level I/O module for your convenience, in AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will succeed even if the file is not found. This might be the case when sound banks were not generated, for example. The Capture Log will still report the missing file. This allows working without sound banks, as long as the Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly though.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pszString"> Name/path of the bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function, and also to  AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam)</param> 
  /// <param name="out_bankID"> Returned bank ID</param> 
  /// <param name="in_bankType"> Type of the bank to load</param>
  public static AKRESULT LoadBank(string in_pszString, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, out uint out_bankID, uint in_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_6(in_pszString, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, out out_bankID, in_bankType); }
  }

  ///  Loads a bank asynchronously (by Unicode string).
  ///
  ///  The bank name is passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      AK_Success if the scheduling was successful, AK_Fail otherwise.
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The sound engine internally calls GetIDFromString(in_pszString) to return the correct bank ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. The path should be resolved in your implementation of the Stream Manager (AK::IAkStreamMgr::CreateStd()), or in the Low-Level I/O module (AK::StreamMgr::IAkLowLevelIOHook::BatchOpen()) if you use the default Stream Manager's implementation. - The cookie (in_pCookie) is passed to the Low-Level I/O module for your convenience, in AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will succeed even if the file is not found. This might be the case when sound banks were not generated, for example. The Capture Log will still report the missing file. This allows working without sound banks, as long as the Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly though.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pszString"> Name/path of the bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function, and also to  AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam)</param> 
  /// <param name="out_bankID"> Returned bank ID</param>
  public static AKRESULT LoadBank(string in_pszString, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, out uint out_bankID) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_7(in_pszString, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, out out_bankID); }
  }

  ///  Loads a bank asynchronously (by ID).
  ///
  ///  Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  The bank ID is passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      - ``AK_Success`` if the scheduling was successful,
  ///      - ``AK_InvalidBankType`` if in_bankType was invalid
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with ``UnloadBank()``.</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The file path should be resolved in your implementation of the Stream Manager, or in the Low-Level I/O module if you use the default Stream Manager's implementation. The ID overload of AK::IAkStreamMgr::CreateStd() and AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() are called. - The cookie (in_pCookie) is passed to the Low-Level I/O module for your convenience, in AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will succeed even if the file is not found. This might be the case when sound banks were not generated, for example. The Capture Log will still report the missing file. This allows working without sound banks, as long as Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly though.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_bankID"> Bank ID of the bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function, and also to  AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam)</param> 
  /// <param name="in_bankType"> Type of the bank to load</param>
  public static AKRESULT LoadBank(uint in_bankID, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, uint in_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_10(in_bankID, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_bankType); }
  }

  ///  Loads a bank asynchronously (by ID).
  ///
  ///  Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  The bank ID is passed to the Stream Manager.
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      - ``AK_Success`` if the scheduling was successful,
  ///      - ``AK_InvalidBankType`` if in_bankType was invalid
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with ``UnloadBank()``.</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The file path should be resolved in your implementation of the Stream Manager, or in the Low-Level I/O module if you use the default Stream Manager's implementation. The ID overload of AK::IAkStreamMgr::CreateStd() and AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() are called. - The cookie (in_pCookie) is passed to the Low-Level I/O module for your convenience, in AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam. When Wwise Authoring is connected to the game in "Profile And Edit (Sync All)" mode, LoadBank will succeed even if the file is not found. This might be the case when sound banks were not generated, for example. The Capture Log will still report the missing file. This allows working without sound banks, as long as Wwise Authoring is connected. The Init.bnk is still required to initialize the sound engine properly though.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_bankID"> Bank ID of the bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function, and also to  AK::StreamMgr::IAkLowLevelIOHook::BatchOpen() as AkFileSystemFlags::pCustomParam)</param>
  public static AKRESULT LoadBank(uint in_bankID, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBank__SWIG_11(in_bankID, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Loads a bank asynchronously (from in-memory data, in-place, user bank only).
  ///  IMPORTANT: Banks loaded from memory with in-place data MUST be unloaded using the UnloadBank function
  ///  providing the same memory pointer. Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryView when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine.
  ///  In-memory loading is in-place: *** the memory must be valid until the bank is unloaded. ***
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      - ``AK_Success`` if the scheduling was successful,
  ///      - ``AK_InvalidBankType`` if the bank is not a user-defined bank.
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The memory must be aligned on platform-specific AK_BANK_PLATFORM_DATA_ALIGNMENT bytes (see AkTypes.h). - Avoid using this function for banks containing a lot of events or structure data: this data will be unpacked into the sound engine heap,   making the supplied bank memory redundant. For event/structure-only banks, prefer LoadBankMemoryCopy().</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is stored in sound engine, memory must remain valid)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie</param> 
  /// <param name="out_bankID"> Returned bank ID</param>
  public static AKRESULT LoadBankMemoryView(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, out uint out_bankID) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryView__SWIG_2(in_pInMemoryBankPtr, in_uInMemoryBankSize, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, out out_bankID); }
  }

  ///  Loads a bank asynchronously (from in-memory data, in-place, any bank type).
  ///  IMPORTANT: Banks loaded from memory with in-place data MUST be unloaded using the UnloadBank function
  ///  providing the same memory pointer. Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryView when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine.
  ///  In-memory loading is in-place: *** the memory must be valid until the bank is unloaded. ***
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      - ``AK_Success`` if the scheduling was successful,
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail. - The memory must be aligned on platform-specific AK_BANK_PLATFORM_DATA_ALIGNMENT bytes (see AkTypes.h). - Avoid using this function for banks containing a lot of events or structure data: this data will be unpacked into the sound engine heap,   making the supplied bank memory redundant. For event/structure-only banks, prefer LoadBankMemoryCopy().</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is stored in sound engine, memory must remain valid)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie</param> 
  /// <param name="out_bankID"> Returned bank ID</param> 
  /// <param name="out_bankType"> Returned bank type</param>
  public static AKRESULT LoadBankMemoryView(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, out uint out_bankID, out uint out_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryView__SWIG_3(in_pInMemoryBankPtr, in_uInMemoryBankSize, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, out out_bankID, out out_bankType); }
  }

  ///  Loads a bank asynchronously (from in-memory data, out-of-place, user bank only).
  ///  NOTE: Banks loaded from in-memory with out-of-place data must be unloaded using the standard UnloadBank function
  ///  (with no memory pointer). Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryCopy when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine, the media section of the bank will be copied into newly allocated
  ///  memory.
  ///  In-memory loading is out-of-place: the buffer can be released after the callback function is called. The advantage of using this
  ///  over the in-place version is that there is no duplication of bank structures.
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      - ``AK_Success`` if the scheduling was successful,
  ///      - ``AK_InvalidBankType`` if the bank is not a user-defined bank.
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is not stored in sound engine, memory can be released after callback)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie</param> 
  /// <param name="out_bankID"> Returned bank ID</param>
  public static AKRESULT LoadBankMemoryCopy(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, out uint out_bankID) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryCopy__SWIG_2(in_pInMemoryBankPtr, in_uInMemoryBankSize, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, out out_bankID); }
  }

  ///  Loads a bank asynchronously (from in-memory data, out-of-place, any bank type).
  ///  NOTE: Banks loaded from in-memory with out-of-place data must be unloaded using the standard UnloadBank function
  ///  (with no memory pointer). Make sure you are using the correct UnloadBank(...) overload
  ///  Use LoadBankMemoryCopy when you want to manage I/O on your side. Load the bank file
  ///  in a buffer and pass its address to the sound engine, the media section of the bank will be copied into newly allocated
  ///  memory.
  ///  In-memory loading is out-of-place: the buffer can be released after the callback function is called. The advantage of using this
  ///  over the in-place version is that there is no duplication of bank structures.
  ///  A bank load request will be posted to the Bank Manager consumer thread.
  ///  The function returns immediately.
  /// <returns>
  ///      - ``AK_Success`` if the scheduling was successful,
  ///      - ``AK_InvalidBankType`` if in_bankType was invalid
  ///      - ``AK_DataAlignmentError`` if the data pointer is not aligned properly
  ///      Use a callback to be notified when completed, and get the status of the request.
  ///      The bank ID, which is obtained by hashing the bank name (see GetIDFromString()).
  ///      You may use this ID with UnloadBank().</returns> 
  /// <remarks> - The initialization bank (Init.bnk) must be loaded first. - All SoundBanks subsequently loaded must come from the same Wwise project as the   initialization bank. If you need to load SoundBanks from a different project, you   must first unload ALL banks, including the initialization bank, then load the   initialization bank from the other project, and finally load banks from that project. - Codecs and plug-ins must be registered before loading banks that use them. - Loading a bank referencing an unregistered plug-in or codec will result in a load bank success, but the plug-ins will not be used. More specifically, playing a sound that uses an unregistered effect plug-in will result in audio playback without applying the said effect. If an unregistered source plug-in is used by an event's audio objects, posting the event will fail.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.UnloadBank"/>
  /// <param name="in_pInMemoryBankPtr"> Pointer to the in-memory bank to load (pointer is not stored in sound engine, memory can be released after callback)</param> 
  /// <param name="in_uInMemoryBankSize"> Size of the in-memory bank to load</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie</param> 
  /// <param name="out_bankID"> Returned bank ID</param> 
  /// <param name="out_bankType"> Returned bank type</param>
  public static AKRESULT LoadBankMemoryCopy(global::System.IntPtr in_pInMemoryBankPtr, uint in_uInMemoryBankSize, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, out uint out_bankID, out uint out_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadBankMemoryCopy__SWIG_3(in_pInMemoryBankPtr, in_uInMemoryBankSize, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, out out_bankID, out out_bankType); }
  }

  ///  Unloads a bank synchronously (by Unicode string).
  ///
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  /// <returns>AK_Success if successful, AK_Fail otherwise. AK_Success is returned when the bank was not loaded.</returns> 
  /// <remarks> - The sound engine internally calls GetIDFromString(in_pszString) to retrieve the bank ID, then it calls the synchronous version of UnloadBank() by ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_pszString"> Name of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param> 
  /// <param name="in_bankType"> Type of the bank to unload</param>
  public static AKRESULT UnloadBank(string in_pszString, global::System.IntPtr in_pInMemoryBankPtr, uint in_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_0(in_pszString, in_pInMemoryBankPtr, in_bankType); }

  ///  Unloads a bank synchronously (by Unicode string).
  ///
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  /// <returns>AK_Success if successful, AK_Fail otherwise. AK_Success is returned when the bank was not loaded.</returns> 
  /// <remarks> - The sound engine internally calls GetIDFromString(in_pszString) to retrieve the bank ID, then it calls the synchronous version of UnloadBank() by ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_pszString"> Name of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param>
  public static AKRESULT UnloadBank(string in_pszString, global::System.IntPtr in_pInMemoryBankPtr) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_1(in_pszString, in_pInMemoryBankPtr); }

  ///  Unloads a bank synchronously (by ID and memory pointer).
  /// <returns>AK_Success if successful, AK_Fail otherwise. AK_Success is returned when the bank was not loaded.</returns> 
  /// <remarks> - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_bankID"> ID of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param> 
  /// <param name="in_bankType"> Type of the bank to unload</param>
  public static AKRESULT UnloadBank(uint in_bankID, global::System.IntPtr in_pInMemoryBankPtr, uint in_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_4(in_bankID, in_pInMemoryBankPtr, in_bankType); }

  ///  Unloads a bank synchronously (by ID and memory pointer).
  /// <returns>AK_Success if successful, AK_Fail otherwise. AK_Success is returned when the bank was not loaded.</returns> 
  /// <remarks> - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_bankID"> ID of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param>
  public static AKRESULT UnloadBank(uint in_bankID, global::System.IntPtr in_pInMemoryBankPtr) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_5(in_bankID, in_pInMemoryBankPtr); }

  ///  Unloads a bank asynchronously (by Unicode string).
  ///
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  /// <returns>AK_Success if scheduling successful (use a callback to be notified when completed)</returns> 
  /// <remarks> The sound engine internally calls GetIDFromString(in_pszString) to retrieve the bank ID, then it calls the synchronous version of UnloadBank() by ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_pszString"> Name of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param> 
  /// <param name="in_bankType"> Type of the bank to unload</param>
  public static AKRESULT UnloadBank(string in_pszString, global::System.IntPtr in_pInMemoryBankPtr, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, uint in_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_6(in_pszString, in_pInMemoryBankPtr, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_bankType); }
  }

  ///  Unloads a bank asynchronously (by Unicode string).
  ///
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  /// <returns>AK_Success if scheduling successful (use a callback to be notified when completed)</returns> 
  /// <remarks> The sound engine internally calls GetIDFromString(in_pszString) to retrieve the bank ID, then it calls the synchronous version of UnloadBank() by ID. Therefore, in_pszString should be the real name of the SoundBank (with or without the BNK extension - it is trimmed internally), not the name of the file (if you changed it), nor the full path of the file. - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_pszString"> Name of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT UnloadBank(string in_pszString, global::System.IntPtr in_pInMemoryBankPtr, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_7(in_pszString, in_pInMemoryBankPtr, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Unloads a bank asynchronously (by ID and memory pointer).
  ///
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  /// <returns>AK_Success if scheduling successful (use a callback to be notified when completed)</returns> 
  /// <remarks> - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_bankID"> ID of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param> 
  /// <param name="in_bankType"> Type of the bank to unload</param>
  public static AKRESULT UnloadBank(uint in_bankID, global::System.IntPtr in_pInMemoryBankPtr, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, uint in_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_10(in_bankID, in_pInMemoryBankPtr, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, in_bankType); }
  }

  ///  Unloads a bank asynchronously (by ID and memory pointer).
  ///
  ///  See \ref soundengine_banks_general for a discussion on using strings and IDs.
  /// <returns>AK_Success if scheduling successful (use a callback to be notified when completed)</returns> 
  /// <remarks> - In order to force the memory deallocation of the bank, sounds that use media from this bank will be stopped. This means that streamed sounds or generated sounds will not be stopped.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_bankID"> ID of the bank to unload</param> 
  /// <param name="in_pInMemoryBankPtr"> Memory pointer from where the bank was initially loaded from. (REQUIRED to determine which bank associated to a memory pointer must be unloaded). Pass NULL if NULL was passed when loading the bank or if LoadBankMemoryCopy was used to load the bank.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT UnloadBank(uint in_bankID, global::System.IntPtr in_pInMemoryBankPtr, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadBank__SWIG_11(in_bankID, in_pInMemoryBankPtr, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Cancels all Event callbacks associated with a specific callback cookie specified while loading Banks of preparing Events.
  /// <seealso cref="
  ///  - AK.SoundEngine.LoadBank"/>
  /// <param name="in_pCookie"> Callback cookie to be canceled</param>
  public static void CancelBankCallbackCookie(object in_pCookie) {
		AkCallbackManager.RemoveBankCallback(in_pCookie);
	}

  ///  This function will load the Events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank; but, as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> PrepareBank(), when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;	for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pszString"> Name of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param> 
  /// <param name="in_bankType"> Type of the bank to Prepare/Unprepare.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, string in_pszString, AkBankContent in_uFlags, uint in_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_0((int)in_PreparationType, in_pszString, (int)in_uFlags, in_bankType); }

  ///  This function will load the Events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank; but, as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> PrepareBank(), when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;	for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pszString"> Name of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, string in_pszString, AkBankContent in_uFlags) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_1((int)in_PreparationType, in_pszString, (int)in_uFlags); }

  ///  This function will load the Events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank; but, as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> PrepareBank(), when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;	for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pszString"> Name of the bank to Prepare/Unprepare.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, string in_pszString) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_2((int)in_PreparationType, in_pszString); }

  /// Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  This function will load the events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank, but as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> ``PrepareBank()``, when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_bankID"> ID of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param> 
  /// <param name="in_bankType"> Type of the bank to Prepare/Unprepare.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, uint in_bankID, AkBankContent in_uFlags, uint in_bankType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_6((int)in_PreparationType, in_bankID, (int)in_uFlags, in_bankType); }

  /// Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  This function will load the events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank, but as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> ``PrepareBank()``, when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_bankID"> ID of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, uint in_bankID, AkBankContent in_uFlags) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_7((int)in_PreparationType, in_bankID, (int)in_uFlags); }

  /// Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  This function will load the events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank, but as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> ``PrepareBank()``, when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_bankID"> ID of the bank to Prepare/Unprepare.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, uint in_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_8((int)in_PreparationType, in_bankID); }

  ///  This function will load the Events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank, but as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> PrepareBank(), when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pszString"> Name of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param> 
  /// <param name="in_bankType"> Type of the bank to Prepare/Unprepare.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, string in_pszString, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, AkBankContent in_uFlags, uint in_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_9((int)in_PreparationType, in_pszString, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, (int)in_uFlags, in_bankType); }
  }

  ///  This function will load the Events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank, but as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> PrepareBank(), when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pszString"> Name of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, string in_pszString, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, AkBankContent in_uFlags) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_10((int)in_PreparationType, in_pszString, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, (int)in_uFlags); }
  }

  ///  This function will load the Events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, PrepareBank() will load the media content from
  ///  the bank, but as opposed to LoadBank(), the media will be loaded one media item at a time instead of in one contiguous memory block. Using PrepareBank(), alone or in combination with PrepareEvent(),
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> PrepareBank(), when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. PrepareEvent(), however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses PrepareEvent() to load loose files on-demand and, also, a game mode that uses LoadBank() to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pszString"> Name of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, string in_pszString, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_11((int)in_PreparationType, in_pszString, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  /// Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  This function will load the events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, ``PrepareBank()`` will load the media content from
  ///  the bank, but as opposed to ``LoadBank()``, the media will be loaded one media item at a time instead of in one contiguous memory block. Using ``PrepareBank()``, alone or in combination with ``PrepareEvent()``,
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> ``PrepareBank()``, when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. ``PrepareEvent()``, however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses ``PrepareEvent()`` to load loose files on-demand and, also, a game mode that uses ``LoadBank()`` to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_bankID"> ID of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param> 
  /// <param name="in_bankType"> Type of the bank to Prepare/Unprepare.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, uint in_bankID, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, AkBankContent in_uFlags, uint in_bankType) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_15((int)in_PreparationType, in_bankID, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, (int)in_uFlags, in_bankType); }
  }

  /// Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  This function will load the events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, ``PrepareBank()`` will load the media content from
  ///  the bank, but as opposed to ``LoadBank()``, the media will be loaded one media item at a time instead of in one contiguous memory block. Using ``PrepareBank()``, alone or in combination with ``PrepareEvent()``,
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> ``PrepareBank()``, when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. ``PrepareEvent()``, however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses ``PrepareEvent()`` to load loose files on-demand and, also, a game mode that uses ``LoadBank()`` to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_bankID"> ID of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param> 
  /// <param name="in_uFlags"> Structures only (including events) or all content.</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, uint in_bankID, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie, AkBankContent in_uFlags) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_16((int)in_PreparationType, in_bankID, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero, (int)in_uFlags); }
  }

  /// Requires that the "Use SoundBank names" option be unchecked in the Wwise Project Settings.
  ///  This function will load the events, structural content, and optionally, the media content from the SoundBank. If the flag AkBankContent_All is specified, ``PrepareBank()`` will load the media content from
  ///  the bank, but as opposed to ``LoadBank()``, the media will be loaded one media item at a time instead of in one contiguous memory block. Using ``PrepareBank()``, alone or in combination with ``PrepareEvent()``,
  ///  will prevent in-memory duplication of media at the cost of some memory fragmentation.
  ///  Calling this function specifying the flag AkBankContent_StructureOnly will load only the structural part (including events) of this bank,
  ///  allowing using PrepareEvent() to load media on demand.
  /// <seealso cref="
  ///  - \ref soundengine_banks_preparingbanks
  ///  - AK.SoundEngine.LoadBank"/>
  /// <remarks> ``PrepareBank()``, when called with the flag AkBankContent_StructureOnly, requires additional calls to PrepareEvent() to load the media for each event. ``PrepareEvent()``, however, is unable to		access media content contained within SoundBanks and requires that the media be available as loose files in the file system. This flag may be useful to implement multiple loading configurations;		for example, a game may have a tool mode that uses ``PrepareEvent()`` to load loose files on-demand and, also, a game mode that uses ``LoadBank()`` to load the bank in entirety.</remarks>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_bankID"> ID of the bank to Prepare/Unprepare.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareBank(AkPreparationType in_PreparationType, uint in_bankID, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBank__SWIG_17((int)in_PreparationType, in_bankID, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Clear all previously prepared events.
  /// <returns>
  ///      - ``AK_Success`` if successful.
  ///      - ``AK_Fail`` if the sound engine was not correctly initialized or if there is not enough memory to handle the command.</returns> 
  /// <remarks> The function ``ClearBanks()`` also clears all prepared events.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareEvent"/>
  public static AKRESULT ClearPreparedEvents() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ClearPreparedEvents(); }

  ///  Prepares or unprepares Events synchronously (by Unicode string).
  ///
  ///  The Events are identified by strings, and converted to IDs internally
  ///  (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking ``PrepareEvent()``, use ``LoadBank()`` to explicitly load the SoundBank(s)
  ///  that contain the Events and structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will resolve all dependencies needed to
  ///  successfully post the specified Events and load the required loose media files.
  ///  Before version 2015.1, the required media files could be included
  ///  in a separate media SoundBank. As described in \ref whatsnew_2015_1_migration,
  ///  however,``PrepareEvent()`` now only looks for loose media files.
  ///
  ///  The function returns when the request is completely processed.
  /// <returns>
  ///      - ``AK_Success``: Prepare/un-prepare successful.
  ///      - ``AK_IDNotFound``: At least one of the event/game sync identifiers passed to PrepareEvent() does not exist.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> Whenever at least one event fails to be resolved, the actions performed for all other events are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareEvent"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_ppszString"> Array of event names</param> 
  /// <param name="in_uNumEvent"> Number of events in the array</param>
  public static AKRESULT PrepareEvent(AkPreparationType in_PreparationType, string [] in_ppszString, uint in_uNumEvent) {
			
		//Find the required size
		int size = 0;
		foreach(string s in in_ppszString)
			size += s.Length + 1;
				
		int sizeofChar = 2;	//Unicode
		global::System.IntPtr pMem = global::System.Runtime.InteropServices.Marshal.AllocHGlobal(size * sizeofChar + 2);
		
		//Write the length of array
		global::System.Runtime.InteropServices.Marshal.WriteInt16(pMem, (short)in_ppszString.Length);
		global::System.IntPtr pCurrent = (global::System.IntPtr)(pMem.ToInt64() + sizeofChar);
		
		//Copy the strings one after the other.
		foreach(string s in in_ppszString)
		{
			global::System.Runtime.InteropServices.Marshal.Copy(s.ToCharArray(), 0, pCurrent, s.Length);
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar * s.Length);
			global::System.Runtime.InteropServices.Marshal.WriteInt16(pCurrent, 0);	//Null-terminated string
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar);
		}		
		
    try { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareEvent__SWIG_0((int)in_PreparationType, pMem, in_uNumEvent); } finally {
	global::System.Runtime.InteropServices.Marshal.FreeHGlobal(pMem);
    }
  }

  ///  Prepares or unprepares events synchronously (by ID).
  ///  The Events are identified by their ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareEvent(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Events and structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will resolve all dependencies needed to
  ///  successfully post the specified Events and load the required loose media files.
  ///  Before version 2015.1, the required media files could be included
  ///  in a separate media SoundBank. As described in \ref whatsnew_2015_1_migration,
  ///  however, PrepareEvent() now only looks for loose media files.
  ///
  ///  The function returns when the request is completely processed.
  /// <returns>
  ///      - ``AK_Success``: Prepare/un-prepare successful.
  ///      - ``AK_IDNotFound``: At least one of the event/game sync identifiers passed to PrepareEvent() does not exist.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> Whenever at least one event fails to be resolved, the actions performed for all other events are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareEvent"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pEventID"> Array of event IDs</param> 
  /// <param name="in_uNumEvent"> Number of event IDs in the array</param>
  public static AKRESULT PrepareEvent(AkPreparationType in_PreparationType, uint[] in_pEventID, uint in_uNumEvent) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareEvent__SWIG_1((int)in_PreparationType, in_pEventID, in_uNumEvent); }

  ///  Prepares or unprepares an event asynchronously (by Unicode string).
  ///  The Events are identified by string (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareEvent(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Events and structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will resolve all dependencies needed to
  ///  successfully post the specified Events and load the required loose media files.
  ///  Before version 2015.1, the required media files could be included
  ///  in a separate media SoundBank. As described in \ref whatsnew_2015_1_migration,
  ///  however, ``PrepareEvent()`` now only looks for loose media files.
  ///
  ///  The function returns immediately. Use a callback to be notified when the request has finished being processed.
  /// <returns>AK_Success if scheduling is was successful, AK_Fail otherwise.</returns> 
  /// <remarks> Whenever at least one Event fails to be resolved, the actions performed for all other Events are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareEvent"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_ppszString"> Array of event names</param> 
  /// <param name="in_uNumEvent"> Number of events in the array</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareEvent(AkPreparationType in_PreparationType, string [] in_ppszString, uint in_uNumEvent, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
			
		//Find the required size
		int size = 0;
		foreach(string s in in_ppszString)
			size += s.Length + 1;
				
		int sizeofChar = 2;	//Unicode
		global::System.IntPtr pMem = global::System.Runtime.InteropServices.Marshal.AllocHGlobal(size * sizeofChar + 2);
		
		//Write the length of array
		global::System.Runtime.InteropServices.Marshal.WriteInt16(pMem, (short)in_ppszString.Length);
		global::System.IntPtr pCurrent = (global::System.IntPtr)(pMem.ToInt64() + sizeofChar);
		
		//Copy the strings one after the other.
		foreach(string s in in_ppszString)
		{
			global::System.Runtime.InteropServices.Marshal.Copy(s.ToCharArray(), 0, pCurrent, s.Length);
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar * s.Length);
			global::System.Runtime.InteropServices.Marshal.WriteInt16(pCurrent, 0);	//Null-terminated string
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar);
		}		
		
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    try { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareEvent__SWIG_2((int)in_PreparationType, pMem, in_uNumEvent, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); } finally {
	global::System.Runtime.InteropServices.Marshal.FreeHGlobal(pMem);
    }
  }

  ///  Prepares or unprepares events asynchronously (by ID).
  ///
  ///  The Events are identified by their ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareEvent(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Events and structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will resolve all dependencies needed to
  ///  successfully post the specified Events and load the required loose media files.
  ///  Before version 2015.1, the required media files could be included
  ///  in a separate media SoundBank. As described in \ref whatsnew_2015_1_migration,
  ///  however, PrepareEvent() now only looks for loose media files.
  ///
  ///  The function returns immediately. Use a callback to be notified when the request has finished being processed.
  /// <returns>AK_Success if scheduling is was successful, AK_Fail otherwise.</returns> 
  /// <remarks> Whenever at least one event fails to be resolved, the actions performed for all other events are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareEvent"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pEventID"> Array of event IDs</param> 
  /// <param name="in_uNumEvent"> Number of event IDs in the array</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareEvent(AkPreparationType in_PreparationType, uint[] in_pEventID, uint in_uNumEvent, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareEvent__SWIG_3((int)in_PreparationType, in_pEventID, in_uNumEvent, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Prepares or unprepares busses synchronously (by Unicode string).
  ///
  ///  The Busses are identified by strings and converted to IDs internally
  ///  (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareBus(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Bus structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will load the required loose media files for effects
  ///  placed on the specified busses.
  ///  The function returns when the request is completely processed.
  /// <returns>
  ///      - ``AK_Success``: Prepare/un-prepare successful.
  ///      - ``AK_IDNotFound``: At least one of the bus IDs does not exist.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_Fail``: Load or unload failed for any other reason.</returns> 
  /// <remarks> Whenever at least one bus fails to be resolved, the actions performed for all other busses are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareBus"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_ppszString"> Array of bus names</param> 
  /// <param name="in_uBusses"> Number of bus names in the array</param>
  public static AKRESULT PrepareBus(AkPreparationType in_PreparationType, string [] in_ppszString, uint in_uBusses) {
			
		//Find the required size
		int size = 0;
		foreach(string s in in_ppszString)
			size += s.Length + 1;
				
		int sizeofChar = 2;	//Unicode
		global::System.IntPtr pMem = global::System.Runtime.InteropServices.Marshal.AllocHGlobal(size * sizeofChar + 2);
		
		//Write the length of array
		global::System.Runtime.InteropServices.Marshal.WriteInt16(pMem, (short)in_ppszString.Length);
		global::System.IntPtr pCurrent = (global::System.IntPtr)(pMem.ToInt64() + sizeofChar);
		
		//Copy the strings one after the other.
		foreach(string s in in_ppszString)
		{
			global::System.Runtime.InteropServices.Marshal.Copy(s.ToCharArray(), 0, pCurrent, s.Length);
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar * s.Length);
			global::System.Runtime.InteropServices.Marshal.WriteInt16(pCurrent, 0);	//Null-terminated string
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar);
		}		
		
    try { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBus__SWIG_0((int)in_PreparationType, pMem, in_uBusses); } finally {
	global::System.Runtime.InteropServices.Marshal.FreeHGlobal(pMem);
    }
  }

  ///  Prepares or unprepares busses synchronously (by ID).
  ///
  ///  The Busses are identified by their ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareBus(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Bus structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will load the required loose media files for effects
  ///  placed on the specified busses.
  ///  The function returns when the request is completely processed.
  /// <returns>
  ///      - ``AK_Success``: Prepare/un-prepare successful.
  ///      - ``AK_IDNotFound``: At least one of the bus IDs does not exist.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_Fail``: Load or unload failed for any other reason.</returns> 
  /// <remarks> Whenever at least one bus fails to be resolved, the actions performed for all other busses are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareBus"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pBusID"> Array of bus IDs</param> 
  /// <param name="in_uBusses"> Number of bus IDs in the array</param>
  public static AKRESULT PrepareBus(AkPreparationType in_PreparationType, uint[] in_pBusID, uint in_uBusses) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBus__SWIG_1((int)in_PreparationType, in_pBusID, in_uBusses); }

  ///  Prepares or unprepares busses asynchronously (by Unicode string).
  ///
  ///  The Busses are identified by string (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareBus(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Bus structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will load the required loose media files for effects
  ///  placed on the specified busses.
  ///  The function returns immediately. Use a callback to be notified when the request has finished being processed.
  /// <returns>AK_Success if scheduling is was successful, AK_Fail otherwise.</returns> 
  /// <remarks> Whenever at least one bus fails to be resolved, the actions performed for all other busses are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareBus"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_ppszString"> Array of bus names</param> 
  /// <param name="in_uBusses"> Number of bus names in the array</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareBus(AkPreparationType in_PreparationType, string [] in_ppszString, uint in_uBusses, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
			
		//Find the required size
		int size = 0;
		foreach(string s in in_ppszString)
			size += s.Length + 1;
				
		int sizeofChar = 2;	//Unicode
		global::System.IntPtr pMem = global::System.Runtime.InteropServices.Marshal.AllocHGlobal(size * sizeofChar + 2);
		
		//Write the length of array
		global::System.Runtime.InteropServices.Marshal.WriteInt16(pMem, (short)in_ppszString.Length);
		global::System.IntPtr pCurrent = (global::System.IntPtr)(pMem.ToInt64() + sizeofChar);
		
		//Copy the strings one after the other.
		foreach(string s in in_ppszString)
		{
			global::System.Runtime.InteropServices.Marshal.Copy(s.ToCharArray(), 0, pCurrent, s.Length);
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar * s.Length);
			global::System.Runtime.InteropServices.Marshal.WriteInt16(pCurrent, 0);	//Null-terminated string
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar);
		}		
		
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    try { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBus__SWIG_2((int)in_PreparationType, pMem, in_uBusses, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); } finally {
	global::System.Runtime.InteropServices.Marshal.FreeHGlobal(pMem);
    }
  }

  ///  Prepares or unprepares busses asynchronously (by ID).
  ///
  ///  The Busses are identified by their ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  Before invoking PrepareBus(), use LoadBank() to explicitly load the SoundBank(s)
  ///  that contain the Bus structures. When a request is posted to the
  ///  Bank Manager consumer thread, it will load the required loose media files for effects
  ///  placed on the specified busses.
  ///  The function returns immediately. Use a callback to be notified when the request has finished being processed.
  /// <returns>AK_Success if scheduling is was successful, AK_Fail otherwise.</returns> 
  /// <remarks> Whenever at least one bus fails to be resolved, the actions performed for all other busses are cancelled.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.PrepareBus"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_pBusID"> Array of bus IDs</param> 
  /// <param name="in_uBusses"> Number of bus IDs in the array</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareBus(AkPreparationType in_PreparationType, uint[] in_pBusID, uint in_uBusses, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareBus__SWIG_3((int)in_PreparationType, in_pBusID, in_uBusses, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Indicates the location of a specific Media ID in memory
  ///  The sources are identified by their ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  /// <returns>AK_Success if operation was successful, AK_InvalidParameter if in_pSourceSettings is invalid or media sizes are 0.</returns> 
  /// <param name="in_pSourceSettings"> Array of Source Settings</param> 
  /// <param name="in_uNumSourceSettings"> Number of Source Settings in the array</param>
  public static AKRESULT SetMedia(AkSourceSettingsArray in_pSourceSettings, uint in_uNumSourceSettings) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMedia(in_pSourceSettings.GetBuffer(), in_uNumSourceSettings); }

  ///  Prepares or unprepares game syncs synchronously (by Unicode string).
  ///
  ///  The group and game syncs are specified by string (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  The game syncs definitions must already exist in the sound engine by having
  ///  explicitly loaded the bank(s) that contain them (with LoadBank()).
  ///  A request is posted to the Bank Manager consumer thread. It will resolve all
  ///  dependencies needed to successfully set this game sync group to one of the
  ///  game sync values specified, and load the required banks, if applicable.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      - ``AK_Success``: Prepare/un-prepare successful.
  ///      - ``AK_IDNotFound``: At least one of the event/game sync identifiers passed to PrepareGameSyncs() does not exist.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> You need to call PrepareGameSyncs() if the sound engine was initialized with AkInitSettings::bEnableGameSyncPreparation set to true. When set to false, the sound engine automatically prepares all game syncs when preparing events, so you never need to call this function.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_eGameSyncType"> The type of game sync.</param> 
  /// <param name="in_pszGroupName"> The State Group Name or the Switch Group Name.</param> 
  /// <param name="in_ppszGameSyncName"> The specific ID of the state to either support or not support.</param> 
  /// <param name="in_uNumGameSyncs"> The number of game sync in the string array.</param>
  public static AKRESULT PrepareGameSyncs(AkPreparationType in_PreparationType, AkGroupType in_eGameSyncType, string in_pszGroupName, string [] in_ppszGameSyncName, uint in_uNumGameSyncs) {
			
		//Find the required size
		int size = 0;
		foreach(string s in in_ppszGameSyncName)
			size += s.Length + 1;
				
		int sizeofChar = 2;	//Unicode
		global::System.IntPtr pMem = global::System.Runtime.InteropServices.Marshal.AllocHGlobal(size * sizeofChar + 2);
		
		//Write the length of array
		global::System.Runtime.InteropServices.Marshal.WriteInt16(pMem, (short)in_ppszGameSyncName.Length);
		global::System.IntPtr pCurrent = (global::System.IntPtr)(pMem.ToInt64() + sizeofChar);
		
		//Copy the strings one after the other.
		foreach(string s in in_ppszGameSyncName)
		{
			global::System.Runtime.InteropServices.Marshal.Copy(s.ToCharArray(), 0, pCurrent, s.Length);
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar * s.Length);
			global::System.Runtime.InteropServices.Marshal.WriteInt16(pCurrent, 0);	//Null-terminated string
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar);
		}		
		
    try { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareGameSyncs__SWIG_0((int)in_PreparationType, (int)in_eGameSyncType, in_pszGroupName, pMem, in_uNumGameSyncs); } finally {
	global::System.Runtime.InteropServices.Marshal.FreeHGlobal(pMem);
    }
  }

  ///  Prepares or unprepares game syncs synchronously (by ID).
  ///
  ///  The group and game syncs are specified by ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  The game syncs definitions must already exist in the sound engine by having
  ///  explicitly loaded the bank(s) that contain them (with LoadBank()).
  ///  A request is posted to the Bank Manager consumer thread. It will resolve all
  ///  dependencies needed to successfully set this game sync group to one of the
  ///  game sync values specified, and load the required banks, if applicable.
  ///  The function returns when the request has been completely processed.
  /// <returns>
  ///      - ``AK_Success``: Prepare/un-prepare successful.
  ///      - ``AK_IDNotFound``: At least one of the event/game sync identifiers passed to PrepareGameSyncs() does not exist.
  ///      - ``AK_InsufficientMemory``: Insufficient memory to store bank data.
  ///      - ``AK_BankReadError``: I/O error.
  ///      - ``AK_WrongBankVersion``: Invalid bank version: make sure the version of Wwise that
  ///      you used to generate the SoundBanks matches that of the SDK you are currently using.
  ///      - ``AK_InvalidFile``: File specified could not be opened.
  ///      - ``AK_InvalidParameter``: Invalid parameter, invalid memory alignment.		
  ///      - ``AK_Fail``: Load or unload failed for any other reason. (Most likely small allocation failure)</returns> 
  /// <remarks> You need to call ``PrepareGameSyncs()`` if the sound engine was initialized with ``AkInitSettings::bEnableGameSyncPreparation`` set to ``true``. When set to ``false``, the sound engine automatically prepares all game syncs when preparing Events, so you never need to call this function.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_eGameSyncType"> The type of game sync.</param> 
  /// <param name="in_GroupID"> The State Group ID or the Switch Group ID.</param> 
  /// <param name="in_paGameSyncID"> Array of ID of the game syncs to either support or not support.</param> 
  /// <param name="in_uNumGameSyncs"> The number of game sync ID in the array.</param>
  public static AKRESULT PrepareGameSyncs(AkPreparationType in_PreparationType, AkGroupType in_eGameSyncType, uint in_GroupID, uint[] in_paGameSyncID, uint in_uNumGameSyncs) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareGameSyncs__SWIG_1((int)in_PreparationType, (int)in_eGameSyncType, in_GroupID, in_paGameSyncID, in_uNumGameSyncs); }

  ///  Prepares or unprepares game syncs asynchronously (by Unicode string).
  ///
  ///  The group and game syncs are specified by string (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  The game syncs definitions must already exist in the sound engine by having
  ///  explicitly loaded the bank(s) that contain them (with LoadBank()).
  ///  A request is posted to the Bank Manager consumer thread. It will resolve all
  ///  dependencies needed to successfully set this game sync group to one of the
  ///  game sync values specified, and load the required banks, if applicable.
  ///  The function returns immediately. Use a callback to be notified when the request has finished being processed.
  /// <returns>AK_Success if scheduling is was successful, AK_Fail otherwise.</returns> 
  /// <remarks> You need to call ``PrepareGameSyncs()`` if the sound engine was initialized with ``AkInitSettings::bEnableGameSyncPreparation`` set to ``true``. When set to ``false``, the sound engine automatically prepares all game syncs when preparing Events, so you never need to call this function.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_eGameSyncType"> The type of game sync.</param> 
  /// <param name="in_pszGroupName"> The State Group Name or the Switch Group Name.</param> 
  /// <param name="in_ppszGameSyncName"> The specific ID of the state to either support or not support.</param> 
  /// <param name="in_uNumGameSyncs"> The number of game sync in the string array.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareGameSyncs(AkPreparationType in_PreparationType, AkGroupType in_eGameSyncType, string in_pszGroupName, string [] in_ppszGameSyncName, uint in_uNumGameSyncs, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
			
		//Find the required size
		int size = 0;
		foreach(string s in in_ppszGameSyncName)
			size += s.Length + 1;
				
		int sizeofChar = 2;	//Unicode
		global::System.IntPtr pMem = global::System.Runtime.InteropServices.Marshal.AllocHGlobal(size * sizeofChar + 2);
		
		//Write the length of array
		global::System.Runtime.InteropServices.Marshal.WriteInt16(pMem, (short)in_ppszGameSyncName.Length);
		global::System.IntPtr pCurrent = (global::System.IntPtr)(pMem.ToInt64() + sizeofChar);
		
		//Copy the strings one after the other.
		foreach(string s in in_ppszGameSyncName)
		{
			global::System.Runtime.InteropServices.Marshal.Copy(s.ToCharArray(), 0, pCurrent, s.Length);
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar * s.Length);
			global::System.Runtime.InteropServices.Marshal.WriteInt16(pCurrent, 0);	//Null-terminated string
			pCurrent = (global::System.IntPtr)(pCurrent.ToInt64() + sizeofChar);
		}		
		
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    try { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareGameSyncs__SWIG_2((int)in_PreparationType, (int)in_eGameSyncType, in_pszGroupName, pMem, in_uNumGameSyncs, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); } finally {
	global::System.Runtime.InteropServices.Marshal.FreeHGlobal(pMem);
    }
  }

  ///  Prepares or un-prepare game syncs asynchronously (by ID).
  ///
  ///  The group and game syncs are specified by ID (see \ref soundengine_banks_general for a discussion on using strings and IDs).
  ///  The game syncs definitions must already exist in the sound engine by having
  ///  explicitly loaded the bank(s) that contain them (with LoadBank()).
  ///  A request is posted to the Bank Manager consumer thread. It will resolve all
  ///  dependencies needed to successfully set this game sync group to one of the
  ///  game sync values specified, and load the required banks, if applicable.
  ///  The function returns immediately. Use a callback to be notified when the request has finished being processed.
  /// <returns>AK_Success if scheduling is was successful, AK_Fail otherwise.</returns> 
  /// <remarks> You need to call PrepareGameSyncs() if the sound engine was initialized with AkInitSettings::bEnableGameSyncPreparation set to true. When set to false, the sound engine automatically prepares all Game Syncs when preparing Events, so you never need to call this function.</remarks>
  /// <seealso cref="
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_PreparationType"> Preparation type ( Preparation_Load or Preparation_Unload )</param> 
  /// <param name="in_eGameSyncType"> The type of game sync.</param> 
  /// <param name="in_GroupID"> The State Group ID or the Switch Group ID.</param> 
  /// <param name="in_paGameSyncID"> Array of ID of the Game Syncs to either support or not support.</param> 
  /// <param name="in_uNumGameSyncs"> The number of game sync ID in the array.</param> 
  /// <param name="in_pfnBankCallback"> Callback function</param> 
  /// <param name="in_pCookie"> Callback cookie (reserved to user, passed to the callback function)</param>
  public static AKRESULT PrepareGameSyncs(AkPreparationType in_PreparationType, AkGroupType in_eGameSyncType, uint in_GroupID, uint[] in_paGameSyncID, uint in_uNumGameSyncs, AkCallbackManager.BankCallback in_pfnBankCallback, object in_pCookie) {
		in_pCookie = new AkCallbackManager.BankCallbackPackage(in_pfnBankCallback, in_pCookie);
    { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PrepareGameSyncs__SWIG_3((int)in_PreparationType, (int)in_eGameSyncType, in_GroupID, in_paGameSyncID, in_uNumGameSyncs, global::System.IntPtr.Zero, in_pCookie != null ? (global::System.IntPtr)in_pCookie.GetHashCode() : global::System.IntPtr.Zero); }
  }

  ///  Add a single listener to a game object's set of associated listeners.
  ///  Any listeners that have previously been added or set via AddListener or SetListeners will remain as listeners and in_listenerGameObj will be added as an additional listener.
  ///  Calling this function will override the default set of listeners and in_emitterGameObj will now reference its own, unique set of listeners.
  /// <seealso cref="
  ///  - AK.SoundEngine.SetListeners
  ///  - AK.SoundEngine.RemoveListener
  ///  - AK.SoundEngine.SetDefaultListeners
  ///  - \ref soundengine_listeners"/>
  /// <param name="in_emitterGameObj"> Emitter game object.  Must have been previously registered via RegisterGameObj.</param> 
  /// <param name="in_listenerGameObj"> Listener game object IDs that will be activated for in_emitterGameObj.</param>
  public static AKRESULT AddListener(ulong in_emitterGameObj, ulong in_listenerGameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddListener(in_emitterGameObj, in_listenerGameObj); }

  ///  Remove a single listener from a game object's set of active listeners.
  ///  Calling this function will override the default set of listeners and in_emitterGameObj will now reference its own, unique set of listeners.
  /// <seealso cref="
  ///  - AK.SoundEngine.SetListeners
  ///  - AK.SoundEngine.AddListener
  ///  - AK.SoundEngine.SetDefaultListeners
  ///  - \ref soundengine_listeners"/>
  /// <param name="in_emitterGameObj"> Emitter game object.</param> 
  /// <param name="in_listenerGameObj"> Listener game object IDs that will be deactivated for in_emitterGameObj. Game objects must have been previously registered.</param>
  public static AKRESULT RemoveListener(ulong in_emitterGameObj, ulong in_listenerGameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveListener(in_emitterGameObj, in_listenerGameObj); }

  ///  Add a single listener to the default set of listeners.  Upon registration, all game objects reference the default listener set, until
  ///  a call to AddListener, RemoveListener, SetListeners or SetGameObjectOutputBusVolume is made on that game object.
  /// <seealso cref="
  ///  - AK.SoundEngine.SetDefaultListeners
  ///  - AK.SoundEngine.RemoveDefaultListener
  ///  - \ref soundengine_listeners"/>
  /// <param name="in_listenerGameObj"> Listener game object IDs that will be added to the default set of listeners.</param>
  public static AKRESULT AddDefaultListener(ulong in_listenerGameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddDefaultListener(in_listenerGameObj); }

  ///  Remove a single listener from the default set of listeners.  Upon registration, all game objects reference the default listener set, until
  ///  a call to AddListener, RemoveListener, SetListeners or SetGameObjectOutputBusVolume is made on that game object.
  /// <seealso cref="
  ///  - AK.SoundEngine.SetDefaultListeners
  ///  - AK.SoundEngine.AddDefaultListener
  ///  - \ref soundengine_listeners"/>
  /// <param name="in_listenerGameObj"> Listener game object IDs that will be removed from the default set of listeners.</param>
  public static AKRESULT RemoveDefaultListener(ulong in_listenerGameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveDefaultListener(in_listenerGameObj); }

  ///  Resets the listener associations to the default listener(s), as set by SetDefaultListeners. This will also reset per-listener gains that have been set using SetGameObjectOutputBusVolume.
  /// <returns>Always returns AK_Success</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.SetListeners
  ///  - AK.SoundEngine.SetDefaultListeners
  ///  - AK.SoundEngine.SetGameObjectOutputBusVolume
  ///  - \ref soundengine_listeners"/>
  /// <param name="in_emitterGameObj"> Emitter game object.</param>
  public static AKRESULT ResetListenersToDefault(ulong in_emitterGameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetListenersToDefault(in_emitterGameObj); }

  ///  Sets a listener's spatialization parameters. This lets you define listener-specific
  ///  volume offsets for each audio channel.
  ///  If ``in_bSpatialized`` is false, only ``in_pVolumeOffsets`` is used for this listener (3D positions
  ///  have no effect on the speaker distribution). Otherwise, ``in_pVolumeOffsets`` is added to the speaker
  ///  distribution computed for this listener.
  ///  Use helper functions of ``AK::SpeakerVolumes`` to manipulate the vector of volume offsets in_pVolumeOffsets.
  ///
  /// <remarks> - If a sound is mixed into a bus that has a different speaker configuration than in_channelConfig, standard up/downmix rules apply. - Sounds with 3D Spatialization set to None will not be affected by these parameters.</remarks>
  /// <returns>
  ///      - ``AK_Success`` if message was successfully posted to sound engine queue
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf
  ///      - ``AK_InsufficientMemory`` if there wasn't enough memory in the message queue		</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_listeners_spatial"/>
  /// <param name="in_uListenerID"> Listener game object ID</param> 
  /// <param name="in_bSpatialized"> Spatialization toggle (True : enable spatialization, False : disable spatialization)</param> 
  /// <param name="in_channelConfig"> Channel configuration associated with volumes in_pVolumeOffsets. Ignored if in_pVolumeOffsets is NULL.</param> 
  /// <param name="in_pVolumeOffsets"> Per-speaker volume offset, in dB. See AkSpeakerVolumes.h for how to manipulate this vector.</param>
  public static AKRESULT SetListenerSpatialization(ulong in_uListenerID, bool in_bSpatialized, AkChannelConfig in_channelConfig, float[] in_pVolumeOffsets) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetListenerSpatialization__SWIG_0(in_uListenerID, in_bSpatialized, AkChannelConfig.getCPtr(in_channelConfig), in_pVolumeOffsets); }

  ///  Sets a listener's spatialization parameters. This lets you define listener-specific
  ///  volume offsets for each audio channel.
  ///  If ``in_bSpatialized`` is false, only ``in_pVolumeOffsets`` is used for this listener (3D positions
  ///  have no effect on the speaker distribution). Otherwise, ``in_pVolumeOffsets`` is added to the speaker
  ///  distribution computed for this listener.
  ///  Use helper functions of ``AK::SpeakerVolumes`` to manipulate the vector of volume offsets in_pVolumeOffsets.
  ///
  /// <remarks> - If a sound is mixed into a bus that has a different speaker configuration than in_channelConfig, standard up/downmix rules apply. - Sounds with 3D Spatialization set to None will not be affected by these parameters.</remarks>
  /// <returns>
  ///      - ``AK_Success`` if message was successfully posted to sound engine queue
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf
  ///      - ``AK_InsufficientMemory`` if there wasn't enough memory in the message queue		</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_listeners_spatial"/>
  /// <param name="in_uListenerID"> Listener game object ID</param> 
  /// <param name="in_bSpatialized"> Spatialization toggle (True : enable spatialization, False : disable spatialization)</param> 
  /// <param name="in_channelConfig"> Channel configuration associated with volumes in_pVolumeOffsets. Ignored if in_pVolumeOffsets is NULL.</param>
  public static AKRESULT SetListenerSpatialization(ulong in_uListenerID, bool in_bSpatialized, AkChannelConfig in_channelConfig) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetListenerSpatialization__SWIG_1(in_uListenerID, in_bSpatialized, AkChannelConfig.getCPtr(in_channelConfig)); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with a global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass ``AK_INVALID_GAME_OBJECT`` as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for ``in_uValueChangeDuration``. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use ``in_uValueChangeDuration``, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when for example loading a level and you dont want the values to interpolate.</param>
  public static AKRESULT SetRTPCValue(uint in_rtpcID, float in_value, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_0(in_rtpcID, in_value, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with a global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass ``AK_INVALID_GAME_OBJECT`` as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for ``in_uValueChangeDuration``. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use ``in_uValueChangeDuration``, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT SetRTPCValue(uint in_rtpcID, float in_value, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_1(in_rtpcID, in_value, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with a global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass ``AK_INVALID_GAME_OBJECT`` as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for ``in_uValueChangeDuration``. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use ``in_uValueChangeDuration``, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param>
  public static AKRESULT SetRTPCValue(uint in_rtpcID, float in_value, ulong in_gameObjectID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_2(in_rtpcID, in_value, in_gameObjectID, in_uValueChangeDuration); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with a global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass ``AK_INVALID_GAME_OBJECT`` as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for ``in_uValueChangeDuration``. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use ``in_uValueChangeDuration``, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT SetRTPCValue(uint in_rtpcID, float in_value, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_3(in_rtpcID, in_value, in_gameObjectID); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with a global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass ``AK_INVALID_GAME_OBJECT`` as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for ``in_uValueChangeDuration``. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use ``in_uValueChangeDuration``, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param>
  public static AKRESULT SetRTPCValue(uint in_rtpcID, float in_value) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_4(in_rtpcID, in_value); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value to global scope or to game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)		
  ///      - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when for example loading a level and you dont want the values to interpolate.</param>
  public static AKRESULT SetRTPCValue(string in_pszRtpcName, float in_value, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_5(in_pszRtpcName, in_value, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value to global scope or to game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)		
  ///      - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT SetRTPCValue(string in_pszRtpcName, float in_value, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_6(in_pszRtpcName, in_value, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value to global scope or to game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)		
  ///      - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param>
  public static AKRESULT SetRTPCValue(string in_pszRtpcName, float in_value, ulong in_gameObjectID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_7(in_pszRtpcName, in_value, in_gameObjectID, in_uValueChangeDuration); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value to global scope or to game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)		
  ///      - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT SetRTPCValue(string in_pszRtpcName, float in_value, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_8(in_pszRtpcName, in_value, in_gameObjectID); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value to global scope or to game object scope.
  ///  Game object scope supersedes global scope. (Once a value is set for the game object scope, it will not be affected by changes to the global scope value.) Game parameter values set with global scope are applied to all
  ///  game objects that not yet registered, or already registered but not overridden with a value with game object scope.
  ///  To set a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if the value was successfully set
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)		
  ///      - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param>
  public static AKRESULT SetRTPCValue(string in_pszRtpcName, float in_value) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValue__SWIG_9(in_pszRtpcName, in_value); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when, for example, loading a level and you don't want the values to interpolate.</param>
  public static AKRESULT SetRTPCValueByPlayingID(uint in_rtpcID, float in_value, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_0(in_rtpcID, in_value, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT SetRTPCValueByPlayingID(uint in_rtpcID, float in_value, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_1(in_rtpcID, in_value, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param>
  public static AKRESULT SetRTPCValueByPlayingID(uint in_rtpcID, float in_value, uint in_playingID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_2(in_rtpcID, in_value, in_playingID, in_uValueChangeDuration); }

  ///  Sets the value of a real-time parameter control (by ID).
  ///  With this function, you may set a game parameter value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param>
  public static AKRESULT SetRTPCValueByPlayingID(uint in_rtpcID, float in_value, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_3(in_rtpcID, in_value, in_playingID); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value on playing ID scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when, for example, loading a level and you don't want the values to interpolate.</param>
  public static AKRESULT SetRTPCValueByPlayingID(string in_pszRtpcName, float in_value, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_4(in_pszRtpcName, in_value, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value on playing ID scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT SetRTPCValueByPlayingID(string in_pszRtpcName, float in_value, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_5(in_pszRtpcName, in_value, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value on playing ID scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param>
  public static AKRESULT SetRTPCValueByPlayingID(string in_pszRtpcName, float in_value, uint in_playingID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_6(in_pszRtpcName, in_value, in_playingID, in_uValueChangeDuration); }

  ///  Sets the value of a real-time parameter control (by Unicode string name).
  ///  With this function, you may set a game parameter value on playing ID scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also change the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly. Thus, if you call this
  ///  function at every game frame, you should not use in_uValueChangeDuration, as it would have no effect and it is less efficient.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  ///  - ``AK_Success`` if successful
  ///  - ``AK_PlayingIDNotFound`` if in_playingID is not found.
  ///  - ``AK_InvalidID`` if in_pszRtpcName is NULL.
  ///  - ``AK_InvalidFloatValue`` if the value specified was NaN, Inf or FLT_MAX (3.402823e+38)
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_value"> Value to set</param> 
  /// <param name="in_playingID"> Associated playing ID</param>
  public static AKRESULT SetRTPCValueByPlayingID(string in_pszRtpcName, float in_value, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRTPCValueByPlayingID__SWIG_7(in_pszRtpcName, in_value, in_playingID); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when for example loading a level and you dont want the values to interpolate.</param>
  public static AKRESULT ResetRTPCValue(uint in_rtpcID, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_0(in_rtpcID, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT ResetRTPCValue(uint in_rtpcID, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_1(in_rtpcID, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param>
  public static AKRESULT ResetRTPCValue(uint in_rtpcID, ulong in_gameObjectID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_2(in_rtpcID, in_gameObjectID, in_uValueChangeDuration); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT ResetRTPCValue(uint in_rtpcID, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_3(in_rtpcID, in_gameObjectID); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_rtpcID is AK_INVALID_UNIQUE_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param>
  public static AKRESULT ResetRTPCValue(uint in_rtpcID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_4(in_rtpcID); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValue"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when for example loading a level and you dont want the values to interpolate.</param>
  public static AKRESULT ResetRTPCValue(string in_pszRtpcName, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_5(in_pszRtpcName, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValue"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT ResetRTPCValue(string in_pszRtpcName, ulong in_gameObjectID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_6(in_pszRtpcName, in_gameObjectID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValue"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param>
  public static AKRESULT ResetRTPCValue(string in_pszRtpcName, ulong in_gameObjectID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_7(in_pszRtpcName, in_gameObjectID, in_uValueChangeDuration); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValue"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT ResetRTPCValue(string in_pszRtpcName, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_8(in_pszRtpcName, in_gameObjectID); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value with global scope or with game object scope.
  ///  Game object scope supersedes global scope. Game parameter values reset with global scope are applied to all
  ///  game objects that were not overridden with a value with game object scope.
  ///  To reset a game parameter value with global scope, pass AK_INVALID_GAME_OBJECT as the game object.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve. If you call SetRTPCValue() or ResetRTPCValue() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValue"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param>
  public static AKRESULT ResetRTPCValue(string in_pszRtpcName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValue__SWIG_9(in_pszRtpcName); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when for example loading a level and you dont want the values to interpolate.</param>
  public static AKRESULT ResetRTPCValueByPlayingID(uint in_rtpcID, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_0(in_rtpcID, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT ResetRTPCValueByPlayingID(uint in_rtpcID, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_1(in_rtpcID, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards its default value</param>
  public static AKRESULT ResetRTPCValueByPlayingID(uint in_rtpcID, uint in_playingID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_2(in_rtpcID, in_playingID, in_uValueChangeDuration); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0)</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_rtpcID"> ID of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param>
  public static AKRESULT ResetRTPCValueByPlayingID(uint in_rtpcID, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_3(in_rtpcID, in_playingID); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0) or if if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param> 
  /// <param name="in_bBypassInternalValueInterpolation"> True if you want to bypass the internal "slew rate" or "over time filtering" specified by the sound designer. This is meant to be used when for example loading a level and you dont want the values to interpolate.</param>
  public static AKRESULT ResetRTPCValueByPlayingID(string in_pszRtpcName, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve, bool in_bBypassInternalValueInterpolation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_4(in_pszRtpcName, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve, in_bBypassInternalValueInterpolation); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0) or if if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param> 
  /// <param name="in_eFadeCurve"> Curve type to be used for the game parameter interpolation</param>
  public static AKRESULT ResetRTPCValueByPlayingID(string in_pszRtpcName, uint in_playingID, int in_uValueChangeDuration, AkCurveInterpolation in_eFadeCurve) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_5(in_pszRtpcName, in_playingID, in_uValueChangeDuration, (int)in_eFadeCurve); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0) or if if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param> 
  /// <param name="in_uValueChangeDuration"> Duration during which the game parameter is interpolated towards in_value</param>
  public static AKRESULT ResetRTPCValueByPlayingID(string in_pszRtpcName, uint in_playingID, int in_uValueChangeDuration) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_6(in_pszRtpcName, in_playingID, in_uValueChangeDuration); }

  ///  Resets the value of the game parameter to its default value, as specified in the Wwise project.
  ///  With this function, you may reset a game parameter to its default value on playing id scope.
  ///  Playing id scope supersedes both game object scope and global scope.
  ///  With this function, you may also reset the value of a game parameter over time. To do so, specify a non-zero
  ///  value for in_uValueChangeDuration. At each audio frame, the game parameter value will be updated internally
  ///  according to the interpolation curve.
  ///   If you call SetRTPCValueByPlayingID() or ReetRTPCValueByPlayingID() with in_uValueChangeDuration = 0 in the
  ///  middle of an interpolation, the interpolation stops and the new value is set directly.
  ///  See \ref soundengine_rtpc_pergameobject, \ref soundengine_rtpc_buses and
  ///  \ref soundengine_rtpc_effects for more details on RTPC scope.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_playingID is AK_INVALID_PLAYING_ID (0) or if if in_pszParamName is NULL.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - AK.SoundEngine.SetRTPCValueByPlayingID"/>
  /// <param name="in_pszRtpcName"> Name of the game parameter</param> 
  /// <param name="in_playingID"> Associated playing ID</param>
  public static AKRESULT ResetRTPCValueByPlayingID(string in_pszRtpcName, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetRTPCValueByPlayingID__SWIG_7(in_pszRtpcName, in_playingID); }

  ///  Sets the State of a Switch Group (by IDs).
  /// <returns>Always returns AK_Success</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_switch
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_switchGroup"> ID of the Switch Group</param> 
  /// <param name="in_switchState"> ID of the Switch</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT SetSwitch(uint in_switchGroup, uint in_switchState, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSwitch__SWIG_0(in_switchGroup, in_switchState, in_gameObjectID); }

  ///  Sets the State of a Switch Group (by Unicode string names).
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if the switch or Switch Group name was not resolved to an existing ID
  ///
  ///      Make sure that the banks were generated with the "include string" option.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_switch"/>
  /// <param name="in_pszSwitchGroup"> Name of the Switch Group</param> 
  /// <param name="in_pszSwitchState"> Name of the Switch</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT SetSwitch(string in_pszSwitchGroup, string in_pszSwitchState, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSwitch__SWIG_1(in_pszSwitchGroup, in_pszSwitchState, in_gameObjectID); }

  ///  Post the specified trigger (by IDs).
  /// <returns>Always returns AK_Success</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_triggers
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_triggerID"> ID of the trigger</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT PostTrigger(uint in_triggerID, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostTrigger__SWIG_0(in_triggerID, in_gameObjectID); }

  ///  Posts the specified trigger (by Unicode string name).
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if the trigger name was null
  ///      Make sure that the banks were generated with the "include string" option.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_triggers"/>
  /// <param name="in_pszTrigger"> Name of the trigger</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param>
  public static AKRESULT PostTrigger(string in_pszTrigger, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostTrigger__SWIG_1(in_pszTrigger, in_gameObjectID); }

  ///  Sets the state of a State Group (by IDs).
  /// <returns>Always returns AK_Success</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_states
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_stateGroup"> ID of the State Group</param> 
  /// <param name="in_state"> ID of the state</param>
  public static AKRESULT SetState(uint in_stateGroup, uint in_state) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetState__SWIG_0(in_stateGroup, in_state); }

  ///  Sets the state of a State Group (by Unicode string names).
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidID`` if the state or State Group name was null
  ///      Make sure that the banks were generated with the "include string" option.
  ///      Strings are case-insensitive.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_states
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <param name="in_pszStateGroup"> Name of the State Group</param> 
  /// <param name="in_pszState"> Name of the state</param>
  public static AKRESULT SetState(string in_pszStateGroup, string in_pszState) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetState__SWIG_1(in_pszStateGroup, in_pszState); }

  ///  Sets the Auxiliary Busses to route the specified game object
  ///  To clear the game object's auxiliary sends, ``in_uNumSendValues`` must be 0.
  /// <seealso cref="
  ///  - \ref soundengine_environments
  ///  - \ref soundengine_environments_dynamic_aux_bus_routing
  ///  - \ref soundengine_environments_id_vs_string
  ///  - AK.SoundEngine.GetIDFromString"/>
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_InvalidParameter`` if a duplicated environment is found in the array
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf</returns> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="in_aAuxSendValues"> Variable-size array of AkAuxSendValue structures
  ///      (it may be NULL if no environment must be set)</param> 
  /// <param name="in_uNumSendValues"> The number of auxiliary busses at the pointer's address
  ///      (it must be 0 if no environment is set)</param>
  public static AKRESULT SetGameObjectAuxSendValues(ulong in_gameObjectID, AkAuxSendArray in_aAuxSendValues, uint in_uNumSendValues) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGameObjectAuxSendValues(in_gameObjectID, in_aAuxSendValues.GetBuffer(), in_uNumSendValues); }

  ///  Sets the Output Bus Volume (direct) to be used for the specified game object.
  ///  The control value is a number ranging from 0.0f to 1.0f.
  ///  Output Bus Volumes are stored per listener association, so calling this function will override the default set of listeners. The game object in_emitterObjID will now reference its own set of listeners which will
  ///  be the same as the old set of listeners, but with the new associated gain.  Future changes to the default listener set will not be picked up by this game object unless ResetListenersToDefault() is called.
  /// <seealso cref="
  ///  - \ref AK.SoundEngine.ResetListenersToDefault
  ///  - \ref soundengine_environments
  ///  - \ref soundengine_environments_setting_dry_environment
  ///  - \ref soundengine_environments_id_vs_string"/>
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf</returns> 
  /// <param name="in_emitterObjID"> Associated emitter game object ID</param> 
  /// <param name="in_listenerObjID"> Associated listener game object ID. Pass AK_INVALID_GAME_OBJECT to set the Output Bus Volume for all connected listeners.</param> 
  /// <param name="in_fControlValue"> A multiplier in the range [0.0f:16.0f] ( -∞ dB to +24 dB).																			
  ///      A value greater than 1.0f will amplify the sound.</param>
  public static AKRESULT SetGameObjectOutputBusVolume(ulong in_emitterObjID, ulong in_listenerObjID, float in_fControlValue) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGameObjectOutputBusVolume(in_emitterObjID, in_listenerObjID, in_fControlValue); }

  ///  Sets an Effect ShareSet at the specified audio node and Effect slot index.
  ///
  ///  Replacing effects is preferably done through a Set Effect Event Action.
  ///
  ///  The target node cannot be a Bus, to set effects on a bus, use SetBusEffect() instead.
  ///  The option "Override Parent" in
  ///  the Effect section in Wwise must be enabled for this node, otherwise the parent's effect will
  ///  still be the one in use and the call to SetActorMixerEffect will have no impact.
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_audioNodeID"> Can be a member of the Containers Hierarchy (not a bus).</param> 
  /// <param name="in_uFXIndex"> Effect slot index (0-254)</param> 
  /// <param name="in_shareSetID"> ShareSets ID; pass AK_INVALID_UNIQUE_ID to clear the effect slot</param>
  public static AKRESULT SetActorMixerEffect(uint in_audioNodeID, uint in_uFXIndex, uint in_shareSetID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetActorMixerEffect(in_audioNodeID, in_uFXIndex, in_shareSetID); }

  ///  Sets an Effect ShareSet at the specified bus and Effect slot index.
  ///
  ///  Replacing effects is preferably done through a Set Effect Event Action.
  ///
  ///  The Bus can either be an Audio Bus or an Auxiliary Bus.
  ///  This adds a reference on the audio node to an existing ShareSet.
  ///  This function has unspecified behavior when adding an Effect to a currently playing
  ///  Bus which does not have any Effects, or removing the last Effect on a currently playing bus.
  ///
  ///  This function will replace existing Effects on the node. If the target node is not at
  ///  the top of the hierarchy and is in the Containers hierarchy, the option "Override Parent" in
  ///  the Effect section in Wwise must be enabled for this node, otherwise the parent's Effect will
  ///  still be the one in use and the call to SetBusEffect will have no impact.
  /// <returns>
  ///      - ``AK_Success`` when successfully posted.
  ///      - ``AK_IDNotFound`` if the Bus isn't found by in_audioNodeID
  ///      - ``AK_InvalidParameter`` if in_uFXIndex isn't in range</returns> 
  /// <param name="in_audioNodeID"> Bus Short ID.</param> 
  /// <param name="in_uFXIndex"> Effect slot index (0-254)</param> 
  /// <param name="in_shareSetID"> ShareSets ID; pass AK_INVALID_UNIQUE_ID to clear the Effect slot</param>
  public static AKRESULT SetBusEffect(uint in_audioNodeID, uint in_uFXIndex, uint in_shareSetID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBusEffect__SWIG_0(in_audioNodeID, in_uFXIndex, in_shareSetID); }

  ///  Sets an Effect ShareSet at the specified Bus and Effect slot index.
  ///
  ///  Replacing effects is preferably done through a Set Effect Event Action.
  ///
  ///  The Bus can either be an Audio Bus or an Auxiliary Bus.
  ///  This adds a reference on the audio node to an existing ShareSet.
  ///  This function has unspecified behavior when adding an Effect to a currently playing
  ///  bus which does not have any Effects, or removing the last Effect on a currently playing Bus.
  ///
  ///  This function will replace existing Effects on the node. If the target node is not at
  ///  the top of the hierarchy and is in the Containers, the option "Override Parent" in
  ///  the Effect section in Wwise must be enabled for this node, otherwise the parent's Effect will
  ///  still be the one in use and the call to ``SetBusEffect`` will have no impact.
  /// <returns>
  ///      - ``AK_Success`` when successfully posted.
  ///      - ``AK_IDNotFound`` if the Bus name doesn't point to a valid bus.
  ///      - ``AK_InvalidID`` if in_pszBusName is null
  ///      - ``AK_InvalidParameter`` if in_uFXIndex isn't in range or in_pszBusName is null</returns> 
  /// <param name="in_pszBusName"> Bus name</param> 
  /// <param name="in_uFXIndex"> Effect slot index (0-254)</param> 
  /// <param name="in_shareSetID"> ShareSets ID; pass AK_INVALID_UNIQUE_ID to clear the effect slot</param>
  public static AKRESULT SetBusEffect(string in_pszBusName, uint in_uFXIndex, uint in_shareSetID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBusEffect__SWIG_1(in_pszBusName, in_uFXIndex, in_shareSetID); }

  ///  Sets an audio device effect shareset on the specified output device and effect slot index.
  ///
  ///  Replacing effects is preferably done through a Set Effect Event Action.
  ///
  ///  Make sure the new effect shareset is included in a soundbank, and that sound bank is loaded. Otherwise you will see errors in the Capture Log.
  ///  This function will replace existing effects of the audio device shareset.
  ///  Audio device effects support is limited to one shareset per plug-in type at any time.
  ///  Errors are reported in the Wwise Capture Log if the effect cannot be set on the output device.
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_outputDeviceID"> Output ID, as returned from AddOutput or GetOutputID. Most of the time this should be 0 to designate the main (default) output</param> 
  /// <param name="in_uFXIndex"> Effect slot index (0-254)</param> 
  /// <param name="in_FXShareSetID"> Effect ShareSet ID</param>
  public static AKRESULT SetOutputDeviceEffect(ulong in_outputDeviceID, uint in_uFXIndex, uint in_FXShareSetID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetOutputDeviceEffect(in_outputDeviceID, in_uFXIndex, in_FXShareSetID); }

  ///  Forces channel configuration for the specified bus.
  ///  You cannot change the configuration of the master bus.
  ///
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_audioNodeID"> Bus Short ID.</param> 
  /// <param name="in_channelConfig"> Desired channel configuration. An invalid configuration (from default constructor) means "as parent".</param>
  public static AKRESULT SetBusConfig(uint in_audioNodeID, AkChannelConfig in_channelConfig) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBusConfig__SWIG_0(in_audioNodeID, AkChannelConfig.getCPtr(in_channelConfig)); }

  ///  Forces channel configuration for the specified bus.
  ///  You cannot change the configuration of the master bus.
  ///
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidID`` if in_pszBusName is null</returns> 
  /// <param name="in_pszBusName"> Bus name</param> 
  /// <param name="in_channelConfig"> Desired channel configuration. An invalid configuration (from default constructor) means "as parent".</param>
  public static AKRESULT SetBusConfig(string in_pszBusName, AkChannelConfig in_channelConfig) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBusConfig__SWIG_1(in_pszBusName, AkChannelConfig.getCPtr(in_channelConfig)); }

  ///  Sets a game object's obstruction and occlusion levels. If SetMultiplePositions were used, values are set for all positions.
  ///  To assign a unique obstruction and occlusion value to each sound position, instead use AK::SoundEngine::SetMultipleObstructionAndOcclusion.
  ///  This function is used to affect how an object should be heard by a specific listener.
  /// <seealso cref="
  ///  - \ref soundengine_obsocc
  ///  - \ref soundengine_environments"/>
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_EmitterID"> Emitter game object ID</param> 
  /// <param name="in_ListenerID"> Listener game object ID</param> 
  /// <param name="in_fObstructionLevel"> ObstructionLevel: [0.0f..1.0f]</param> 
  /// <param name="in_fOcclusionLevel"> OcclusionLevel: [0.0f..1.0f]</param>
  public static AKRESULT SetObjectObstructionAndOcclusion(ulong in_EmitterID, ulong in_ListenerID, float in_fObstructionLevel, float in_fOcclusionLevel) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetObjectObstructionAndOcclusion(in_EmitterID, in_ListenerID, in_fObstructionLevel, in_fOcclusionLevel); }

  ///  Sets a game object's obstruction and occlusion value for each position defined by AK::SoundEngine::SetMultiplePositions.
  ///  This function differs from AK::SoundEngine::SetObjectObstructionAndOcclusion as a list of obstruction/occlusion pair is provided
  ///  and each obstruction/occlusion pair will affect the corresponding position defined at the same index.
  ///  In the case the number of obstruction/occlusion pairs is smaller than the number of positions, remaining positions'
  ///  obstruction/occlusion values are set to 0.0.
  /// <returns>
  ///      - ``AK_Success`` if successful
  ///      - ``AK_CommandTooLarge`` if the number of obstruction values is too large for the command queue.
  ///      - ``AK_InvalidParameter`` if one of the parameter is out of range (check the debug console)
  ///      - ``AK_InvalidFloatValue`` if one of the occlusion/obstruction values is NaN or Inf.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_obsocc
  ///  - \ref soundengine_environments"/>
  /// <returns>AK_Success if occlusion/obstruction values are successfully stored for this emitter</returns> 
  /// <param name="in_EmitterID"> Emitter game object ID</param> 
  /// <param name="in_uListenerID"> Listener game object ID</param> 
  /// <param name="in_fObstructionOcclusionValues"> Array of obstruction/occlusion pairs to apply
  ///      ObstructionLevel: [0.0f..1.0f]
  ///      OcclusionLevel: [0.0f..1.0f]</param> 
  /// <param name="in_uNumOcclusionObstruction"> Number of obstruction/occlusion pairs specified in the provided array</param>
  public static AKRESULT SetMultipleObstructionAndOcclusion(ulong in_EmitterID, ulong in_uListenerID, AkObstructionOcclusionValuesArray in_fObstructionOcclusionValues, uint in_uNumOcclusionObstruction) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMultipleObstructionAndOcclusion(in_EmitterID, in_uListenerID, in_fObstructionOcclusionValues.GetBuffer(), in_uNumOcclusionObstruction); }

  ///  Starts recording the sound engine audio output.
  ///  StartOutputCapture outputs a wav file per current output device of the sound engine.
  ///  If more than one device is active, the system will create multiple files in the same output
  ///  directory and will append numbers at the end of the provided filename.
  ///  If no device is running yet, the system will return success AK_Success despite doing nothing.
  ///  Use RegisterAudioDeviceStatusCallback to get notified when devices are created/destructed.
  ///
  /// <returns>AK_Success if successful, AK_Fail if there was a problem starting the output capture.</returns> 
  /// <remarks>		- The sound engine opens a stream for writing using AK::IAkStreamMgr::CreateStd(). If you are using the			default implementation of the Stream Manager, file opening is executed in your implementation of			the Low-Level IO interface AK::StreamMgr::IAkLowLevelIOHook::BatchOpen(). The following			AkFileSystemFlags are passed: uCompanyID = AKCOMPANYID_AUDIOKINETIC and uCodecID = AKCODECID_PCM,			and the AkOpenMode is AK_OpenModeWriteOvrwr. See \ref streamingmanager_lowlevel_location for			more details on managing the deployment of your Wwise generated data.</remarks>
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidParameter`` if in_CaptureFileName is null.
  ///      - ``AK_InsufficientMemory`` if not enough memory is available.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.StopOutputCapture"/>
  /// <param name="in_CaptureFileName"> Name of the output capture file</param>
  public static AKRESULT StartOutputCapture(string in_CaptureFileName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StartOutputCapture(in_CaptureFileName); }

  ///  Stops recording the sound engine audio output.
  /// <returns>AK_Success if successful, AK_Fail if there was a problem stopping the output capture.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.StartOutputCapture"/>
  public static AKRESULT StopOutputCapture() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StopOutputCapture(); }

  ///  Adds text marker in audio output file.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidParameter`` if in_MarkerText is null.
  ///      - ``AK_InsufficientMemory`` if not enough memory is available.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.StartOutputCapture"/>
  /// <param name="in_MarkerText"> Text of the marker</param> 
  /// <param name="in_uSamplePos"> Sample to attach the marker to. If set to AK_INVALID_SAMPLE_POS, marker is added at the current recording time.</param>
  public static AKRESULT AddOutputCaptureMarker(string in_MarkerText, uint in_uSamplePos) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutputCaptureMarker__SWIG_0(in_MarkerText, in_uSamplePos); }

  ///  Adds text marker in audio output file.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidParameter`` if in_MarkerText is null.
  ///      - ``AK_InsufficientMemory`` if not enough memory is available.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.StartOutputCapture"/>
  /// <param name="in_MarkerText"> Text of the marker</param>
  public static AKRESULT AddOutputCaptureMarker(string in_MarkerText) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutputCaptureMarker__SWIG_1(in_MarkerText); }

  ///  Adds binary data to a marker in audio output file.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidParameter`` if in_pMarkerData is null or in_uMarkerDataSize is zero.
  ///      - ``AK_InsufficientMemory`` if not enough memory is available.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.StartOutputCapture"/>
  /// <param name="in_pMarkerData"> Marker data</param> 
  /// <param name="in_uMarkerDataSize"> Size of the marker data</param> 
  /// <param name="in_uSamplePos"> Sample to attach the marker to. If set to AK_INVALID_SAMPLE_POS, marker is added at the current recording time.</param>
  public static AKRESULT AddOutputCaptureBinaryMarker(global::System.IntPtr in_pMarkerData, uint in_uMarkerDataSize, uint in_uSamplePos) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutputCaptureBinaryMarker__SWIG_0(in_pMarkerData, in_uMarkerDataSize, in_uSamplePos); }

  ///  Adds binary data to a marker in audio output file.
  /// <returns>
  ///      - ``AK_Success`` when successful
  ///      - ``AK_InvalidParameter`` if in_pMarkerData is null or in_uMarkerDataSize is zero.
  ///      - ``AK_InsufficientMemory`` if not enough memory is available.</returns> 
  /// <seealso cref="
  ///  - AK.SoundEngine.StartOutputCapture"/>
  /// <param name="in_pMarkerData"> Marker data</param> 
  /// <param name="in_uMarkerDataSize"> Size of the marker data</param>
  public static AKRESULT AddOutputCaptureBinaryMarker(global::System.IntPtr in_pMarkerData, uint in_uMarkerDataSize) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutputCaptureBinaryMarker__SWIG_1(in_pMarkerData, in_uMarkerDataSize); }

  ///  Gets the system sample rate.
  /// <returns>The sample rate.</returns>
  public static uint GetSampleRate() { return AkUnitySoundEnginePINVOKE.CSharp_GetSampleRate(); }

  ///  Starts recording the sound engine profiling information into a file. This file can be read
  ///  by Wwise Authoring. The file is created at the base path. If you have integrated Wwise I/O,
  ///  you can use CAkDefaultIOHookDeferred::SetBasePath() (or CAkDefaultIOHookDeferred::AddBasePath())
  ///  to change the location where the file is saved. The profiling session records all data types possible.
  ///  Note that this call captures peak metering for all the busses loaded and mixing
  ///  while this call is invoked.
  /// <remarks>This function is provided as a utility tool only. It does nothing if it is			called in the release configuration and returns AK_NotCompatible.</remarks>
  /// <param name="in_CaptureFileName"> Name of the output profiler file (.prof extension recommended)</param>
  public static AKRESULT StartProfilerCapture(string in_CaptureFileName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StartProfilerCapture(in_CaptureFileName); }

  ///  Stops recording the sound engine profiling information.
  /// <remarks>This function is provided as a utility tool only. It does nothing if it is			called in the release configuration and returns AK_NotCompatible.</remarks>
  public static AKRESULT StopProfilerCapture() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_StopProfilerCapture(); }

  ///  Sets the offline rendering frame time in seconds.
  ///  When offline rendering is enabled, every call to \ref RenderAudio() will generate sample data as if this much time has elapsed. If the frame time argument is less than or equal to zero, every call to RenderAudio() will generate one audio buffer.
  ///
  /// <seealso cref="\ref goingfurther_offlinerendering"/>
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_fFrameTimeInSeconds"> frame time in seconds used during offline rendering</param>
  public static AKRESULT SetOfflineRenderingFrameTime(float in_fFrameTimeInSeconds) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetOfflineRenderingFrameTime(in_fFrameTimeInSeconds); }

  ///  Enables/disables offline rendering.
  ///
  /// <seealso cref="\ref goingfurther_offlinerendering"/>
  /// <returns>Always returns AK_Success</returns> 
  /// <param name="in_bEnableOfflineRendering"> enables/disables offline rendering</param>
  public static AKRESULT SetOfflineRendering(bool in_bEnableOfflineRendering) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetOfflineRendering(in_bEnableOfflineRendering); }

  ///  Removes one output added through AK::SoundEngine::AddOutput
  ///  If a listener was associated with the device, you should consider unregistering the listener prior to call RemoveOutput
  ///  so that Game Object/Listener routing is properly updated according to your game scenario.			
  /// <seealso cref="\ref integrating_secondary_outputs"/>
  /// <seealso cref="AK.SoundEngine.AddOutput"/>
  /// <returns>AK_Success: Parameters are valid.</returns> 
  /// <param name="in_idOutput"> ID of the output to remove.  Use the returned ID from AddOutput, GetOutputID, or ReplaceOutput</param>
  public static AKRESULT RemoveOutput(ulong in_idOutput) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveOutput(in_idOutput); }

  ///  Replaces an output device previously created during engine initialization or from AddOutput, with a new output device.
  ///  In addition to simply removing one output device and adding a new one, the new output device will also be used on all of the master buses
  ///  that the old output device was associated with, and preserve all listeners that were attached to the old output device.
  ///  Like most functions of AK::SoundEngine, AddOutput is asynchronous. A successful return code merely indicates that the request is properly queued.
  ///  Error codes returned by this function indicate various invalid parameters. To know if this function succeeds or not, and the failure code,
  ///  register an AkDeviceStatusCallbackFunc callback with RegisterAudioDeviceStatusCallback.
  ///
  /// <seealso cref="AK.SoundEngine.AddOutput"/>
  /// <seealso cref="AK.SoundEngine.RegisterAudioDeviceStatusCallback"/>
  /// <seealso cref="AK.AkDeviceStatusCallbackFunc"/>
  /// <returns>
  ///      - ``AK_InvalidID``: The audioDeviceShareset on in_settings was not valid.
  ///      - ``AK_IDNotFound``: The audioDeviceShareset on in_settings doesn't exist.  Possibly, the Init bank isn't loaded yet or was not updated with latest changes.
  ///      - ``AK_DeviceNotReady``: The idDevice on in_settings doesn't match with a valid hardware device.  Either the device doesn't exist or is disabled.  Disconnected devices (headphones) are not considered "not ready" therefore won't cause this error.
  ///      - ``AK_DeviceNotFound``: The in_outputDeviceId provided does not match with any of the output devices that the sound engine is currently using.
  ///      - ``AK_InvalidParameter``: Out of range parameters or unsupported parameter combinations on in_settings
  ///      - ``AK_Success``: parameters were valid, and the remove and add will occur.</returns> 
  /// <param name="in_Settings"> Creation parameters for this output.  \ref AkOutputSettings</param> 
  /// <param name="in_outputDeviceId"> AkOutputDeviceID of the output to replace. Use 0 to target the current main output, regardless of its id.  Otherwise, use the AkOutputDeviceID returned from AddOutput() or ReplaceOutput(), or generated by GetOutputID()</param> 
  /// <param name="out_pOutputDeviceId"> (Optional) Pointer into which the method writes the AkOutputDeviceID of the new output device. If the call fails, the value pointed to will not be modified.</param>
  public static AKRESULT ReplaceOutput(AkOutputSettings in_Settings, ulong in_outputDeviceId, out ulong out_pOutputDeviceId) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ReplaceOutput__SWIG_0(AkOutputSettings.getCPtr(in_Settings), in_outputDeviceId, out out_pOutputDeviceId); }

  ///  Replaces an output device previously created during engine initialization or from AddOutput, with a new output device.
  ///  In addition to simply removing one output device and adding a new one, the new output device will also be used on all of the master buses
  ///  that the old output device was associated with, and preserve all listeners that were attached to the old output device.
  ///  Like most functions of AK::SoundEngine, AddOutput is asynchronous. A successful return code merely indicates that the request is properly queued.
  ///  Error codes returned by this function indicate various invalid parameters. To know if this function succeeds or not, and the failure code,
  ///  register an AkDeviceStatusCallbackFunc callback with RegisterAudioDeviceStatusCallback.
  ///
  /// <seealso cref="AK.SoundEngine.AddOutput"/>
  /// <seealso cref="AK.SoundEngine.RegisterAudioDeviceStatusCallback"/>
  /// <seealso cref="AK.AkDeviceStatusCallbackFunc"/>
  /// <returns>
  ///      - ``AK_InvalidID``: The audioDeviceShareset on in_settings was not valid.
  ///      - ``AK_IDNotFound``: The audioDeviceShareset on in_settings doesn't exist.  Possibly, the Init bank isn't loaded yet or was not updated with latest changes.
  ///      - ``AK_DeviceNotReady``: The idDevice on in_settings doesn't match with a valid hardware device.  Either the device doesn't exist or is disabled.  Disconnected devices (headphones) are not considered "not ready" therefore won't cause this error.
  ///      - ``AK_DeviceNotFound``: The in_outputDeviceId provided does not match with any of the output devices that the sound engine is currently using.
  ///      - ``AK_InvalidParameter``: Out of range parameters or unsupported parameter combinations on in_settings
  ///      - ``AK_Success``: parameters were valid, and the remove and add will occur.</returns> 
  /// <param name="in_Settings"> Creation parameters for this output.  \ref AkOutputSettings</param> 
  /// <param name="in_outputDeviceId"> AkOutputDeviceID of the output to replace. Use 0 to target the current main output, regardless of its id.  Otherwise, use the AkOutputDeviceID returned from AddOutput() or ReplaceOutput(), or generated by GetOutputID()</param>
  public static AKRESULT ReplaceOutput(AkOutputSettings in_Settings, ulong in_outputDeviceId) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ReplaceOutput__SWIG_1(AkOutputSettings.getCPtr(in_Settings), in_outputDeviceId); }

  ///  Gets the compounded output ID from shareset and device id.
  ///  Outputs are defined by their type (Audio Device shareset) and their specific system ID.  A system ID could be reused for other device types on some OS or platforms, hence the compounded ID.
  ///  Use 0 for in_idShareset &amp; in_idDevice to get the Main Output ID (the one usually initialized during AK::SoundEngine::Init)
  /// <returns>The id of the output					</returns> 
  /// <param name="in_idShareset"> Audio Device ShareSet ID, as defined in the Wwise Project.  If needed, use AK::SoundEngine::GetIDFromString() to convert from a string.  Set to AK_INVALID_UNIQUE_ID to use the default.</param> 
  /// <param name="in_idDevice"> Device specific identifier, when multiple devices of the same type are possible.  If only one device is possible, leave to 0.</param> 
  /// <seealso cref="\ref obtaining_device_id"/>
  public static ulong GetOutputID(uint in_idShareset, uint in_idDevice) { return AkUnitySoundEnginePINVOKE.CSharp_GetOutputID__SWIG_0(in_idShareset, in_idDevice); }

  public static ulong GetOutputID(string in_szShareSet, uint in_idDevice) { return AkUnitySoundEnginePINVOKE.CSharp_GetOutputID__SWIG_1(in_szShareSet, in_idDevice); }

  ///  Sets the Audio Device to which a master bus outputs.  This overrides the setting in the Wwise project.	
  ///  Can only be set on top-level busses. The Init bank should be successfully loaded prior to this call.
  ///  This function is useful only if used before the creation of an output, at the beginning of the sound engine setup.
  ///  Once active outputs using this Bus have been created, it is imperative to use AK::SoundEngine:ReplaceOutput instead to change the type of output.
  /// <returns>
  ///      AK_IDNotFound when either the Bus ID or the Device ID are not present in the Init bank or the bank was not loaded
  ///      AK_InvalidParameter when the specified bus is not a Master Bus.  This function can be called only on busses that have no parent bus.</returns> 
  /// <param name="in_idBus"> Id of the master bus</param> 
  /// <param name="in_idNewDevice"> New device shareset to replace with.</param>
  public static AKRESULT SetBusDevice(uint in_idBus, uint in_idNewDevice) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBusDevice__SWIG_0(in_idBus, in_idNewDevice); }

  ///  Sets the Audio Device to which a master bus outputs.  This overrides the setting in the Wwise project.	
  ///  Can only be set on top-level busses. The Init bank should be successfully loaded prior to this call.
  ///  This function is useful only if used before the creation of an output, at the beginning of the sound engine setup.
  ///  Once active outputs using this Bus have been created, it is imperative to use AK::SoundEngine:ReplaceOutput instead to change the type of output.
  /// <returns>
  ///      AK_IDNotFound when either the Bus ID or the Device ID are not present in the Init bank or the bank was not loaded
  ///      AK_InvalidParameter when the specified bus is not a Master Bus.  This function can be called only on busses that have no parent bus.</returns> 
  /// <param name="in_BusName"> Name of the master bus</param> 
  /// <param name="in_DeviceName"> New device shareset to replace with.</param>
  public static AKRESULT SetBusDevice(string in_BusName, string in_DeviceName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBusDevice__SWIG_1(in_BusName, in_DeviceName); }

  ///  Returns a listing of the current devices for a given sink plug-in, including Device ID, friendly name, and state.
  /// <remarks> This call is only valid for sink plug-ins that support device enumeration. Prerequisites:The plug-in must have been initialized by loading the init bank or by calling \ref AK::SoundEngine::RegisterPlugin.A physical device recognized by this plug-in must exist in the system.</remarks>
  ///  The built-in audio devices (System, Communication, Headphones, Personal, Pad Speaker) all support enumeration, on all platforms.
  ///  The only Wwise plug-in that support device enumeration is Motion, for the Windows platform only.
  ///  Note that it is optional to implement device enumeration on custom sink plug-ins.
  /// <returns>
  ///      - ``AK_NotImplemented`` if the sink plug-in does not implement device enumeration
  ///      - ``AK_PluginNotRegistered`` if the plug-in has not been registered yet either by loading the init bank or by calling RegisterPluginDLL.
  ///      - ``AK_NotCompatible`` if no device of this type are supported on the current platform
  ///      - ``AK_Fail`` in case of system device manager failure (OS related)</returns> 
  ///
  /// <param name="in_ulCompanyID"> Company identifier (as declared in the plug-in description XML file)</param> 
  /// <param name="in_ulPluginID"> Plug-in identifier (as declared in the plug-in description XML file)</param> 
  /// <param name="io_maxNumDevices"> In: The length of the out_deviceDescriptions array. Out: If out_deviceDescriptions is not-null, this will be set to the number of entries in out_deviceDescriptions that was populated. If out_deviceDescriptions is null, this will be set to the number of devices that may be available.</param> 
  /// <param name="out_deviceDescriptions"> The output array of device descriptions.</param>
  public static AKRESULT GetDeviceList(uint in_ulCompanyID, uint in_ulPluginID, out uint io_maxNumDevices, AkDeviceDescriptionArray out_deviceDescriptions) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetDeviceList__SWIG_0(in_ulCompanyID, in_ulPluginID, out io_maxNumDevices, out_deviceDescriptions.GetBuffer()); }

  ///  Returns a listing of the current devices for a given sink plug-in, including Device ID, friendly name, and state.
  /// <remarks> This call is only valid for sink plug-ins that support device enumeration. Prerequisites:The plug-in must have been initialized by loading the init bank or by calling \ref AK::SoundEngine::RegisterPlugin.The audio device shareset must have been loaded from a soundbank, and a physical device recognized by this plug-in must exist in the system.</remarks>
  ///  The built-in audio devices (System, Communication, Headphones, Personal, Pad Speaker) all support enumeration, on all platforms.
  ///  The only Wwise plug-in that support device enumeration is Motion, for the Windows platform only.
  ///  Note that it is optional to implement device enumeration on custom sink plug-ins.
  /// <returns>
  ///      AK_NotImplemented if the sink plug-in does not implement device enumeration
  ///      AK_PluginNotRegistered if the plug-in has not been registered yet either by loading the init bank or by calling RegisterPluginDLL.</returns> 
  /// <param name="in_audioDeviceShareSetID"> In: The audio device shareset ID for which to list the sink plug-in devices.</param> 
  /// <param name="io_maxNumDevices"> In: The length of the out_deviceDescriptions array. Out: If out_deviceDescriptions is not-null, this will be set to the number of entries in out_deviceDescriptions that was populated. If out_deviceDescriptions is null, this will be set to the number of devices that may be available.</param> 
  /// <param name="out_deviceDescriptions"> The output array of device descriptions.</param>
  public static AKRESULT GetDeviceList(uint in_audioDeviceShareSetID, out uint io_maxNumDevices, AkDeviceDescriptionArray out_deviceDescriptions) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetDeviceList__SWIG_1(in_audioDeviceShareSetID, out io_maxNumDevices, out_deviceDescriptions.GetBuffer()); }

  ///  Sets the volume of a output device.		
  /// <returns>
  ///      - ``AK_Success`` if successful		
  ///      - ``AK_InvalidFloatValue`` if the value specified was NaN or Inf</returns> 
  /// <param name="in_idOutput"> Output ID to set the volume on.  As returned from AddOutput or GetOutputID</param> 
  /// <param name="in_fVolume"> Volume (0.0 = Muted, 1.0 = Volume max)</param>
  public static AKRESULT SetOutputVolume(ulong in_idOutput, float in_fVolume) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetOutputVolume(in_idOutput, in_fVolume); }

  ///  Returns whether or not the audio device matching the device ID provided supports spatial audio (i.e. the functionality is enabled, and more than 0 dynamic objects are supported).
  ///  If Spatial Audio is supported, then you can call Init, AddOutput, or ReplaceOutput with an Audio Device Shareset corresponding to the respective platform-specific plug-in that
  ///  provides spatial audio, such as the Microsoft Spatial Sound Platform for Windows. Note that on Xbox One, you need to call EnableSpatialAudio() before the sound engine is
  ///  initialized, or initialize the sound engine with AkPlatformInitSettings::bEnableSpatialAudio set to true if you want spatial audio support; otherwise this will always return AK_NotCompatible.
  /// <returns>
  ///      AK_NotCompatible when the device ID provided does not support spatial audio, or the platform does not support spatial audio
  ///      AK_Fail when there is some other miscellaneous failure, or the device ID provided does not match a device that the system knows about
  ///      AK_Success when the device ID provided does support spatial audio</returns> 
  /// <param name="in_idDevice"> Device specific identifier, when multiple devices of the same type are possible.  If only one device is possible, leave to 0.</param> 
  /// <seealso cref="\ref obtaining_device_id"/>
  public static AKRESULT GetDeviceSpatialAudioSupport(uint in_idDevice) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetDeviceSpatialAudioSupport(in_idDevice); }

  ///  This function should be called to put the sound engine in background mode, where audio isn't processed anymore. This needs to be called if the console has a background mode or some suspended state.
  ///  Call ``WakeupFromSuspend`` when your application receives the message from the OS that the process is back in foreground.
  ///  When suspended, the sound engine will process API messages (like PostEvent and SetSwitch) only when \ref RenderAudio() is called.
  ///  It is recommended to match the **in_bRenderAnyway** parameter with the behavior of the rest of your game:
  ///  if your game still runs in background and you must keep some kind of coherent state between the audio engine and game, then allow rendering.
  ///  If you want to minimize CPU when in background, then don't allow rendering and never call RenderAudio from the game.
  ///  Consult \ref workingwithsdks_system_calls to learn when it is appropriate to call this function for each platform.
  /// <seealso cref="WakeupFromSuspend"/>
  /// <seealso cref="\ref workingwithsdks_system_calls"/>
  /// <param name="in_bRenderAnyway"> If set to true, audio processing will still occur, but not outputted. When set to false, no audio will be processed at all, even upon reception of RenderAudio().</param> 
  /// <param name="in_bFadeOut"> Delay the suspend by one audio frame in order to fade-out. When false, the suspend takes effect immediately but audio may glitch.</param>
  public static AKRESULT Suspend(bool in_bRenderAnyway, bool in_bFadeOut) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_Suspend__SWIG_0(in_bRenderAnyway, in_bFadeOut); }

  ///  This function should be called to put the sound engine in background mode, where audio isn't processed anymore. This needs to be called if the console has a background mode or some suspended state.
  ///  Call ``WakeupFromSuspend`` when your application receives the message from the OS that the process is back in foreground.
  ///  When suspended, the sound engine will process API messages (like PostEvent and SetSwitch) only when \ref RenderAudio() is called.
  ///  It is recommended to match the **in_bRenderAnyway** parameter with the behavior of the rest of your game:
  ///  if your game still runs in background and you must keep some kind of coherent state between the audio engine and game, then allow rendering.
  ///  If you want to minimize CPU when in background, then don't allow rendering and never call RenderAudio from the game.
  ///  Consult \ref workingwithsdks_system_calls to learn when it is appropriate to call this function for each platform.
  /// <seealso cref="WakeupFromSuspend"/>
  /// <seealso cref="\ref workingwithsdks_system_calls"/>
  /// <param name="in_bRenderAnyway"> If set to true, audio processing will still occur, but not outputted. When set to false, no audio will be processed at all, even upon reception of RenderAudio().</param>
  public static AKRESULT Suspend(bool in_bRenderAnyway) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_Suspend__SWIG_1(in_bRenderAnyway); }

  ///  This function should be called to put the sound engine in background mode, where audio isn't processed anymore. This needs to be called if the console has a background mode or some suspended state.
  ///  Call ``WakeupFromSuspend`` when your application receives the message from the OS that the process is back in foreground.
  ///  When suspended, the sound engine will process API messages (like PostEvent and SetSwitch) only when \ref RenderAudio() is called.
  ///  It is recommended to match the **in_bRenderAnyway** parameter with the behavior of the rest of your game:
  ///  if your game still runs in background and you must keep some kind of coherent state between the audio engine and game, then allow rendering.
  ///  If you want to minimize CPU when in background, then don't allow rendering and never call RenderAudio from the game.
  ///  Consult \ref workingwithsdks_system_calls to learn when it is appropriate to call this function for each platform.
  /// <seealso cref="WakeupFromSuspend"/>
  /// <seealso cref="\ref workingwithsdks_system_calls"/>
  public static AKRESULT Suspend() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_Suspend__SWIG_2(); }

  ///  This function should be called to wake up the sound engine and start processing audio again. This needs to be called if the console has a background mode or some suspended state.
  ///  Consult \ref workingwithsdks_system_calls to learn when it is appropriate to call this function for each platform.
  /// <seealso cref="Suspend"/>
  /// <seealso cref="\ref workingwithsdks_system_calls"/>
  /// <param name="in_uDelayMs"> Delay (in milliseconds) before the wake up occurs. Rounded up to audio frame granularity. Adding a delay is useful if there is a possibility that another OS event may override the wake-up in the near future.</param>
  public static AKRESULT WakeupFromSuspend(uint in_uDelayMs) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_WakeupFromSuspend__SWIG_0(in_uDelayMs); }

  ///  This function should be called to wake up the sound engine and start processing audio again. This needs to be called if the console has a background mode or some suspended state.
  ///  Consult \ref workingwithsdks_system_calls to learn when it is appropriate to call this function for each platform.
  /// <seealso cref="Suspend"/>
  /// <seealso cref="\ref workingwithsdks_system_calls"/>
  public static AKRESULT WakeupFromSuspend() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_WakeupFromSuspend__SWIG_1(); }

  ///  Obtains the current audio output buffer tick. This corresponds to the number of buffers produced by
  ///  the sound engine since initialization.
  /// <returns>Tick count.</returns>
  public static uint GetBufferTick() { return AkUnitySoundEnginePINVOKE.CSharp_GetBufferTick(); }

  ///  Obtains the current audio output sample tick. This corresponds to the number of samples produced by
  ///  the sound engine since initialization.
  /// <returns>Sample count.</returns>
  public static ulong GetSampleTick() { return AkUnitySoundEnginePINVOKE.CSharp_GetSampleTick(); }

  public static AkAudioDeviceEvent AkAudioDeviceEvent_Initialization { get { return (AkAudioDeviceEvent)AkUnitySoundEnginePINVOKE.CSharp_AkAudioDeviceEvent_Initialization_get(); } 
  }

  public static AkAudioDeviceEvent AkAudioDeviceEvent_Removal { get { return (AkAudioDeviceEvent)AkUnitySoundEnginePINVOKE.CSharp_AkAudioDeviceEvent_Removal_get(); } 
  }

  public static AkAudioDeviceEvent AkAudioDeviceEvent_SystemRemoval { get { return (AkAudioDeviceEvent)AkUnitySoundEnginePINVOKE.CSharp_AkAudioDeviceEvent_SystemRemoval_get(); } 
  }

  public static AkAudioDeviceEvent AkAudioDeviceEvent_Last { get { return (AkAudioDeviceEvent)AkUnitySoundEnginePINVOKE.CSharp_AkAudioDeviceEvent_Last_get(); } 
  }

  ///  Post a monitoring message or error code. This will be displayed in the Wwise capture
  ///  log. Since this function doesn't send variable arguments, be sure that the error code you're posting doesn't contain any tag.
  ///  Otherwise, there'll be an undefined behavior
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_eError"> Message or error code to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param> 
  /// <param name="in_gameObjID"> Related Game Object ID if applicable, AK_INVALID_GAME_OBJECT otherwise</param> 
  /// <param name="in_audioNodeID"> Related Audio Node ID if applicable, AK_INVALID_UNIQUE_ID otherwise</param> 
  /// <param name="in_bIsBus"> true if in_audioNodeID is a bus</param>
  public static AKRESULT PostCode(AkMonitorErrorCode in_eError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID, ulong in_gameObjID, uint in_audioNodeID, bool in_bIsBus) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostCode__SWIG_0((int)in_eError, (int)in_eErrorLevel, in_playingID, in_gameObjID, in_audioNodeID, in_bIsBus); }

  ///  Post a monitoring message or error code. This will be displayed in the Wwise capture
  ///  log. Since this function doesn't send variable arguments, be sure that the error code you're posting doesn't contain any tag.
  ///  Otherwise, there'll be an undefined behavior
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_eError"> Message or error code to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param> 
  /// <param name="in_gameObjID"> Related Game Object ID if applicable, AK_INVALID_GAME_OBJECT otherwise</param> 
  /// <param name="in_audioNodeID"> Related Audio Node ID if applicable, AK_INVALID_UNIQUE_ID otherwise</param>
  public static AKRESULT PostCode(AkMonitorErrorCode in_eError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID, ulong in_gameObjID, uint in_audioNodeID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostCode__SWIG_1((int)in_eError, (int)in_eErrorLevel, in_playingID, in_gameObjID, in_audioNodeID); }

  ///  Post a monitoring message or error code. This will be displayed in the Wwise capture
  ///  log. Since this function doesn't send variable arguments, be sure that the error code you're posting doesn't contain any tag.
  ///  Otherwise, there'll be an undefined behavior
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_eError"> Message or error code to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param> 
  /// <param name="in_gameObjID"> Related Game Object ID if applicable, AK_INVALID_GAME_OBJECT otherwise</param>
  public static AKRESULT PostCode(AkMonitorErrorCode in_eError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID, ulong in_gameObjID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostCode__SWIG_2((int)in_eError, (int)in_eErrorLevel, in_playingID, in_gameObjID); }

  ///  Post a monitoring message or error code. This will be displayed in the Wwise capture
  ///  log. Since this function doesn't send variable arguments, be sure that the error code you're posting doesn't contain any tag.
  ///  Otherwise, there'll be an undefined behavior
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_eError"> Message or error code to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param>
  public static AKRESULT PostCode(AkMonitorErrorCode in_eError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostCode__SWIG_3((int)in_eError, (int)in_eErrorLevel, in_playingID); }

  ///  Post a monitoring message or error code. This will be displayed in the Wwise capture
  ///  log. Since this function doesn't send variable arguments, be sure that the error code you're posting doesn't contain any tag.
  ///  Otherwise, there'll be an undefined behavior
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_eError"> Message or error code to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param>
  public static AKRESULT PostCode(AkMonitorErrorCode in_eError, AkMonitorErrorLevel in_eErrorLevel) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostCode__SWIG_4((int)in_eError, (int)in_eErrorLevel); }

  public static AKRESULT PostCodeVarArg(AkMonitorErrorCode in_eError, AkMonitorErrorLevel in_eErrorLevel, MsgContext msgContext) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostCodeVarArg((int)in_eError, (int)in_eErrorLevel, MsgContext.getCPtr(msgContext)); }

  ///  Post a unicode monitoring message or error string. This will be displayed in the Wwise capture
  ///  log.
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_pszError"> Message or error string to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param> 
  /// <param name="in_gameObjID"> Related Game Object ID if applicable, AK_INVALID_GAME_OBJECT otherwise</param> 
  /// <param name="in_audioNodeID"> Related Audio Node ID if applicable, AK_INVALID_UNIQUE_ID otherwise</param> 
  /// <param name="in_bIsBus"> true if in_audioNodeID is a bus</param>
  public static AKRESULT PostString(string in_pszError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID, ulong in_gameObjID, uint in_audioNodeID, bool in_bIsBus) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostString__SWIG_0(in_pszError, (int)in_eErrorLevel, in_playingID, in_gameObjID, in_audioNodeID, in_bIsBus); }

  ///  Post a unicode monitoring message or error string. This will be displayed in the Wwise capture
  ///  log.
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_pszError"> Message or error string to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param> 
  /// <param name="in_gameObjID"> Related Game Object ID if applicable, AK_INVALID_GAME_OBJECT otherwise</param> 
  /// <param name="in_audioNodeID"> Related Audio Node ID if applicable, AK_INVALID_UNIQUE_ID otherwise</param>
  public static AKRESULT PostString(string in_pszError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID, ulong in_gameObjID, uint in_audioNodeID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostString__SWIG_1(in_pszError, (int)in_eErrorLevel, in_playingID, in_gameObjID, in_audioNodeID); }

  ///  Post a unicode monitoring message or error string. This will be displayed in the Wwise capture
  ///  log.
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_pszError"> Message or error string to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param> 
  /// <param name="in_gameObjID"> Related Game Object ID if applicable, AK_INVALID_GAME_OBJECT otherwise</param>
  public static AKRESULT PostString(string in_pszError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID, ulong in_gameObjID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostString__SWIG_2(in_pszError, (int)in_eErrorLevel, in_playingID, in_gameObjID); }

  ///  Post a unicode monitoring message or error string. This will be displayed in the Wwise capture
  ///  log.
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_pszError"> Message or error string to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param> 
  /// <param name="in_playingID"> Related Playing ID if applicable</param>
  public static AKRESULT PostString(string in_pszError, AkMonitorErrorLevel in_eErrorLevel, uint in_playingID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostString__SWIG_3(in_pszError, (int)in_eErrorLevel, in_playingID); }

  ///  Post a unicode monitoring message or error string. This will be displayed in the Wwise capture
  ///  log.
  /// <returns>AK_Success if successful, AK_Fail if there was a problem posting the message.
  ///     			In optimized mode, this function returns AK_NotCompatible.</returns> 
  /// <remarks>This function is provided as a tracking tool only. It does nothing if it is			called in the optimized/release configuration and return AK_NotCompatible.</remarks>
  /// <param name="in_pszError"> Message or error string to be displayed</param> 
  /// <param name="in_eErrorLevel"> Specifies whether it should be displayed as a message or an error</param>
  public static AKRESULT PostString(string in_pszError, AkMonitorErrorLevel in_eErrorLevel) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_PostString__SWIG_4(in_pszError, (int)in_eErrorLevel); }

  ///  Reset the wwiseErrorHandler to only using the default translator
  /// <returns>AK_Success.
  ///     	In optimized/release configuration, this function returns AK_NotCompatible.</returns>
  public static AKRESULT ResetTranslator() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetTranslator(); }

  ///  Get the time stamp shown in the capture log along with monitoring messages.
  /// <returns>Time stamp in milliseconds.
  ///     			In optimized/release configuration, this function returns 0.</returns>
  public static int GetTimeStamp() { return AkUnitySoundEnginePINVOKE.CSharp_GetTimeStamp(); }

  ///  Add the streaming manager settings to the profiler capture.
  public static void MonitorStreamMgrInit(AkStreamMgrSettings in_streamMgrSettings) { AkUnitySoundEnginePINVOKE.CSharp_MonitorStreamMgrInit(AkStreamMgrSettings.getCPtr(in_streamMgrSettings)); }

  ///  Add device settings to the list of active streaming devices.
  ///  The list of streaming devices and their settings will be
  ///  sent to the profiler capture when remote connecting from Wwise.
  ///
  /// <remarks>``AK::Monitor::MonitorStreamMgrTerm`` must be called to			clean-up memory	used to keep track of active streaming devices.</remarks>
  public static void MonitorStreamingDeviceInit(uint in_deviceID, AkDeviceSettings in_deviceSettings) { AkUnitySoundEnginePINVOKE.CSharp_MonitorStreamingDeviceInit(in_deviceID, AkDeviceSettings.getCPtr(in_deviceSettings)); }

  /// Remove streaming device entry from the list of devices
  /// to send when remote connecting from Wwise.
  public static void MonitorStreamingDeviceDestroyed(uint in_deviceID) { AkUnitySoundEnginePINVOKE.CSharp_MonitorStreamingDeviceDestroyed(in_deviceID); }

  ///  Monitor streaming manager destruction as part of the
  ///  profiler capture.
  ///
  /// <remarks>This function must be called to clean-up memory	used by			``AK::Monitor::MonitorStreamingDeviceInit`` and ``AK::Monitor::MonitorStreamingDeviceTerm`` 		to keep track of active streaming devices.</remarks>
  public static void MonitorStreamMgrTerm() { AkUnitySoundEnginePINVOKE.CSharp_MonitorStreamMgrTerm(); }

  ///  Platform Independent Helper for memcpy/memmove/memset
  public static void AkMemCpy(global::System.IntPtr pDest, global::System.IntPtr pSrc, uint uSize) { AkUnitySoundEnginePINVOKE.CSharp_AkMemCpy(pDest, pSrc, uSize); }

  public static void AkMemMove(global::System.IntPtr pDest, global::System.IntPtr pSrc, uint uSize) { AkUnitySoundEnginePINVOKE.CSharp_AkMemMove(pDest, pSrc, uSize); }

  public static void AkMemSet(global::System.IntPtr pDest, int iVal, uint uSize) { AkUnitySoundEnginePINVOKE.CSharp_AkMemSet(pDest, iVal, uSize); }

  ///  Platform-dependent helpers
  public static void AkGetDefaultHighPriorityThreadProperties(AkThreadProperties out_threadProperties) { AkUnitySoundEnginePINVOKE.CSharp_AkGetDefaultHighPriorityThreadProperties(AkThreadProperties.getCPtr(out_threadProperties)); }

  public static void AkForceCrash() { AkUnitySoundEnginePINVOKE.CSharp_AkForceCrash(); }

  ///  Resolve a dialogue event into an audio node ID based on the specified argument path.
  /// <returns>Unique ID of audio node, or AK_INVALID_UNIQUE_ID if no audio node is defined for specified argument path</returns> 
  /// <param name="in_eventID"> Unique ID of dialogue event</param> 
  /// <param name="in_aArgumentValues"> Argument path, as array of argument value IDs. AK_FALLBACK_ARGUMENTVALUE_ID indicates a fallback argument value</param> 
  /// <param name="in_uNumArguments"> Number of argument value IDs in in_aArgumentValues</param> 
  /// <param name="in_idSequence"> Optional sequence ID in which the token will be inserted (for profiling purposes)</param>
  public static uint ResolveDialogueEvent(uint in_eventID, uint[] in_aArgumentValues, uint in_uNumArguments, uint in_idSequence) { return AkUnitySoundEnginePINVOKE.CSharp_ResolveDialogueEvent__SWIG_0(in_eventID, in_aArgumentValues, in_uNumArguments, in_idSequence); }

  ///  Resolve a dialogue event into an audio node ID based on the specified argument path.
  /// <returns>Unique ID of audio node, or AK_INVALID_UNIQUE_ID if no audio node is defined for specified argument path</returns> 
  /// <param name="in_eventID"> Unique ID of dialogue event</param> 
  /// <param name="in_aArgumentValues"> Argument path, as array of argument value IDs. AK_FALLBACK_ARGUMENTVALUE_ID indicates a fallback argument value</param> 
  /// <param name="in_uNumArguments"> Number of argument value IDs in in_aArgumentValues</param>
  public static uint ResolveDialogueEvent(uint in_eventID, uint[] in_aArgumentValues, uint in_uNumArguments) { return AkUnitySoundEnginePINVOKE.CSharp_ResolveDialogueEvent__SWIG_1(in_eventID, in_aArgumentValues, in_uNumArguments); }

  ///  Get the value of a custom property of integer or boolean type.
  /// <returns>
  ///      - AK_Success if the value is found			
  ///      - AK_PartialSuccess if the event was found but no matching custom property was found on this object. Note that it could mean this value is the default value.
  ///      - AK_IDNotFound if the EventID is unknown (not loaded or typo in the id)</returns> 
  /// <param name="in_eventID"> Unique ID of dialogue event</param> 
  /// <param name="in_uPropID"> Property ID of your custom property found under the Custom Properties tab of the Wwise project settings.</param> 
  /// <param name="out_iValue"> Property Value</param>
  public static AKRESULT GetDialogueEventCustomPropertyValue(uint in_eventID, uint in_uPropID, out int out_iValue) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetDialogueEventCustomPropertyValue__SWIG_0(in_eventID, in_uPropID, out out_iValue); }

  ///  Get the value of a custom property of real type.
  /// <returns>
  ///      - AK_Success if the value is found			
  ///      - AK_PartialSuccess if the event was found but no matching custom property was found on this object. Note that it could mean this value is the default value.
  ///      - AK_IDNotFound if the EventID is unknown (not loaded or typo in the id)</returns> 
  /// <param name="in_eventID"> Unique ID of dialogue event</param> 
  /// <param name="in_uPropID"> Property ID of your custom property found under the Custom Properties tab of the Wwise project settings.</param> 
  /// <param name="out_fValue"> Property Value</param>
  public static AKRESULT GetDialogueEventCustomPropertyValue(uint in_eventID, uint in_uPropID, out float out_fValue) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetDialogueEventCustomPropertyValue__SWIG_1(in_eventID, in_uPropID, out out_fValue); }

  ///  Get the position of a game object.
  /// <returns>AK_Success if succeeded, or AK_IDNotFound if the game object was not registered</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_3dpositions"/>
  /// <param name="in_GameObjectID"> Game object identifier</param> 
  /// <param name="out_rPosition"> Position to get</param>
  public static AKRESULT GetPosition(ulong in_GameObjectID, AkWorldTransform out_rPosition) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPosition(in_GameObjectID, AkWorldTransform.getCPtr(out_rPosition)); }

  ///  Get a listener's position.
  /// <returns>AK_Success if succeeded, or AK_InvalidParameter if the index is out of range</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_listeners_settingpos"/>
  /// <param name="in_uListenerID"> Listener game object ID.</param> 
  /// <param name="out_rPosition"> Position set</param>
  public static AKRESULT GetListenerPosition(ulong in_uListenerID, AkWorldTransform out_rPosition) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetListenerPosition(in_uListenerID, AkWorldTransform.getCPtr(out_rPosition)); }

  ///  Get the value of a real-time parameter control (by ID)
  ///  An RTPC can have a any combination of a global value, a unique value for each game object, or a unique value for each playing ID (Event).
  ///  The value requested is determined by RTPCValue_type, in_gameObjectID and in_playingID.
  ///  If a value at the requested scope (determined by RTPCValue_type) is not found, the value that is available at the the next broadest scope will be returned, and io_rValueType will be changed to indicate this.
  /// 		When looking up RTPC values via playing ID (ie. io_rValueType is RTPC_PlayingID), in_gameObjectID can be set to a specific game object (if it is available to the caller) to use as a fall back value.
  /// 		If the game object is unknown or unavailable, AK_INVALID_GAME_OBJECT can be passed in in_gameObjectID, and the game object will be looked up via in_playingID.
  /// 		However in this case, it is not possible to retrieve a game object value as a fall back value if the playing id does not exist.  It is best to pass in the game object if possible.
  /// 		Contrary to most AK::Query functions, GetRTPCValue does not block. This means that GetRTPCValue does not wait for all previous API to be completed (which may take several milliseconds),
  /// 		and instead returns the current value. Therefore calling SetRTPCValue, RenderAudio and then GetRTPCValue might not immediately give the value set by SetRTPCValue.
  /// <returns>
  ///     	- AK_Success if succeeded
  ///      - AK_IDNotFound if the RTPC does not exist
  ///      - AK_InvalidID if the GameObject does not exist.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - RTPCValue_type"/>
  /// <param name="in_rtpcID"> ID of the RTPC</param> 
  /// <param name="in_gameObjectID"> Associated game object ID, ignored if io_rValueType is RTPCValue_Global.</param> 
  /// <param name="in_playingID"> Associated playing ID, ignored if io_rValueType is not RTPC_PlayingID.</param> 
  /// <param name="out_rValue"> Value returned</param> 
  /// <param name="io_rValueType"> In/Out value, the user must specify the requested type. The function will return in this variable the type of the returned value.</param>
  public static AKRESULT GetRTPCValue(uint in_rtpcID, ulong in_gameObjectID, uint in_playingID, out float out_rValue, ref int io_rValueType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetRTPCValue__SWIG_0(in_rtpcID, in_gameObjectID, in_playingID, out out_rValue, ref io_rValueType); }

  ///  Get the value of a real-time parameter control (by ID)
  ///  An RTPC can have a any combination of a global value, a unique value for each game object, or a unique value for each playing ID.
  ///  The value requested is determined by RTPCValue_type, in_gameObjectID and in_playingID.
  ///  If a value at the requested scope (determined by RTPCValue_type) is not found, the value that is available at the the next broadest scope will be returned, and io_rValueType will be changed to indicate this.
  /// 		When looking up RTPC values via playing ID (ie. io_rValueType is RTPC_PlayingID), in_gameObjectID can be set to a specific game object (if it is available to the caller) to use as a fall back value.
  /// 		If the game object is unknown or unavailable, AK_INVALID_GAME_OBJECT can be passed in in_gameObjectID, and the game object will be looked up via in_playingID.
  /// 		However in this case, it is not possible to retrieve a game object value as a fall back value if the playing id does not exist.  It is best to pass in the game object if possible.
  /// 		Contrary to most AK::Query functions, GetRTPCValue does not block. This means that GetRTPCValue does not wait for all previous API to be completed (which may take several milliseconds),
  /// 		and instead returns the current value. Therefore calling SetRTPCValue, RenderAudio and then GetRTPCValue might not immediately give the value set by SetRTPCValue.
  /// <returns>
  ///     	- AK_Success if succeeded
  ///      - AK_IDNotFound if the RTPC does not exist
  ///      - AK_InvalidID if the GameObject does not exist.</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_rtpc
  ///  - RTPCValue_type"/>
  /// <param name="in_pszRtpcName"> String name of the RTPC</param> 
  /// <param name="in_gameObjectID"> Associated game object ID, ignored if io_rValueType is RTPCValue_Global.</param> 
  /// <param name="in_playingID"> Associated playing ID, ignored if io_rValueType is not RTPC_PlayingID.</param> 
  /// <param name="out_rValue"> Value returned</param> 
  /// <param name="io_rValueType"> In/Out value, the user must specify the requested type. The function will return in this variable the type of the returned value.				);</param>
  public static AKRESULT GetRTPCValue(string in_pszRtpcName, ulong in_gameObjectID, uint in_playingID, out float out_rValue, ref int io_rValueType) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetRTPCValue__SWIG_1(in_pszRtpcName, in_gameObjectID, in_playingID, out out_rValue, ref io_rValueType); }

  ///  Get the current Switch value of the specified Switch Group, for a game object
  /// 		Contrary to most AK::Query functions, GetSwitch does not block. This means that GetSwitch does not wait for all previous API to be completed (which may take several milliseconds),
  /// 		and instead returns the current value. Therefore calling SetSwitch, RenderAudio and then GetSwitch might not immediately give the value set by SetSwitch.
  /// <returns>
  ///     	- AK_Success if succeeded
  ///      - AK_IDNotFound if the RTPC does not exist
  ///      - AK_InvalidID if the GameObject does not exist.</returns> 
  /// <returns>AK_Success if succeeded, or AK_IDNotFound if the game object was not registered or the Switch Group name cannot be found</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_switch
  ///  - \ref AK.SoundEngine.SetSwitch"/>
  /// <param name="in_switchGroup"> ID of the Switch Group</param> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="out_rSwitchState"> ID of the Switch</param>
  public static AKRESULT GetSwitch(uint in_switchGroup, ulong in_gameObjectID, out uint out_rSwitchState) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSwitch__SWIG_0(in_switchGroup, in_gameObjectID, out out_rSwitchState); }

  ///  Get the current Switch value of the specified Switch Group, for a game object
  /// <returns>AK_Success if succeeded, or AK_IDNotFound if the game object was not registered or the Switch Group name cannot be found</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_switch
  ///  - \ref AK.SoundEngine.SetSwitch"/>
  /// <param name="in_pstrSwitchGroupName"> String name of the Switch Group</param> 
  /// <param name="in_GameObj"> Associated game object ID</param> 
  /// <param name="out_rSwitchState"> ID of the Switch</param>
  public static AKRESULT GetSwitch(string in_pstrSwitchGroupName, ulong in_GameObj, out uint out_rSwitchState) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSwitch__SWIG_1(in_pstrSwitchGroupName, in_GameObj, out out_rSwitchState); }

  ///  Get the current State value active in the specified State Group.
  /// <returns>AK_Success if succeeded</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_states
  ///  - \ref AK.SoundEngine.SetState"/>
  /// <param name="in_stateGroup"> ID of the State Group</param> 
  /// <param name="out_rState"> ID of the state</param>
  public static AKRESULT GetState(uint in_stateGroup, out uint out_rState) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetState__SWIG_0(in_stateGroup, out out_rState); }

  ///  Get the current State value active in the specified State Group.
  /// <returns>AK_Success if succeeded</returns> 
  /// <seealso cref="
  ///  - \ref soundengine_states
  ///  - \ref AK.SoundEngine.SetState"/>
  /// <param name="in_pstrStateGroupName"> String name of the State Group</param> 
  /// <param name="out_rState"> ID of the State</param>
  public static AKRESULT GetState(string in_pstrStateGroupName, out uint out_rState) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetState__SWIG_1(in_pstrStateGroupName, out out_rState); }

  ///  Get the environmental ratios used by the specified game object.
  /// <seealso cref="
  ///  - \ref soundengine_environments
  ///  - \ref soundengine_environments_dynamic_aux_bus_routing
  ///  - \ref soundengine_environments_id_vs_string"/>
  /// <returns>AK_Success if succeeded, or AK_InvalidParameter if io_ruNumSendValues is 0 or out_paEnvironmentValues is NULL, or AK_PartialSuccess if more environments exist than io_ruNumSendValues</returns> 
  /// <param name="in_gameObjectID"> Associated game object ID</param> 
  /// <param name="out_paAuxSendValues"> Variable-size array of AkAuxSendValue structures
  ///      (it may be NULL if no aux send must be set)</param> 
  /// <param name="io_ruNumSendValues"> The number of Auxiliary busses at the pointer's address
  ///      (it must be 0 if no aux bus is set)</param>
  public static AKRESULT GetGameObjectAuxSendValues(ulong in_gameObjectID, AkAuxSendArray out_paAuxSendValues, ref uint io_ruNumSendValues) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetGameObjectAuxSendValues(in_gameObjectID, out_paAuxSendValues.GetBuffer(), ref io_ruNumSendValues); }

  ///  Get the environmental dry level to be used for the specified game object
  ///  The control value is a number ranging from 0.0f to 1.0f.
  ///  0.0f stands for 0% dry, while 1.0f stands for 100% dry.
  ///  Reducing the dry level does not mean increasing the wet level.
  /// <seealso cref="
  ///  - \ref soundengine_environments
  ///  - \ref soundengine_environments_setting_dry_environment
  ///  - \ref soundengine_environments_id_vs_string"/>
  /// <returns>AK_Success if succeeded, or AK_IDNotFound if the game object was not registered</returns> 
  /// <param name="in_EmitterID"> Associated emitter game object ID</param> 
  /// <param name="in_ListenerID"> Associated listener game object ID</param> 
  /// <param name="out_rfControlValue"> Dry level control value, ranging from 0.0f to 1.0f
  ///      (0.0f stands for 0% dry, while 1.0f stands for 100% dry)</param>
  public static AKRESULT GetGameObjectDryLevelValue(ulong in_EmitterID, ulong in_ListenerID, out float out_rfControlValue) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetGameObjectDryLevelValue(in_EmitterID, in_ListenerID, out out_rfControlValue); }

  ///  Get a game object's obstruction and occlusion levels.
  /// <seealso cref="
  ///  - \ref soundengine_obsocc
  ///  - \ref soundengine_environments"/>
  /// <returns>AK_Success if succeeded, AK_IDNotFound if the game object was not registered</returns> 
  /// <param name="in_EmitterID"> Associated game object ID</param> 
  /// <param name="in_ListenerID"> Listener object ID</param> 
  /// <param name="out_rfObstructionLevel"> ObstructionLevel: [0.0f..1.0f]</param> 
  /// <param name="out_rfOcclusionLevel"> OcclusionLevel: [0.0f..1.0f]</param>
  public static AKRESULT GetObjectObstructionAndOcclusion(ulong in_EmitterID, ulong in_ListenerID, out float out_rfObstructionLevel, out float out_rfOcclusionLevel) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetObjectObstructionAndOcclusion(in_EmitterID, in_ListenerID, out out_rfObstructionLevel, out out_rfOcclusionLevel); }

  ///  Get the list of audio object IDs associated to an event.
  ///  It is possible to call QueryAudioObjectIDs with io_ruNumItems = 0 to get the total size of the
  ///  structure that should be allocated for out_aObjectInfos.
  /// <returns>AK_Success if succeeded, AK_IDNotFound if the eventID cannot be found, AK_InvalidParameter if out_aObjectInfos is NULL while io_ruNumItems > 0
  ///      or AK_PartialSuccess if io_ruNumItems was set to 0 to query the number of available items.</returns> 
  /// <param name="in_eventID"> Event ID</param> 
  /// <param name="io_ruNumItems"> Number of items in array provided / Number of items filled in array</param> 
  /// <param name="out_aObjectInfos"> Array of AkObjectInfo items to fill</param>
  public static AKRESULT QueryAudioObjectIDs(uint in_eventID, ref uint io_ruNumItems, AkObjectInfoArray out_aObjectInfos) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_QueryAudioObjectIDs__SWIG_0(in_eventID, ref io_ruNumItems, out_aObjectInfos.GetBuffer()); }

  ///  Get the list of audio object IDs associated to a event name.
  ///  It is possible to call QueryAudioObjectIDs with io_ruNumItems = 0 to get the total size of the
  ///  structure that should be allocated for out_aObjectInfos.
  /// <returns>AK_Success if succeeded, AK_IDNotFound if the event name cannot be found, AK_InvalidParameter if out_aObjectInfos is NULL while io_ruNumItems > 0
  ///      or AK_PartialSuccess if io_ruNumItems was set to 0 to query the number of available items.</returns> 
  /// <param name="in_pszEventName"> Event name</param> 
  /// <param name="io_ruNumItems"> Number of items in array provided / Number of items filled in array</param> 
  /// <param name="out_aObjectInfos"> Array of AkObjectInfo items to fill</param>
  public static AKRESULT QueryAudioObjectIDs(string in_pszEventName, ref uint io_ruNumItems, AkObjectInfoArray out_aObjectInfos) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_QueryAudioObjectIDs__SWIG_1(in_pszEventName, ref io_ruNumItems, out_aObjectInfos.GetBuffer()); }

  ///  Get positioning information associated to an audio object.
  /// <returns>AK_Success if succeeded, AK_IDNotFound if the object ID cannot be found, AK_NotCompatible if the audio object cannot expose positioning</returns> 
  /// <param name="in_ObjectID"> Audio object ID</param> 
  /// <param name="out_rPositioningInfo"> Positioning information structure to be filled</param>
  public static AKRESULT GetPositioningInfo(uint in_ObjectID, AkPositioningInfo out_rPositioningInfo) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPositioningInfo(in_ObjectID, AkPositioningInfo.getCPtr(out_rPositioningInfo)); }

  ///  Query if the specified game object is currently active.
  ///  Being active means that either a sound is playing or pending to be played using this game object.
  /// <param name="in_GameObjId"> Game object ID</param>
  public static bool GetIsGameObjectActive(ulong in_GameObjId) { return AkUnitySoundEnginePINVOKE.CSharp_GetIsGameObjectActive(in_GameObjId); }

  ///  Returns the maximum distance used in attenuations associated to sounds playing using the specified game object.
  ///  This may be used for example by the game to know if some processing need to be performed on the game side, that would not be required
  ///  if the object is out of reach anyway.
  ///  The returned value is NOT the distance from a listener to an object but the maximum attenuation distance of all sounds playing on this object.
  ///
  /// <returns>
  ///      - A negative number if the game object specified is not playing.
  ///      - 0, if the game object was only associated to sounds playing using no distance attenuation.
  ///      - A positive number represents the maximum of all the distance attenuations playing on this game object.</returns> 
  ///  The Scaling factor (if one was specified on the game object) is included in the return value.
  ///  The Scaling factor is not updated once a sound starts playing since it
  ///  is computed only when the playback starts with the initial scaling factor of this game object. Scaling factor will
  ///  be re-computed for every playback instance, always using the scaling factor available at this time.
  ///
  /// <seealso cref="
  ///  - \ref AK.SoundEngine.SetScalingFactor"/>
  /// <param name="in_GameObjId"> Game object ID</param>
  public static float GetMaxRadius(ulong in_GameObjId) { return AkUnitySoundEnginePINVOKE.CSharp_GetMaxRadius(in_GameObjId); }

  ///  Get the Event ID associated to the specified PlayingID.
  ///  This function does not acquire the main audio lock.
  ///
  /// <returns>AK_INVALID_UNIQUE_ID on failure.</returns> 
  /// <param name="in_playingID"> Associated PlayingID</param>
  public static uint GetEventIDFromPlayingID(uint in_playingID) { return AkUnitySoundEnginePINVOKE.CSharp_GetEventIDFromPlayingID(in_playingID); }

  ///  Get the ObjectID associated to the specified PlayingID.
  ///  This function does not acquire the main audio lock.
  ///
  /// <returns>AK_INVALID_GAME_OBJECT on failure.</returns> 
  /// <param name="in_playingID"> Associated PlayingID</param>
  public static ulong GetGameObjectFromPlayingID(uint in_playingID) { return AkUnitySoundEnginePINVOKE.CSharp_GetGameObjectFromPlayingID(in_playingID); }

  ///  Get the list PlayingIDs associated with the given game object.
  ///  This function does not acquire the main audio lock.
  ///  It is possible to call GetPlayingIDsFromGameObject with io_ruNumItems = 0 to get the total size of the
  ///  structure that should be allocated for out_aPlayingIDs.
  /// <returns>AK_Success if succeeded, AK_InvalidParameter if out_aPlayingIDs is NULL while io_ruNumItems > 0</returns> 
  /// <param name="in_GameObjId"> Game object ID</param> 
  /// <param name="io_ruNumIDs"> Number of items in array provided / Number of items filled in array</param> 
  /// <param name="out_aPlayingIDs"> Array of AkPlayingID items to fill</param>
  public static AKRESULT GetPlayingIDsFromGameObject(ulong in_GameObjId, ref uint io_ruNumIDs, uint[] out_aPlayingIDs) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetPlayingIDsFromGameObject(in_GameObjId, ref io_ruNumIDs, out_aPlayingIDs); }

  ///  Get the value of a custom property of integer or boolean type.
  /// <returns>AK_PartialSuccess if the object was found but no matching custom property was found on this object. Note that it could mean this value is the default value.</returns> 
  /// <param name="in_ObjectID"> Object ID, this is the 32bit ShortID of the AudioFileSource or Sound object found in the .wwu XML file. At runtime it can only be retrieved by the AK_Duration callback when registered with PostEvent(), or by calling Query::QueryAudioObjectIDs() to get all the shortIDs associated with an event.</param> 
  /// <param name="in_uPropID"> Property ID of your custom property found under the Custom Properties tab of the Wwise project settings.</param> 
  /// <param name="out_iValue"> Property Value</param>
  public static AKRESULT GetCustomPropertyValue(uint in_ObjectID, uint in_uPropID, out int out_iValue) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetCustomPropertyValue__SWIG_0(in_ObjectID, in_uPropID, out out_iValue); }

  ///  Get the value of a custom property of real type.
  /// <returns>AK_PartialSuccess if the object was found but no matching custom property was found on this object. Note that it could mean this value is the default value.</returns> 
  /// <param name="in_ObjectID"> Object ID, this is the 32bit ShortID of the AudioFileSource or Sound object found in the .wwu XML file. At runtime it can only be retrieved by the AK_Duration callback when registered with PostEvent(), or by calling Query::QueryAudioObjectIDs() to get all the shortIDs associated with an event.</param> 
  /// <param name="in_uPropID"> Property ID of your custom property found under the Custom Properties tab of the Wwise project settings.</param> 
  /// <param name="out_fValue"> Property Value</param>
  public static AKRESULT GetCustomPropertyValue(uint in_ObjectID, uint in_uPropID, out float out_fValue) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetCustomPropertyValue__SWIG_1(in_ObjectID, in_uPropID, out out_fValue); }

  public static void AK_SPEAKER_SETUP_FIX_LEFT_TO_CENTER(ref uint io_uChannelMask) { AkUnitySoundEnginePINVOKE.CSharp_AK_SPEAKER_SETUP_FIX_LEFT_TO_CENTER(ref io_uChannelMask); }

  public static void AK_SPEAKER_SETUP_FIX_REAR_TO_SIDE(ref uint io_uChannelMask) { AkUnitySoundEnginePINVOKE.CSharp_AK_SPEAKER_SETUP_FIX_REAR_TO_SIDE(ref io_uChannelMask); }

  public static void AK_SPEAKER_SETUP_CONVERT_TO_SUPPORTED(ref uint io_uChannelMask) { AkUnitySoundEnginePINVOKE.CSharp_AK_SPEAKER_SETUP_CONVERT_TO_SUPPORTED(ref io_uChannelMask); }

  ///  Returns the number of channels of a given channel configuration.
  public static byte ChannelMaskToNumChannels(uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_ChannelMaskToNumChannels(in_uChannelMask); }

  /// Returns a 'best guess' channel configuration from a given number of channels.
  /// Will return 0 if no guess can be made.
  public static uint ChannelMaskFromNumChannels(uint in_uNumChannels) { return AkUnitySoundEnginePINVOKE.CSharp_ChannelMaskFromNumChannels(in_uNumChannels); }

  ///  Converts a channel bit to a channel index (in Wwise pipeline ordering - LFE at the end), given a channel mask in_uChannelMask.
  /// <returns>Channel index.</returns>
  public static byte ChannelBitToIndex(uint in_uChannelBit, uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_ChannelBitToIndex(in_uChannelBit, in_uChannelMask); }

  /// Returns true if standard configuration represented by channel mask has surround
  /// channels, either defined as side or back channels.
  public static bool HasSurroundChannels(uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_HasSurroundChannels(in_uChannelMask); }

  /// Returns true if standard configuration represented by channel mask has strictly one
  /// pair of surround channels, either defined as side or back channels. 7.1 has two pairs
  /// of surround channels and would thus return false.
  public static bool HasStrictlyOnePairOfSurroundChannels(uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_HasStrictlyOnePairOfSurroundChannels(in_uChannelMask); }

  /// Returns true if standard configuration represented by channel mask has two
  /// pair of surround channels, that is, side and back channels. 7.1 has two pairs
  /// of surround channels and would thus return true, whereas 5.1 would return false.
  public static bool HasSideAndRearChannels(uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_HasSideAndRearChannels(in_uChannelMask); }

  ///  Returns true if standard configuration represented by channel mask has at least one "height" channel (above the plane).
  public static bool HasHeightChannels(uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_HasHeightChannels(in_uChannelMask); }

  /// Takes a channel mask and swap back channels with side channels if there is just
  /// one pair of surround channels.
  public static uint BackToSideChannels(uint in_uChannelMask) { return AkUnitySoundEnginePINVOKE.CSharp_BackToSideChannels(in_uChannelMask); }

  ///  Define an inner and outer radius around each sound position for a specified game object.
  ///  If the radii are set to 0, the game object is a point source. Non-zero radii create a Radial Emitter.
  ///  The radii are used in spread and distance calculations that simulates sound emitting from a spherical volume of space.
  ///  When applying attenuation curves, the distance between the listener and the inner sphere (defined by the sound position and ``in_innerRadius)`` is used.
  ///  The spread for each sound position is calculated as follows:
  ///  - If the listener is outside the outer radius, the spread is defined by the area that the sphere occupies in the listener field of view. Specifically, this angle is calculated as 2.0*asinf( ``in_outerRadius`` / distance ), where distance is the distance between the listener and the sound position.
  /// 	- When the listener intersects the outer radius (the listener is exactly ``in_outerRadius`` units away from the sound position), the spread is exactly 50%.
  ///  - When the listener is between the inner and outer radii, the spread interpolates linearly from 50% to 100% as the listener transitions from the outer radius towards the inner radius.
  ///  - If the listener is inside the inner radius, the spread is 100%.
  ///  Transmission and diffraction calculations in Spatial Audio always use the center of the sphere (the position(s) passed into ``AK::SoundEngine::SetPosition`` or ``AK::SoundEngine::SetMultiplePositions)`` for raycasting.
  ///  To obtain accurate diffraction and transmission calculations for radial sources, where different parts of the volume may take different paths through or around geometry,
  ///  it is necessary to pass multiple sound positions into ``AK::SoundEngine::SetMultiplePositions`` to allow the engine to 'sample' the area at different points.
  ///  - \ref AK::SoundEngine::SetPosition
  ///  - \ref AK::SoundEngine::SetMultiplePositions
  /// <param name="in_gameObjectID"> Game object ID</param> 
  /// <param name="in_outerRadius"> Outer radius around each sound position, defining 50% spread. Must satisfy ``in_innerRadius`` <= ``in`` outerRadius.</param> 
  /// <param name="in_innerRadius"> Inner radius around each sound position, defining 100% spread and 0 attenuation distance. Must satisfy ``in_innerRadius`` <= ``in`` outerRadius.</param>
  public static AKRESULT SetGameObjectRadius(ulong in_gameObjectID, float in_outerRadius, float in_innerRadius) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGameObjectRadius(in_gameObjectID, in_outerRadius, in_innerRadius); }

  ///  Use this API for detailed placement of reflection image sources.
  ///  These functions are low-level and useful when your game engine already implements a geometrical approach to sound propagation such as an image-source or a ray tracing algorithm.
  ///  Functions of Geometry are preferred and easier to use with the Reflect plug-in.
  ///  Add or update an individual image source for processing via the AkReflect plug-in.  Use this API for detailed placement of
  ///  reflection image sources, whose positions have been determined by the client, such as from the results of a ray cast, computation or by manual placement.  One possible
  ///  use case is generating reflections that originate far enough away that they can be modeled as a static point source, for example, off of a distant mountain.
  ///  The SpatialAudio API manages image sources added via SetImageSource() and sends them to the AkReflect plug-in that is on the aux bus with ID ``in_AuxBusID``.
  ///  The image source applies all game objects that have a reflections aux send defined in the authoring tool, or only to a specific game object if ``in_gameObjectID`` is used.
  ///  The ``AkImageSourceSettings`` struct passed in ``in_info`` must contain a unique image source ID to be able to identify this image source across frames and when updating and/or removing it later.
  ///  Each instance of AkReflect has its own set of data, so you may reuse ID, if desired, as long as ``in_gameObjectID`` and ``in_AuxBusID`` are different.
  ///  It is possible for the AkReflect plugin to process reflections from both ``SetImageSource`` and the geometric reflections API on the same aux bus and game object, but be aware that image source ID collisions are possible.
  ///  The image source IDs used by the geometric reflections API are generated from hashed data that uniquely identifies the reflecting surfaces. If a collision occurs, one of the reflections will not be heard.
  ///  While collision are rare, to ensure that it never occurs use an aux bus for ``SetImageSource`` that is unique from the aux bus(es) defined in the authoring tool, and from those passed to ``SetEarlyReflectionsAuxSend``.
  ///
  ///  For proper operation with AkReflect and the SpatialAudio API, any aux bus using AkReflect should have 'Listener Relative Routing' checked and the 3D Spatialization set to None in the Wwise authoring tool. See \ref spatial_audio_wwiseprojectsetup_businstances for more details.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.RemoveImageSource
  /// 	- \ref AK.SpatialAudio.ClearImageSources
  ///  - \ref AK.SpatialAudio.SetGameObjectInRoom
  ///  - \ref AK.SpatialAudio.SetEarlyReflectionsAuxSend"/>
  /// <param name="in_srcID"> The ID of the image source being added.</param> 
  /// <param name="in_info"> Image source information.</param> 
  /// <param name="in_name"> Name given to image source, can be used to identify the image source in the AK Reflect plugin UI.</param> 
  /// <param name="in_AuxBusID"> Aux bus that has the AkReflect plug in for early reflection DSP.
  ///      Pass AK_INVALID_AUX_ID to use the reflections aux bus defined in the authoring tool.</param> 
  /// <param name="in_gameObjectID"> The ID of the emitter game object to which the image source applies.
  ///      Pass AK_INVALID_GAME_OBJECT to apply to all game objects that have a reflections aux bus assigned in the authoring tool.</param>
  public static AKRESULT SetImageSource(uint in_srcID, AkImageSourceSettings in_info, string in_name, uint in_AuxBusID, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetImageSource__SWIG_0(in_srcID, AkImageSourceSettings.getCPtr(in_info), in_name, in_AuxBusID, in_gameObjectID); }

  ///  Use this API for detailed placement of reflection image sources.
  ///  These functions are low-level and useful when your game engine already implements a geometrical approach to sound propagation such as an image-source or a ray tracing algorithm.
  ///  Functions of Geometry are preferred and easier to use with the Reflect plug-in.
  ///  Add or update an individual image source for processing via the AkReflect plug-in.  Use this API for detailed placement of
  ///  reflection image sources, whose positions have been determined by the client, such as from the results of a ray cast, computation or by manual placement.  One possible
  ///  use case is generating reflections that originate far enough away that they can be modeled as a static point source, for example, off of a distant mountain.
  ///  The SpatialAudio API manages image sources added via SetImageSource() and sends them to the AkReflect plug-in that is on the aux bus with ID ``in_AuxBusID``.
  ///  The image source applies all game objects that have a reflections aux send defined in the authoring tool, or only to a specific game object if ``in_gameObjectID`` is used.
  ///  The ``AkImageSourceSettings`` struct passed in ``in_info`` must contain a unique image source ID to be able to identify this image source across frames and when updating and/or removing it later.
  ///  Each instance of AkReflect has its own set of data, so you may reuse ID, if desired, as long as ``in_gameObjectID`` and ``in_AuxBusID`` are different.
  ///  It is possible for the AkReflect plugin to process reflections from both ``SetImageSource`` and the geometric reflections API on the same aux bus and game object, but be aware that image source ID collisions are possible.
  ///  The image source IDs used by the geometric reflections API are generated from hashed data that uniquely identifies the reflecting surfaces. If a collision occurs, one of the reflections will not be heard.
  ///  While collision are rare, to ensure that it never occurs use an aux bus for ``SetImageSource`` that is unique from the aux bus(es) defined in the authoring tool, and from those passed to ``SetEarlyReflectionsAuxSend``.
  ///
  ///  For proper operation with AkReflect and the SpatialAudio API, any aux bus using AkReflect should have 'Listener Relative Routing' checked and the 3D Spatialization set to None in the Wwise authoring tool. See \ref spatial_audio_wwiseprojectsetup_businstances for more details.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.RemoveImageSource
  /// 	- \ref AK.SpatialAudio.ClearImageSources
  ///  - \ref AK.SpatialAudio.SetGameObjectInRoom
  ///  - \ref AK.SpatialAudio.SetEarlyReflectionsAuxSend"/>
  /// <param name="in_srcID"> The ID of the image source being added.</param> 
  /// <param name="in_info"> Image source information.</param> 
  /// <param name="in_name"> Name given to image source, can be used to identify the image source in the AK Reflect plugin UI.</param> 
  /// <param name="in_AuxBusID"> Aux bus that has the AkReflect plug in for early reflection DSP.
  ///      Pass AK_INVALID_AUX_ID to use the reflections aux bus defined in the authoring tool.</param>
  public static AKRESULT SetImageSource(uint in_srcID, AkImageSourceSettings in_info, string in_name, uint in_AuxBusID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetImageSource__SWIG_1(in_srcID, AkImageSourceSettings.getCPtr(in_info), in_name, in_AuxBusID); }

  ///  Use this API for detailed placement of reflection image sources.
  ///  These functions are low-level and useful when your game engine already implements a geometrical approach to sound propagation such as an image-source or a ray tracing algorithm.
  ///  Functions of Geometry are preferred and easier to use with the Reflect plug-in.
  ///  Add or update an individual image source for processing via the AkReflect plug-in.  Use this API for detailed placement of
  ///  reflection image sources, whose positions have been determined by the client, such as from the results of a ray cast, computation or by manual placement.  One possible
  ///  use case is generating reflections that originate far enough away that they can be modeled as a static point source, for example, off of a distant mountain.
  ///  The SpatialAudio API manages image sources added via SetImageSource() and sends them to the AkReflect plug-in that is on the aux bus with ID ``in_AuxBusID``.
  ///  The image source applies all game objects that have a reflections aux send defined in the authoring tool, or only to a specific game object if ``in_gameObjectID`` is used.
  ///  The ``AkImageSourceSettings`` struct passed in ``in_info`` must contain a unique image source ID to be able to identify this image source across frames and when updating and/or removing it later.
  ///  Each instance of AkReflect has its own set of data, so you may reuse ID, if desired, as long as ``in_gameObjectID`` and ``in_AuxBusID`` are different.
  ///  It is possible for the AkReflect plugin to process reflections from both ``SetImageSource`` and the geometric reflections API on the same aux bus and game object, but be aware that image source ID collisions are possible.
  ///  The image source IDs used by the geometric reflections API are generated from hashed data that uniquely identifies the reflecting surfaces. If a collision occurs, one of the reflections will not be heard.
  ///  While collision are rare, to ensure that it never occurs use an aux bus for ``SetImageSource`` that is unique from the aux bus(es) defined in the authoring tool, and from those passed to ``SetEarlyReflectionsAuxSend``.
  ///
  ///  For proper operation with AkReflect and the SpatialAudio API, any aux bus using AkReflect should have 'Listener Relative Routing' checked and the 3D Spatialization set to None in the Wwise authoring tool. See \ref spatial_audio_wwiseprojectsetup_businstances for more details.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.RemoveImageSource
  /// 	- \ref AK.SpatialAudio.ClearImageSources
  ///  - \ref AK.SpatialAudio.SetGameObjectInRoom
  ///  - \ref AK.SpatialAudio.SetEarlyReflectionsAuxSend"/>
  /// <param name="in_srcID"> The ID of the image source being added.</param> 
  /// <param name="in_info"> Image source information.</param> 
  /// <param name="in_name"> Name given to image source, can be used to identify the image source in the AK Reflect plugin UI.</param>
  public static AKRESULT SetImageSource(uint in_srcID, AkImageSourceSettings in_info, string in_name) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetImageSource__SWIG_2(in_srcID, AkImageSourceSettings.getCPtr(in_info), in_name); }

  ///  Remove an individual reflection image source that was previously added via ``SetImageSource``.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetImageSource
  /// 	- \ref AK.SpatialAudio.ClearImageSources"/>
  /// <param name="in_srcID"> The ID of the image source to remove.</param> 
  /// <param name="in_AuxBusID"> Aux bus that was passed to SetImageSource.</param> 
  /// <param name="in_gameObjectID"> Game object ID that was passed to SetImageSource.</param>
  public static AKRESULT RemoveImageSource(uint in_srcID, uint in_AuxBusID, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveImageSource__SWIG_0(in_srcID, in_AuxBusID, in_gameObjectID); }

  ///  Remove an individual reflection image source that was previously added via ``SetImageSource``.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetImageSource
  /// 	- \ref AK.SpatialAudio.ClearImageSources"/>
  /// <param name="in_srcID"> The ID of the image source to remove.</param> 
  /// <param name="in_AuxBusID"> Aux bus that was passed to SetImageSource.</param>
  public static AKRESULT RemoveImageSource(uint in_srcID, uint in_AuxBusID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveImageSource__SWIG_1(in_srcID, in_AuxBusID); }

  ///  Remove an individual reflection image source that was previously added via ``SetImageSource``.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetImageSource
  /// 	- \ref AK.SpatialAudio.ClearImageSources"/>
  /// <param name="in_srcID"> The ID of the image source to remove.</param>
  public static AKRESULT RemoveImageSource(uint in_srcID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveImageSource__SWIG_2(in_srcID); }

  ///  Remove all image sources matching ``in_AuxBusID`` and ``in_gameObjectID`` that were previously added via ``SetImageSource``.
  ///  Both ``in_AuxBusID`` and ``in_gameObjectID`` can be treated as wild cards matching all aux buses and/or all game object, by passing ``AK_INVALID_AUX_ID`` and/or ``AK_INVALID_GAME_OBJECT``, respectively.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetImageSource
  ///  - \ref AK.SpatialAudio.RemoveImageSource"/>
  /// <param name="in_AuxBusID"> Aux bus that was passed to SetImageSource, or AK_INVALID_AUX_ID to match all aux buses.</param> 
  /// <param name="in_gameObjectID"> Game object ID that was passed to SetImageSource, or AK_INVALID_GAME_OBJECT to match all game objects.</param>
  public static AKRESULT ClearImageSources(uint in_AuxBusID, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ClearImageSources__SWIG_0(in_AuxBusID, in_gameObjectID); }

  ///  Remove all image sources matching ``in_AuxBusID`` and ``in_gameObjectID`` that were previously added via ``SetImageSource``.
  ///  Both ``in_AuxBusID`` and ``in_gameObjectID`` can be treated as wild cards matching all aux buses and/or all game object, by passing ``AK_INVALID_AUX_ID`` and/or ``AK_INVALID_GAME_OBJECT``, respectively.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetImageSource
  ///  - \ref AK.SpatialAudio.RemoveImageSource"/>
  /// <param name="in_AuxBusID"> Aux bus that was passed to SetImageSource, or AK_INVALID_AUX_ID to match all aux buses.</param>
  public static AKRESULT ClearImageSources(uint in_AuxBusID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ClearImageSources__SWIG_1(in_AuxBusID); }

  ///  Remove all image sources matching ``in_AuxBusID`` and ``in_gameObjectID`` that were previously added via ``SetImageSource``.
  ///  Both ``in_AuxBusID`` and ``in_gameObjectID`` can be treated as wild cards matching all aux buses and/or all game object, by passing ``AK_INVALID_AUX_ID`` and/or ``AK_INVALID_GAME_OBJECT``, respectively.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetImageSource
  ///  - \ref AK.SpatialAudio.RemoveImageSource"/>
  public static AKRESULT ClearImageSources() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ClearImageSources__SWIG_2(); }

  ///  Remove a set of geometry to the SpatialAudio API.
  ///  Calling ``AK::SpatialAudio::RemoveGeometry`` will remove all instances of the geometry from the scene.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetGeometry"/>
  /// <param name="in_SetID"> ID of geometry set to be removed.</param>
  public static AKRESULT RemoveGeometry(ulong in_SetID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveGeometry(in_SetID); }

  ///  Remove a geometry instance from the SpatialAudio API.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetGeometryInstance"/>
  /// <param name="in_GeometryInstanceID"> ID of geometry set instance to be removed.</param>
  public static AKRESULT RemoveGeometryInstance(ulong in_GeometryInstanceID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveGeometryInstance(in_GeometryInstanceID); }

  ///  Remove a room.
  /// <seealso cref="
  ///  - \ref AkRoomID
  ///  - \ref AK.SpatialAudio.SetRoom"/>
  /// <param name="in_RoomID"> Room ID that was passed to ``SetRoom``.</param>
  public static AKRESULT RemoveRoom(ulong in_RoomID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveRoom(in_RoomID); }

  ///  Remove a portal.
  /// <seealso cref="
  ///  - \ref AkPortalID
  ///  - \ref AK.SpatialAudio.SetPortal"/>
  /// <param name="in_PortalID"> ID of portal to be removed, which was originally passed to SetPortal.</param>
  public static AKRESULT RemovePortal(ulong in_PortalID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemovePortal(in_PortalID); }

  ///  Use a Room as a Reverb Zone.
  ///  AK::SpatialAudio::SetReverbZone establishes a parent-child relationship between two Rooms and allows for sound propagation between them
  ///  as if they were the same Room, without the need for a connecting Portal. Setting a Room as a Reverb Zone
  ///  is useful in situations where two or more acoustic environments are not easily modeled as closed rooms connected by portals.
  ///  Possible uses for Reverb Zones include: a covered area with no walls, a forested area within an outdoor space, or any situation
  ///  where multiple reverb effects are desired within a common space. Reverb Zones have many advantages compared to standard Game-Defined
  ///  Auxiliary Sends. They are part of the wet path, and form reverb chains with other Rooms; they are spatialized according to their 3D extent;
  ///  they are also subject to other acoustic phenomena simulated in Wwise Spatial Audio, such as diffraction and transmission.
  ///  A parent Room may have multiple Reverb Zones, but a Reverb Zone can only have a single Parent. If a Room is already assigned
  ///  to a parent Room, it will first be removed from the old parent (exactly as if AK::SpatialAudio::RemoveReverbZone were called)
  ///  before then being assigned to the new parent Room. A Room can not be its own parent.
  ///  The Reverb Zone and its parent are both Rooms, and as such, must be specified using AK::SpatialAudio::SetRoom.
  ///  If AK::SpatialAudio::SetReverbZone is called before AK::SpatialAudio::SetRoom, and either of the two rooms do not yet exist,
  ///  placeholder Rooms with default parameters are created. They should be subsequently parameteized with AK::SpatialAudio::SetRoom.
  ///  To set which Reverb Zone a Game Object is in, use the AK::SpatialAudio::SetGameObjectInRoom API, and pass the Reverb Zone's Room ID.
  ///  In Wwise Spatial Audio, a Game Object can only ever be inside a single room, and Reverb Zones are no different in this regard.
  ///
  ///  The automatically created 'outdoors' Room is commonly used as a parent Room for Reverb Zones, since they often model open spaces.
  ///  To attach a Reverb zone to outdoors, pass AK::SpatialAudio::kOutdoorRoomID as the ``in_ParentRoom`` argument. Like all Rooms, the 'outdoors' Room
  ///  can be parameterized (for example, to assign a reverb bus) by passing AK::SpatialAudio::kOutdoorRoomID to AK::SpatialAudio::SetRoom.
  /// <seealso cref="
  ///  - \ref AkRoomID
  /// 	- \ref AK.SpatialAudio.SetRoom
  /// 	- \ref AK.SpatialAudio.RemoveRoom
  /// 	- \ref AK.SpatialAudio.RemoveReverbZone
  ///  - \ref AK.SpatialAudio.kOutdoorRoomID"/>
  /// <param name="in_ReverbZone"> ID of the Room which will be specified as a Reverb Zone.</param> 
  /// <param name="in_ParentRoom"> ID of the parent Room.</param> 
  /// <param name="in_transitionRegionWidth"> Width of the transition region between the Reverb Zone and its parent. The transition region is centered around the Reverb Zone geometry. It only applies where triangle transmission loss is set to 0.</param>
  public static AKRESULT SetReverbZone(ulong in_ReverbZone, ulong in_ParentRoom, float in_transitionRegionWidth) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetReverbZone(in_ReverbZone, in_ParentRoom, in_transitionRegionWidth); }

  ///  Remove a Reverb Zone from its parent.
  ///  It will no longer be possible for sound to propagate between the two rooms, unless they are explicitly connected with a Portal.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetReverbZone
  /// 	- \ref AK.SpatialAudio.RemoveRoom
  /// 	- \ref AK.SpatialAudio.RemoveReverbZone"/>
  /// <param name="in_ReverbZone"> ID of the Room which has been specified as a Reverb Zone.</param>
  public static AKRESULT RemoveReverbZone(ulong in_ReverbZone) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RemoveReverbZone(in_ReverbZone); }

  ///  Set the room that the game object is currently located in - usually the result of a containment test performed by the client. The room must have been registered with ``SetRoom``.
  /// 	Setting the room for a game object provides the basis for the sound propagation service, and also sets which room's reverb aux bus to send to.  The sound propagation service traces the path
  ///  of the sound from the emitter to the listener, and calculates the diffraction as the sound passes through each portal.  The portals are used to define the spatial location of the diffracted and reverberated
  ///  audio.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetRoom
  /// 	- \ref AK.SpatialAudio.RemoveRoom"/>
  /// <param name="in_gameObjectID"> Game object ID</param> 
  /// <param name="in_CurrentRoomID"> RoomID that was passed to ``AK::SpatialAudio::SetRoom``</param>
  public static AKRESULT SetGameObjectInRoom(ulong in_gameObjectID, ulong in_CurrentRoomID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGameObjectInRoom(in_gameObjectID, in_CurrentRoomID); }

  ///  Unset the room that the game object is currently located in.
  /// 	When a game object has not been explicitly assigned to a room with \ref AK::SpatialAudio::SetGameObjectInRoom, the room is automatically computed.
  /// <seealso cref="
  /// 	- \ref AK.SpatialAudio.SetRoom
  /// 	- \ref AK.SpatialAudio.RemoveRoom"/>
  /// <param name="in_gameObjectID"> Game object ID</param>
  public static AKRESULT UnsetGameObjectInRoom(ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnsetGameObjectInRoom(in_gameObjectID); }

  /// Set a global scaling factor that manipulates reverb send values. AK::SpatialAudio::SetAdjacentRoomBleed affects the proportion of audio sent to adjacent rooms
  /// versus the proportion sent to the emitter's current room. It updates the initialization setting specified in AkSpatialAudioInitSettings::fAdjacentRoomBleed.
  /// This value is multiplied by AkPortalParams::AdjacentRoomBleed, which is used to scale reverb bleed for individual portals.
  /// When calculating reverb send amounts, each portal's aperture is multiplied by fAdjacentRoomBleed, altering its perceived size:
  /// - 1.0 (default): Maintain portals at its true geometric size (no scaling).
  /// - &gt; 1.0: Increases the perceived size of all portals, allowing more bleed into adjacent rooms.
  /// - &lt; 1.0: Decreases the perceived size of all portals, reducing bleed into adjacent rooms.
  /// Valid range: (0.0 - infinity)
  /// Note: Values approaching 0 may result in abrupt portal transitions.
  public static AKRESULT SetAdjacentRoomBleed(float in_fAdjacentRoomBleed) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetAdjacentRoomBleed(in_fAdjacentRoomBleed); }

  ///  Set the early reflections order for reflection calculation. The reflections order indicates the number of times sound can bounce off of a surface.
  ///  A higher number requires more CPU resources but results in denser early reflections. Set to 0 to globally disable reflections processing.
  /// <param name="in_uReflectionsOrder"> Number of reflections to calculate. Valid range [0,4]</param> 
  /// <param name="in_bUpdatePaths"> Set to true to clear existing higher-order paths and to force the re-computation of new paths. If false, existing paths will remain and new paths will be computed when the emitter or listener moves.</param>
  public static AKRESULT SetReflectionsOrder(uint in_uReflectionsOrder, bool in_bUpdatePaths) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetReflectionsOrder(in_uReflectionsOrder, in_bUpdatePaths); }

  ///  Set the diffraction order for geometric path calculation. The diffraction order indicates the number of edges a sound can diffract around.
  ///  A higher number requires more CPU resources but results in paths found around more complex geometry. Set to 0 to globally disable geometric diffraction processing.
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings.uMaxDiffractionOrder"/>
  /// <param name="in_uDiffractionOrder"> Number of diffraction edges to consider in path calculations. Valid range [0,8]</param> 
  /// <param name="in_bUpdatePaths"> Set to true to clear existing diffraction paths and to force the re-computation of new paths. If false, existing paths will remain and new paths will be computed when the emitter or listener moves.</param>
  public static AKRESULT SetDiffractionOrder(uint in_uDiffractionOrder, bool in_bUpdatePaths) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetDiffractionOrder(in_uDiffractionOrder, in_bUpdatePaths); }

  ///  Set the maximum number of computed reflection paths
  ///
  /// <param name="in_uMaxGlobalReflectionPaths"> Maximum number of reflection paths. Valid range [0..[</param>
  public static AKRESULT SetMaxGlobalReflectionPaths(uint in_uMaxGlobalReflectionPaths) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMaxGlobalReflectionPaths(in_uMaxGlobalReflectionPaths); }

  ///  Set the maximum number of computed diffraction paths.
  ///  Pass a valid Game Object ID to to ``in_gameObjectID`` to affect a specific game object and override the value set in AkSpatialAudioInitSettings::uMaxDiffractionPaths.
  ///  Pass ``AK_INVALID_GAME_OBJECT`` to apply the same limit to all Game Objects (that have not previously been passed to SetMaxDiffractionPaths),
  ///  updating the value set for AkSpatialAudioInitSettings::uMaxDiffractionPaths.
  ///
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings.uMaxDiffractionPaths"/>
  /// <param name="in_uMaxDiffractionPaths"> Maximum number of reflection paths. Valid range [0..32]</param> 
  /// <param name="in_gameObjectID"> Game Object ID. Pass AK_INVALID_GAME_OBJECT to affect all Game Objects, effectivly updating AkSpatialAudioInitSettings::uMaxDiffractionPaths. Pass a valid Game Object ID to override the init setting for a specific Game Object.</param>
  public static AKRESULT SetMaxDiffractionPaths(uint in_uMaxDiffractionPaths, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMaxDiffractionPaths__SWIG_0(in_uMaxDiffractionPaths, in_gameObjectID); }

  ///  Set the maximum number of computed diffraction paths.
  ///  Pass a valid Game Object ID to to ``in_gameObjectID`` to affect a specific game object and override the value set in AkSpatialAudioInitSettings::uMaxDiffractionPaths.
  ///  Pass ``AK_INVALID_GAME_OBJECT`` to apply the same limit to all Game Objects (that have not previously been passed to SetMaxDiffractionPaths),
  ///  updating the value set for AkSpatialAudioInitSettings::uMaxDiffractionPaths.
  ///
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings.uMaxDiffractionPaths"/>
  /// <param name="in_uMaxDiffractionPaths"> Maximum number of reflection paths. Valid range [0..32]</param>
  public static AKRESULT SetMaxDiffractionPaths(uint in_uMaxDiffractionPaths) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMaxDiffractionPaths__SWIG_1(in_uMaxDiffractionPaths); }

  ///  Set the maximum number of game-defined auxiliary sends that can originate from a single emitter.
  ///  Set to 1 to only allow emitters to send directly to their current room. Set to 0 to disable the limit.
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings.uMaxEmitterRoomAuxSends"/>
  /// <param name="in_uMaxEmitterRoomAuxSends"> The maximum number of room aux send connections.</param>
  public static AKRESULT SetMaxEmitterRoomAuxSends(uint in_uMaxEmitterRoomAuxSends) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetMaxEmitterRoomAuxSends(in_uMaxEmitterRoomAuxSends); }

  ///  Set the number of rays cast from the listener by the stochastic ray casting engine.
  ///  A higher number requires more CPU resources but provides more accurate results. Default value (35) should be good for most applications.
  ///
  /// <param name="in_uNbPrimaryRays"> Number of rays cast from the listener</param>
  public static AKRESULT SetNumberOfPrimaryRays(uint in_uNbPrimaryRays) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetNumberOfPrimaryRays(in_uNbPrimaryRays); }

  ///  Set the number of frames on which the path validation phase will be spread. Value between [1..[
  ///  High values delay the validation of paths. A value of 1 indicates no spread at all.
  ///
  /// <param name="in_uNbFrames"> Number of spread frames</param>
  public static AKRESULT SetLoadBalancingSpread(uint in_uNbFrames) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetLoadBalancingSpread(in_uNbFrames); }

  ///  [\ref Experimental]  Enable parameter smoothing on the diffraction paths output from the Acoustics Engine, either globally or for a specific game object. Set fSmoothingConstantMs to a value greater than 0 to define the time constant (in milliseconds) for parameter smoothing.
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings.fSmoothingConstantMs"/>
  /// <param name="in_fSmoothingConstantMs"> Smoothing constant (ms)</param> 
  /// <param name="in_gameObjectID"> Game Object ID. Pass AK_INVALID_GAME_OBJECT to set the global smoothing constant, affecting all Spatial Audio Emitters and Rooms.</param>
  public static AKRESULT SetSmoothingConstant(float in_fSmoothingConstantMs, ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSmoothingConstant__SWIG_0(in_fSmoothingConstantMs, in_gameObjectID); }

  ///  [\ref Experimental]  Enable parameter smoothing on the diffraction paths output from the Acoustics Engine, either globally or for a specific game object. Set fSmoothingConstantMs to a value greater than 0 to define the time constant (in milliseconds) for parameter smoothing.
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings.fSmoothingConstantMs"/>
  /// <param name="in_fSmoothingConstantMs"> Smoothing constant (ms)</param>
  public static AKRESULT SetSmoothingConstant(float in_fSmoothingConstantMs) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetSmoothingConstant__SWIG_1(in_fSmoothingConstantMs); }

  ///  Set an early reflections auxiliary bus for a particular game object.
  ///  Geometrical reflection calculation inside spatial audio is enabled for a game object if any sound playing on the game object has a valid early reflections aux bus specified in the authoring tool,
  ///  or if an aux bus is specified via ``SetEarlyReflectionsAuxSend``.
  ///  The ``in_auxBusID`` parameter of SetEarlyReflectionsAuxSend applies to sounds playing on the game object ``in_gameObjectID`` which have not specified an early reflection bus in the authoring tool -
  ///  the parameter specified on individual sounds' reflection bus takes priority over the value passed in to ``SetEarlyReflectionsAuxSend``.
  ///
  ///  Users may apply this function to avoid duplicating sounds in the Containers hierarchy solely for the sake of specifying a unique early reflection bus, or in any situation where the same
  ///  sound should be played on different game objects with different early reflection aux buses (the early reflection bus must be left blank in the authoring tool if the user intends to specify it through the API).
  /// <param name="in_gameObjectID"> Game object ID</param> 
  /// <param name="in_auxBusID"> Auxiliary bus ID. Applies only to sounds which have not specified an early reflection bus in the authoring tool. Pass ``AK_INVALID_AUX_ID`` to set only the send volume.</param>
  public static AKRESULT SetEarlyReflectionsAuxSend(ulong in_gameObjectID, uint in_auxBusID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetEarlyReflectionsAuxSend(in_gameObjectID, in_auxBusID); }

  ///  Set an early reflections send volume for a particular game object.
  ///  The ``in_fSendVolume`` parameter is used to control the volume of the early reflections send. It is combined with the early reflections volume specified in the authoring tool, and is applied to all sounds
  ///  playing on the game object.
  ///  Setting ``in_fSendVolume`` to 0.f will disable all reflection processing for this game object.
  /// <param name="in_gameObjectID"> Game object ID</param> 
  /// <param name="in_fSendVolume"> Send volume (linear) for auxiliary send. Set 0.f to disable reflection processing. Valid range 0.f-1.f.</param>
  public static AKRESULT SetEarlyReflectionsVolume(ulong in_gameObjectID, float in_fSendVolume) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetEarlyReflectionsVolume(in_gameObjectID, in_fSendVolume); }

  ///  Set the obstruction and occlusion value for a portal that has been registered with Spatial Audio.
  ///  Portal obstruction simulates objects that block the direct sound path between the portal and the listener, but
  ///  allows indirect sound to pass around the obstacle. For example, use portal obstruction
  ///  when a piece of furniture blocks the line of sight of the portal opening.
  ///  Portal obstruction is applied to the connection between the emitter and the listener, and only affects the dry signal path.
  ///  Portal occlusion simulates a complete blockage of both the direct and indirect sound through a portal. For example, use portal occlusion for
  ///  opening or closing a door or window.
  ///  Portal occlusion is applied to the connection between the emitter and the first room in the chain, as well as the connection between the emitter and listener.
  ///  Portal occlusion affects both the dry and wet (reverberant) signal paths.
  ///  If you are using built-in game parameters to drive RTPCs, the obstruction and occlusion values set here
  ///  do not affect the RTPC values. This behavior is intentional and occurs because RTPCs only provide one
  ///  value per game object, but a single game object can have multiple paths through different Portals,
  ///  each with different obstruction and occlusion values.
  ///  To apply detailed obstruction to specific sound paths but not others, use ``AK::SpatialAudio::SetGameObjectToPortalObstruction`` and ``AK::SpatialAudio::SetPortalToPortalObstruction``.
  ///  To apply occlusion and obstruction to the direct line of sight between the emitter and listener use ``AK::SoundEngine::SetObjectObstructionAndOcclusion``.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.SetGameObjectToPortalObstruction
  ///  - \ref AK.SpatialAudio.SetPortalToPortalObstruction
  ///  - \ref AK.SoundEngine.SetObjectObstructionAndOcclusion"/>
  /// <param name="in_PortalID"> Portal ID.</param> 
  /// <param name="in_fObstruction"> Obstruction value.  Valid range 0.f-1.f</param> 
  /// <param name="in_fOcclusion"> Occlusion value.  Valid range 0.f-1.f</param> 
  /// <param name="in_bTransition"> Transition obstruction and occlusion through portals.  Default false</param>
  public static AKRESULT SetPortalObstructionAndOcclusion(ulong in_PortalID, float in_fObstruction, float in_fOcclusion, bool in_bTransition) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetPortalObstructionAndOcclusion__SWIG_0(in_PortalID, in_fObstruction, in_fOcclusion, in_bTransition); }

  ///  Set the obstruction and occlusion value for a portal that has been registered with Spatial Audio.
  ///  Portal obstruction simulates objects that block the direct sound path between the portal and the listener, but
  ///  allows indirect sound to pass around the obstacle. For example, use portal obstruction
  ///  when a piece of furniture blocks the line of sight of the portal opening.
  ///  Portal obstruction is applied to the connection between the emitter and the listener, and only affects the dry signal path.
  ///  Portal occlusion simulates a complete blockage of both the direct and indirect sound through a portal. For example, use portal occlusion for
  ///  opening or closing a door or window.
  ///  Portal occlusion is applied to the connection between the emitter and the first room in the chain, as well as the connection between the emitter and listener.
  ///  Portal occlusion affects both the dry and wet (reverberant) signal paths.
  ///  If you are using built-in game parameters to drive RTPCs, the obstruction and occlusion values set here
  ///  do not affect the RTPC values. This behavior is intentional and occurs because RTPCs only provide one
  ///  value per game object, but a single game object can have multiple paths through different Portals,
  ///  each with different obstruction and occlusion values.
  ///  To apply detailed obstruction to specific sound paths but not others, use ``AK::SpatialAudio::SetGameObjectToPortalObstruction`` and ``AK::SpatialAudio::SetPortalToPortalObstruction``.
  ///  To apply occlusion and obstruction to the direct line of sight between the emitter and listener use ``AK::SoundEngine::SetObjectObstructionAndOcclusion``.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.SetGameObjectToPortalObstruction
  ///  - \ref AK.SpatialAudio.SetPortalToPortalObstruction
  ///  - \ref AK.SoundEngine.SetObjectObstructionAndOcclusion"/>
  /// <param name="in_PortalID"> Portal ID.</param> 
  /// <param name="in_fObstruction"> Obstruction value.  Valid range 0.f-1.f</param> 
  /// <param name="in_fOcclusion"> Occlusion value.  Valid range 0.f-1.f</param>
  public static AKRESULT SetPortalObstructionAndOcclusion(ulong in_PortalID, float in_fObstruction, float in_fOcclusion) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetPortalObstructionAndOcclusion__SWIG_1(in_PortalID, in_fObstruction, in_fOcclusion); }

  ///  Set the obstruction value of the path between a game object and a portal that has been created by Spatial Audio.
  ///  The obstruction value is applied on one of the path segments of the sound between the emitter and the listener.
  ///  Diffraction must be enabled on the sound for a diffraction path to be created.
  ///  Also, there should not be any portals between the provided game object and portal ID parameters.
  ///  The obstruction value is used to simulate objects between the portal and the game object that are obstructing the sound.
  ///  Send an obstruction value of 0 to ensure the value is removed from the internal data structure.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.SetPortalObstructionAndOcclusion"/>
  /// <param name="in_gameObjectID"> Game object ID</param> 
  /// <param name="in_PortalID"> Portal ID</param> 
  /// <param name="in_fObstruction"> Obstruction value.  Valid range 0.f-1.f</param>
  public static AKRESULT SetGameObjectToPortalObstruction(ulong in_gameObjectID, ulong in_PortalID, float in_fObstruction) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGameObjectToPortalObstruction(in_gameObjectID, in_PortalID, in_fObstruction); }

  ///  Set the obstruction value of the path between two portals that has been created by Spatial Audio.
  ///  The obstruction value is applied on one of the path segments of the sound between the emitter and the listener.
  ///  Diffraction must be enabled on the sound for a diffraction path to be created.
  ///  Also, there should not be any portals between the two provided ID parameters.
  ///  The obstruction value is used to simulate objects between the portals that are obstructing the sound.
  ///  Send an obstruction value of 0 to ensure the value is removed from the internal data structure.
  /// <seealso cref="
  ///  - \ref AK.SpatialAudio.SetPortalObstructionAndOcclusion"/>
  /// <param name="in_PortalID0"> Portal ID</param> 
  /// <param name="in_PortalID1"> Portal ID</param> 
  /// <param name="in_fObstruction"> Obstruction value.  Valid range 0.f-1.f</param>
  public static AKRESULT SetPortalToPortalObstruction(ulong in_PortalID0, ulong in_PortalID1, float in_fObstruction) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetPortalToPortalObstruction(in_PortalID0, in_PortalID1, in_fObstruction); }

  ///  Query information about the wet diffraction amount for the portal ``in_portal``, returned as a normalized value ``out_wetDiffraction`` in the range [0,1].
  ///  The wet diffraction is calculated from how far into the 'shadow region' the listener is from the portal.  Unlike dry diffraction, the
  ///  wet diffraction does not depend on the incident angle, but only the normal of the portal.
  ///  This value is applied by spatial audio, to the Diffraction value and built-in game parameter of the room game object that is
  ///  on the other side of the portal (relative to the listener).
  ///  This function must acquire the global sound engine lock and therefore, may block waiting for the lock.
  /// <seealso cref="
  ///  - \ref AkSpatialAudioInitSettings"/>
  /// <param name="in_portal"> The ID of the game object that the client wishes to query.</param> 
  /// <param name="out_wetDiffraction"> The number of slots in ``out_aPaths``, after returning the number of valid elements written.</param>
  public static AKRESULT QueryWetDiffraction(ulong in_portal, out float out_wetDiffraction) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_QueryWetDiffraction(in_portal, out out_wetDiffraction); }

  ///  Set the operation used to calculate transmission loss on a direct path between emitter and listener.
  ///
  /// <param name="in_eOperation"> The operation to be used on all transmission paths.</param>
  public static AKRESULT SetTransmissionOperation(AkTransmissionOperation in_eOperation) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetTransmissionOperation((int)in_eOperation); }

  ///  Reset the stochastic engine state by re-initializing the random seeds.
  public static AKRESULT ResetStochasticEngine() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_ResetStochasticEngine(); }

  ///  Get the motion device ID corresponding to a GCController player index. This device ID can be used to add/remove motion output for that gamepad.
  ///  The player index is 0-based, and corresponds to a value of type GCControllerPlayerIndex in the Core.Haptics framework.
  /// The ID returned is unique to Wwise and does not correspond to any sensible value outside of Wwise.
  /// <returns>Unique device ID</returns>
  public static uint GetDeviceIDFromPlayerIndex(int playerIndex) { return AkUnitySoundEnginePINVOKE.CSharp_GetDeviceIDFromPlayerIndex(playerIndex); }

  public static void SetErrorLogger(AkLogger.ErrorLoggerInteropDelegate logger) { AkUnitySoundEnginePINVOKE.CSharp_SetErrorLogger__SWIG_0(logger); }

  public static void SetErrorLogger() { AkUnitySoundEnginePINVOKE.CSharp_SetErrorLogger__SWIG_1(); }

  public static void SetAudioInputCallbacks(AkAudioInputManager.AudioSamplesInteropDelegate getAudioSamples, AkAudioInputManager.AudioFormatInteropDelegate getAudioFormat) { AkUnitySoundEnginePINVOKE.CSharp_SetAudioInputCallbacks(getAudioSamples, getAudioFormat); }

  public static AKRESULT Init(AkInitializationSettings settings) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_Init(AkInitializationSettings.getCPtr(settings)); }

  public static AKRESULT InitSpatialAudio(AkSpatialAudioInitSettings settings) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_InitSpatialAudio(AkSpatialAudioInitSettings.getCPtr(settings)); }

  public static AKRESULT InitCommunication(AkCommunicationSettings settings) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_InitCommunication(AkCommunicationSettings.getCPtr(settings)); }

  public static void Term() { AkUnitySoundEnginePINVOKE.CSharp_Term(); }

  public static AKRESULT RegisterGameObjInternal(ulong in_GameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RegisterGameObjInternal(in_GameObj); }

  public static AKRESULT UnregisterGameObjInternal(ulong in_GameObj) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnregisterGameObjInternal(in_GameObj); }

  public static AKRESULT RegisterGameObjInternal_WithName(ulong in_GameObj, string in_pszObjName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RegisterGameObjInternal_WithName(in_GameObj, in_pszObjName); }

  public static AKRESULT SetBasePath(string in_pszBasePath) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetBasePath(in_pszBasePath); }

  public static AKRESULT SetCurrentLanguage(string in_pszAudioSrcPath) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetCurrentLanguage(in_pszAudioSrcPath); }

  public static AKRESULT LoadFilePackage(string in_pszFilePackageName, out uint out_uPackageID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadFilePackage(in_pszFilePackageName, out out_uPackageID); }

  public static AKRESULT AddBasePath(string in_pszBasePath) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddBasePath(in_pszBasePath); }

  public static AKRESULT SetGameName(string in_GameName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGameName(in_GameName); }

  public static AKRESULT SetDecodedBankPath(string in_DecodedPath) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetDecodedBankPath(in_DecodedPath); }

  public static AKRESULT LoadAndDecodeBank(string in_pszString, bool in_bSaveDecodedBank, out uint out_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadAndDecodeBank(in_pszString, in_bSaveDecodedBank, out out_bankID); }

  public static AKRESULT LoadAndDecodeBankFromMemory(global::System.IntPtr in_BankData, uint in_BankDataSize, bool in_bSaveDecodedBank, string in_DecodedBankName, bool in_bIsLanguageSpecific, out uint out_bankID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_LoadAndDecodeBankFromMemory(in_BankData, in_BankDataSize, in_bSaveDecodedBank, in_DecodedBankName, in_bIsLanguageSpecific, out out_bankID); }

  public static string GetCurrentLanguage() { return AkUnitySoundEngine.StringFromIntPtrOSString(AkUnitySoundEnginePINVOKE.CSharp_GetCurrentLanguage()); }

  public static AKRESULT UnloadFilePackage(uint in_uPackageID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadFilePackage(in_uPackageID); }

  public static AKRESULT UnloadAllFilePackages() { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnloadAllFilePackages(); }

  public static AKRESULT SetObjectPosition(ulong in_GameObjectID, UnityEngine.Vector3 Pos, UnityEngine.Vector3 Front, UnityEngine.Vector3 Top) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetObjectPosition(in_GameObjectID, Pos, Front, Top); }

  public static AKRESULT GetSourceMultiplePlayPositions(uint in_PlayingID, uint[] out_audioNodeID, uint[] out_mediaID, int[] out_msTime, ref uint io_pcPositions, bool in_bExtrapolate) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSourceMultiplePlayPositions__SWIG_0(in_PlayingID, out_audioNodeID, out_mediaID, out_msTime, ref io_pcPositions, in_bExtrapolate); }

  public static AKRESULT GetSourceMultiplePlayPositions(uint in_PlayingID, uint[] out_audioNodeID, uint[] out_mediaID, int[] out_msTime, ref uint io_pcPositions) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_GetSourceMultiplePlayPositions__SWIG_1(in_PlayingID, out_audioNodeID, out_mediaID, out_msTime, ref io_pcPositions); }

  public static AKRESULT SetListeners(ulong in_emitterGameObj, ulong[] in_pListenerGameObjs, uint in_uNumListeners) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetListeners(in_emitterGameObj, in_pListenerGameObjs, in_uNumListeners); }

  public static AKRESULT SetDefaultListeners(ulong[] in_pListenerObjs, uint in_uNumListeners) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetDefaultListeners(in_pListenerObjs, in_uNumListeners); }

  public static uint GetNumOutputDevices(uint in_AudioDeviceShareSetID) { return AkUnitySoundEnginePINVOKE.CSharp_GetNumOutputDevices(in_AudioDeviceShareSetID); }

  public static AKRESULT AddOutput(AkOutputSettings in_Settings, out ulong out_pDeviceID, ulong[] in_pListenerIDs, uint in_uNumListeners) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutput__SWIG_0(AkOutputSettings.getCPtr(in_Settings), out out_pDeviceID, in_pListenerIDs, in_uNumListeners); }

  public static AKRESULT AddOutput(AkOutputSettings in_Settings, out ulong out_pDeviceID, ulong[] in_pListenerIDs) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutput__SWIG_1(AkOutputSettings.getCPtr(in_Settings), out out_pDeviceID, in_pListenerIDs); }

  public static AKRESULT AddOutput(AkOutputSettings in_Settings, out ulong out_pDeviceID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutput__SWIG_2(AkOutputSettings.getCPtr(in_Settings), out out_pDeviceID); }

  public static AKRESULT AddOutput(AkOutputSettings in_Settings) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_AddOutput__SWIG_3(AkOutputSettings.getCPtr(in_Settings)); }

  public static void GetDefaultStreamSettings(AkStreamMgrSettings out_settings) { AkUnitySoundEnginePINVOKE.CSharp_GetDefaultStreamSettings(AkStreamMgrSettings.getCPtr(out_settings)); }

  public static void GetDefaultDeviceSettings(AkDeviceSettings out_settings) { AkUnitySoundEnginePINVOKE.CSharp_GetDefaultDeviceSettings(AkDeviceSettings.getCPtr(out_settings)); }

  public static void GetDefaultInitSettings(AkInitSettings out_settings) { AkUnitySoundEnginePINVOKE.CSharp_GetDefaultInitSettings(AkInitSettings.getCPtr(out_settings)); }

  public static void GetDefaultPlatformInitSettings(AkPlatformInitSettings out_settings) { AkUnitySoundEnginePINVOKE.CSharp_GetDefaultPlatformInitSettings(AkPlatformInitSettings.getCPtr(out_settings)); }

  public static uint GetMajorMinorVersion() { return AkUnitySoundEnginePINVOKE.CSharp_GetMajorMinorVersion(); }

  public static uint GetSubminorBuildVersion() { return AkUnitySoundEnginePINVOKE.CSharp_GetSubminorBuildVersion(); }

  public static void StartResourceMonitoring() { AkUnitySoundEnginePINVOKE.CSharp_StartResourceMonitoring(); }

  public static void StopResourceMonitoring() { AkUnitySoundEnginePINVOKE.CSharp_StopResourceMonitoring(); }

  public static void GetResourceMonitorDataSummary(AkResourceMonitorDataSummary resourceMonitorDataSummary) { AkUnitySoundEnginePINVOKE.CSharp_GetResourceMonitorDataSummary(AkResourceMonitorDataSummary.getCPtr(resourceMonitorDataSummary)); }

  public static void StartDeviceCapture(ulong in_idOutputDeviceID) { AkUnitySoundEnginePINVOKE.CSharp_StartDeviceCapture(in_idOutputDeviceID); }

  public static void StopDeviceCapture(ulong in_idOutputDeviceID) { AkUnitySoundEnginePINVOKE.CSharp_StopDeviceCapture(in_idOutputDeviceID); }

  public static void ClearCaptureData() { AkUnitySoundEnginePINVOKE.CSharp_ClearCaptureData(); }

  public static uint UpdateCaptureSampleCount(ulong in_idOutputDeviceID) { return AkUnitySoundEnginePINVOKE.CSharp_UpdateCaptureSampleCount(in_idOutputDeviceID); }

  public static uint GetCaptureSamples(ulong in_idOutputDeviceID, float[] out_pSamples, uint in_uBufferSize) { return AkUnitySoundEnginePINVOKE.CSharp_GetCaptureSamples(in_idOutputDeviceID, out_pSamples, in_uBufferSize); }

  public static AKRESULT SetRoomPortal(ulong in_PortalID, ulong FrontRoom, ulong BackRoom, AkTransform Transform, AkExtent Extent, bool bEnabled, string in_pName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRoomPortal(in_PortalID, FrontRoom, BackRoom, AkTransform.getCPtr(Transform), AkExtent.getCPtr(Extent), bEnabled, in_pName); }

  public static AKRESULT SetRoom(ulong in_RoomID, AkRoomParams in_roomParams, ulong GeometryInstanceID, string in_pName) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetRoom(in_RoomID, AkRoomParams.getCPtr(in_roomParams), GeometryInstanceID, in_pName); }

  public static AKRESULT RegisterSpatialAudioListener(ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_RegisterSpatialAudioListener(in_gameObjectID); }

  public static AKRESULT UnregisterSpatialAudioListener(ulong in_gameObjectID) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_UnregisterSpatialAudioListener(in_gameObjectID); }

  public static AKRESULT SetGeometry(ulong in_GeomSetID, AkTriangleArray Triangles, uint NumTriangles, UnityEngine.Vector3[] Vertices, uint NumVertices, AkAcousticSurfaceArray Surfaces, uint NumSurfaces, bool EnableDiffraction, bool EnableDiffractionOnBoundaryEdges) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGeometry(in_GeomSetID, Triangles.GetBuffer(), NumTriangles, Vertices, NumVertices, Surfaces.GetBuffer(), NumSurfaces, EnableDiffraction, EnableDiffractionOnBoundaryEdges); }

  public static AKRESULT SetGeometryInstance(ulong in_GeomInstanceID, AkTransform Transform, UnityEngine.Vector3 Scale, ulong GeometrySetID, bool UseForReflectionAndDiffraction, bool Solid) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_SetGeometryInstance(in_GeomInstanceID, AkTransform.getCPtr(Transform), Scale, GeometrySetID, UseForReflectionAndDiffraction, Solid); }

  public static AKRESULT QueryReflectionPaths(ulong in_gameObjectID, uint in_positionIndex, ref UnityEngine.Vector3 out_listenerPos, ref UnityEngine.Vector3 out_emitterPos, AkReflectionPathInfoArray out_aPaths, out uint io_uArraySize) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_QueryReflectionPaths(in_gameObjectID, in_positionIndex, ref out_listenerPos, ref out_emitterPos, out_aPaths.GetBuffer(), out io_uArraySize); }

  public static AKRESULT QueryDiffractionPaths(ulong in_gameObjectID, uint in_positionIndex, ref UnityEngine.Vector3 out_listenerPos, ref UnityEngine.Vector3 out_emitterPos, AkDiffractionPathInfoArray out_aPaths, out uint io_uArraySize) { return (AKRESULT)AkUnitySoundEnginePINVOKE.CSharp_QueryDiffractionPaths(in_gameObjectID, in_positionIndex, ref out_listenerPos, ref out_emitterPos, out_aPaths.GetBuffer(), out io_uArraySize); }

  public static void PerformStreamMgrIO() { AkUnitySoundEnginePINVOKE.CSharp_PerformStreamMgrIO(); }

  ///  Data type definitions.
  public const int AK_SIMD_ALIGNMENT = 16;
  public const int AK_BUFFER_ALIGNMENT = 16;
  public const int AK_MAX_PATH = 260;
  ///  Create Riff chunk
  public const int AK_BANK_PLATFORM_DATA_ALIGNMENT = (16);
  ///  Format for printing AkOSChar string using OutputDebugMsgV
  ///  Corresponds to "%ls" if AK_OS_WCHAR, else "%s".
  /// <remarks>Usage: AKPLATFORM::OutputDebugMsgV(AKTEXT("Print this string: " AK_OSCHAR_FMT "\n", msg));</remarks>
  public const string AK_OSCHAR_FMT = "%s";
  ///  Invalid FX ID
  public const uint AK_INVALID_PLUGINID = unchecked((uint)(-1));
  ///  Invalid game object (may also mean all game objects)
  public const ulong AK_INVALID_GAME_OBJECT = unchecked((ulong)(-1));
  ///  Invalid unique 32-bit ID
  public const uint AK_INVALID_UNIQUE_ID = 0;
  ///  Invalid RTPC ID
  public const uint AK_INVALID_RTPC_ID = AK_INVALID_UNIQUE_ID;
  ///  Invalid listener index
  public const uint AK_INVALID_LISTENER_INDEX = unchecked((uint)(-1));
  ///  Invalid playing ID
  public const uint AK_INVALID_PLAYING_ID = AK_INVALID_UNIQUE_ID;
  ///  Switch selected if no switch has been set yet
  public const uint AK_DEFAULT_SWITCH_STATE = 0;
  ///  Invalid pool ID
  public const int AK_INVALID_POOL_ID = -1;
  ///  Default pool ID, same as AK_INVALID_POOL_ID
  public const int AK_DEFAULT_POOL_ID = -1;
  ///  Invalid auxiliary bus ID (or no Aux bus ID)
  public const uint AK_INVALID_AUX_ID = AK_INVALID_UNIQUE_ID;
  ///  Invalid file ID
  public const uint AK_INVALID_FILE_ID = unchecked((uint)(-1));
  ///  Invalid streaming device ID
  public const uint AK_INVALID_DEVICE_ID = unchecked((uint)(-1));
  ///  Invalid bank ID
  public const uint AK_INVALID_BANK_ID = AK_INVALID_UNIQUE_ID;
  ///  Fallback argument value ID
  public const uint AK_FALLBACK_ARGUMENTVALUE_ID = 0;
  ///  Invalid channel mask
  public const uint AK_INVALID_CHANNELMASK = 0;
  ///  Invalid Device ID
  public const uint AK_INVALID_OUTPUT_DEVICE_ID = AK_INVALID_UNIQUE_ID;
  ///  Mixer slot
  public const uint AK_MIXER_FX_SLOT = unchecked((uint)(-1));
  ///  Default listener ID 0
  public const ulong AK_DEFAULT_LISTENER_OBJ = 0;
  ///  Default sound / I/O priority
  public const uint AK_DEFAULT_PRIORITY = 50;
  ///  Minimal priority value [0,100]
  public const uint AK_MIN_PRIORITY = 0;
  ///  Maximal priority value [0,100]
  public const uint AK_MAX_PRIORITY = 100;
  ///   Default bank load I/O priority
  public const uint AK_DEFAULT_BANK_IO_PRIORITY = AK_DEFAULT_PRIORITY;
  ///   Default bank load throughput (1 Mb/ms)
  public const double AK_DEFAULT_BANK_THROUGHPUT = 1*1024*1024/1000.0;
  public const uint AKCOMPANYID_AUDIOKINETIC = 0;
  public const uint AK_LISTENERS_MASK_ALL = 0xFFFFFFFF;
  public const uint AK_INVALID_SAMPLE_POS = 0xFFFFFFFF;
  public const uint AKMOTION_RESIDENT_MODE = 0x80000000;
  public const int NULL = 0;
  public const int AK_MAX_LANGUAGE_NAME_SIZE = (32);
  public const int AKCOMPANYID_PLUGINDEV_MIN = (64);
  public const int AKCOMPANYID_PLUGINDEV_MAX = (255);
  public const int AKCOMPANYID_AUDIOKINETIC_EXTERNAL = (1);
  public const int AKCOMPANYID_MCDSP = (256);
  public const int AKCOMPANYID_WAVEARTS = (257);
  public const int AKCOMPANYID_PHONETICARTS = (258);
  public const int AKCOMPANYID_IZOTOPE = (259);
  public const int AKCOMPANYID_CRANKCASEAUDIO = (261);
  public const int AKCOMPANYID_IOSONO = (262);
  public const int AKCOMPANYID_AUROTECHNOLOGIES = (263);
  public const int AKCOMPANYID_DOLBY = (264);
  public const int AKCOMPANYID_TWOBIGEARS = (265);
  public const int AKCOMPANYID_OCULUS = (266);
  public const int AKCOMPANYID_BLUERIPPLESOUND = (267);
  public const int AKCOMPANYID_ENZIEN = (268);
  public const int AKCOMPANYID_KROTOS = (269);
  public const int AKCOMPANYID_NURULIZE = (270);
  public const int AKCOMPANYID_SUPERPOWERED = (271);
  public const int AKCOMPANYID_GOOGLE = (272);
  public const int AKCOMPANYID_VISISONICS = (277);
  public const int AKCODECID_BANK = (0);
  public const int AKCODECID_PCM = (1);
  public const int AKCODECID_ADPCM = (2);
  public const int AKCODECID_XMA = (3);
  public const int AKCODECID_VORBIS = (4);
  public const int AKCODECID_WIIADPCM = (5);
  public const int AKCODECID_PCM_WAV = (7);
  public const int AKCODECID_EXTERNAL_SOURCE = (8);
  public const int AKCODECID_XWMA = (9);
  public const int AKCODECID_FILE_PACKAGE = (11);
  public const int AKCODECID_ATRAC9 = (12);
  public const int AKCODECID_VAG = (13);
  public const int AKCODECID_PROFILERCAPTURE = (14);
  public const int AKCODECID_ANALYSISFILE = (15);
  public const int AKCODECID_MIDI = (16);
  public const int AKCODECID_OPUSNX = (17);
  public const int AKCODECID_CAF = (18);
  public const int AKCODECID_AKOPUS = (19);
  public const int AKCODECID_AKOPUS_WEM = (20);
  public const int AKCODECID_MEMORYMGR_DUMP = (21);
  public const int AKCODECID_SONY360 = (22);
  public const int AKCODECID_BANK_EVENT = (30);
  public const int AKCODECID_BANK_BUS = (31);
  public const int AKPLUGINID_RECORDER = (132);
  public const int AKPLUGINID_IMPACTER = (184);
  public const int AKPLUGINID_SYSTEM_OUTPUT_META = (900);
  public const int AKPLUGINID_AUDIO_OBJECT_ATTENUATION_META = (901);
  public const int AKPLUGINID_AUDIO_OBJECT_PRIORITY_META = (902);
  public const int AKEXTENSIONID_SPATIALAUDIO = (800);
  public const int AKEXTENSIONID_INTERACTIVEMUSIC = (801);
  public const int AKEXTENSIONID_MIDIDEVICEMGR = (802);
  public const int AK_WAVE_FORMAT_VAG = 0xFFFB;
  public const int AK_WAVE_FORMAT_AT9 = 0xFFFC;
  public const int AK_WAVE_FORMAT_VORBIS = 0xFFFF;
  public const int AK_WAVE_FORMAT_OPUSNX = 0x3039;
  public const int AK_WAVE_FORMAT_OPUS = 0x3040;
  public const int AK_WAVE_FORMAT_OPUS_WEM = 0x3041;
  public const int AK_WAVE_FORMAT_XMA2 = 0x166;
  public const int AKCURVEINTERPOLATION_NUM_STORAGE_BIT = 5;
  public const int AK_PANNER_NUM_STORAGE_BITS = 3;
  public const int AK_POSSOURCE_NUM_STORAGE_BITS = 3;
  public const int AK_SPAT_NUM_STORAGE_BITS = 3;
  public const int AK_MAX_BITS_METERING_FLAGS = (5);
  public const bool AK_ASYNC_OPEN_DEFAULT = (false);
  public const int AK_COMM_DEFAULT_DISCOVERY_PORT = 24024;
  ///  Default listener transform.
  public const float AK_DEFAULT_LISTENER_POSITION_X = (0.0f);
  public const float AK_DEFAULT_LISTENER_POSITION_Y = (0.0f);
  public const float AK_DEFAULT_LISTENER_POSITION_Z = (0.0f);
  public const float AK_DEFAULT_LISTENER_FRONT_X = (0.0f);
  public const float AK_DEFAULT_LISTENER_FRONT_Y = (0.0f);
  public const float AK_DEFAULT_LISTENER_FRONT_Z = (1.0f);
  public const float AK_DEFAULT_TOP_X = (0.0f);
  public const float AK_DEFAULT_TOP_Y = (1.0f);
  public const float AK_DEFAULT_TOP_Z = (0.0f);
  public const int AK_MIDI_EVENT_TYPE_INVALID = 0x00;
  public const int AK_MIDI_EVENT_TYPE_NOTE_OFF = 0x80;
  public const int AK_MIDI_EVENT_TYPE_NOTE_ON = 0x90;
  public const int AK_MIDI_EVENT_TYPE_NOTE_AFTERTOUCH = 0xa0;
  public const int AK_MIDI_EVENT_TYPE_CONTROLLER = 0xb0;
  public const int AK_MIDI_EVENT_TYPE_PROGRAM_CHANGE = 0xc0;
  public const int AK_MIDI_EVENT_TYPE_CHANNEL_AFTERTOUCH = 0xd0;
  public const int AK_MIDI_EVENT_TYPE_PITCH_BEND = 0xe0;
  public const int AK_MIDI_EVENT_TYPE_SYSEX = 0xf0;
  public const int AK_MIDI_EVENT_TYPE_ESCAPE = 0xf7;
  public const int AK_MIDI_EVENT_TYPE_WWISE_CMD = 0xfe;
  public const int AK_MIDI_EVENT_TYPE_META = 0xff;
  public const int AK_MIDI_CC_BANK_SELECT_COARSE = 0;
  public const int AK_MIDI_CC_MOD_WHEEL_COARSE = 1;
  public const int AK_MIDI_CC_BREATH_CTRL_COARSE = 2;
  public const int AK_MIDI_CC_CTRL_3_COARSE = 3;
  public const int AK_MIDI_CC_FOOT_PEDAL_COARSE = 4;
  public const int AK_MIDI_CC_PORTAMENTO_COARSE = 5;
  public const int AK_MIDI_CC_DATA_ENTRY_COARSE = 6;
  public const int AK_MIDI_CC_VOLUME_COARSE = 7;
  public const int AK_MIDI_CC_BALANCE_COARSE = 8;
  public const int AK_MIDI_CC_CTRL_9_COARSE = 9;
  public const int AK_MIDI_CC_PAN_POSITION_COARSE = 10;
  public const int AK_MIDI_CC_EXPRESSION_COARSE = 11;
  public const int AK_MIDI_CC_EFFECT_CTRL_1_COARSE = 12;
  public const int AK_MIDI_CC_EFFECT_CTRL_2_COARSE = 13;
  public const int AK_MIDI_CC_CTRL_14_COARSE = 14;
  public const int AK_MIDI_CC_CTRL_15_COARSE = 15;
  public const int AK_MIDI_CC_GEN_SLIDER_1 = 16;
  public const int AK_MIDI_CC_GEN_SLIDER_2 = 17;
  public const int AK_MIDI_CC_GEN_SLIDER_3 = 18;
  public const int AK_MIDI_CC_GEN_SLIDER_4 = 19;
  public const int AK_MIDI_CC_CTRL_20_COARSE = 20;
  public const int AK_MIDI_CC_CTRL_21_COARSE = 21;
  public const int AK_MIDI_CC_CTRL_22_COARSE = 22;
  public const int AK_MIDI_CC_CTRL_23_COARSE = 23;
  public const int AK_MIDI_CC_CTRL_24_COARSE = 24;
  public const int AK_MIDI_CC_CTRL_25_COARSE = 25;
  public const int AK_MIDI_CC_CTRL_26_COARSE = 26;
  public const int AK_MIDI_CC_CTRL_27_COARSE = 27;
  public const int AK_MIDI_CC_CTRL_28_COARSE = 28;
  public const int AK_MIDI_CC_CTRL_29_COARSE = 29;
  public const int AK_MIDI_CC_CTRL_30_COARSE = 30;
  public const int AK_MIDI_CC_CTRL_31_COARSE = 31;
  public const int AK_MIDI_CC_BANK_SELECT_FINE = 32;
  public const int AK_MIDI_CC_MOD_WHEEL_FINE = 33;
  public const int AK_MIDI_CC_BREATH_CTRL_FINE = 34;
  public const int AK_MIDI_CC_CTRL_3_FINE = 35;
  public const int AK_MIDI_CC_FOOT_PEDAL_FINE = 36;
  public const int AK_MIDI_CC_PORTAMENTO_FINE = 37;
  public const int AK_MIDI_CC_DATA_ENTRY_FINE = 38;
  public const int AK_MIDI_CC_VOLUME_FINE = 39;
  public const int AK_MIDI_CC_BALANCE_FINE = 40;
  public const int AK_MIDI_CC_CTRL_9_FINE = 41;
  public const int AK_MIDI_CC_PAN_POSITION_FINE = 42;
  public const int AK_MIDI_CC_EXPRESSION_FINE = 43;
  public const int AK_MIDI_CC_EFFECT_CTRL_1_FINE = 44;
  public const int AK_MIDI_CC_EFFECT_CTRL_2_FINE = 45;
  public const int AK_MIDI_CC_CTRL_14_FINE = 46;
  public const int AK_MIDI_CC_CTRL_15_FINE = 47;
  public const int AK_MIDI_CC_CTRL_20_FINE = 52;
  public const int AK_MIDI_CC_CTRL_21_FINE = 53;
  public const int AK_MIDI_CC_CTRL_22_FINE = 54;
  public const int AK_MIDI_CC_CTRL_23_FINE = 55;
  public const int AK_MIDI_CC_CTRL_24_FINE = 56;
  public const int AK_MIDI_CC_CTRL_25_FINE = 57;
  public const int AK_MIDI_CC_CTRL_26_FINE = 58;
  public const int AK_MIDI_CC_CTRL_27_FINE = 59;
  public const int AK_MIDI_CC_CTRL_28_FINE = 60;
  public const int AK_MIDI_CC_CTRL_29_FINE = 61;
  public const int AK_MIDI_CC_CTRL_30_FINE = 62;
  public const int AK_MIDI_CC_CTRL_31_FINE = 63;
  public const int AK_MIDI_CC_HOLD_PEDAL = 64;
  public const int AK_MIDI_CC_PORTAMENTO_ON_OFF = 65;
  public const int AK_MIDI_CC_SUSTENUTO_PEDAL = 66;
  public const int AK_MIDI_CC_SOFT_PEDAL = 67;
  public const int AK_MIDI_CC_LEGATO_PEDAL = 68;
  public const int AK_MIDI_CC_HOLD_PEDAL_2 = 69;
  public const int AK_MIDI_CC_SOUND_VARIATION = 70;
  public const int AK_MIDI_CC_SOUND_TIMBRE = 71;
  public const int AK_MIDI_CC_SOUND_RELEASE_TIME = 72;
  public const int AK_MIDI_CC_SOUND_ATTACK_TIME = 73;
  public const int AK_MIDI_CC_SOUND_BRIGHTNESS = 74;
  public const int AK_MIDI_CC_SOUND_CTRL_6 = 75;
  public const int AK_MIDI_CC_SOUND_CTRL_7 = 76;
  public const int AK_MIDI_CC_SOUND_CTRL_8 = 77;
  public const int AK_MIDI_CC_SOUND_CTRL_9 = 78;
  public const int AK_MIDI_CC_SOUND_CTRL_10 = 79;
  public const int AK_MIDI_CC_GENERAL_BUTTON_1 = 80;
  public const int AK_MIDI_CC_GENERAL_BUTTON_2 = 81;
  public const int AK_MIDI_CC_GENERAL_BUTTON_3 = 82;
  public const int AK_MIDI_CC_GENERAL_BUTTON_4 = 83;
  public const int AK_MIDI_CC_REVERB_LEVEL = 91;
  public const int AK_MIDI_CC_TREMOLO_LEVEL = 92;
  public const int AK_MIDI_CC_CHORUS_LEVEL = 93;
  public const int AK_MIDI_CC_CELESTE_LEVEL = 94;
  public const int AK_MIDI_CC_PHASER_LEVEL = 95;
  public const int AK_MIDI_CC_DATA_BUTTON_P1 = 96;
  public const int AK_MIDI_CC_DATA_BUTTON_M1 = 97;
  public const int AK_MIDI_CC_NON_REGISTER_COARSE = 98;
  public const int AK_MIDI_CC_NON_REGISTER_FINE = 99;
  public const int AK_MIDI_CC_ALL_SOUND_OFF = 120;
  public const int AK_MIDI_CC_ALL_CONTROLLERS_OFF = 121;
  public const int AK_MIDI_CC_LOCAL_KEYBOARD = 122;
  public const int AK_MIDI_CC_ALL_NOTES_OFF = 123;
  public const int AK_MIDI_CC_OMNI_MODE_OFF = 124;
  public const int AK_MIDI_CC_OMNI_MODE_ON = 125;
  public const int AK_MIDI_CC_OMNI_MONOPHONIC_ON = 126;
  public const int AK_MIDI_CC_OMNI_POLYPHONIC_ON = 127;
  public const int AK_MIDI_WWISE_CMD_PLAY = 0;
  public const int AK_MIDI_WWISE_CMD_STOP = 1;
  public const int AK_MIDI_WWISE_CMD_PAUSE = 2;
  public const int AK_MIDI_WWISE_CMD_RESUME = 3;
  public const int AK_MIDI_WWISE_CMD_SEEK_MS = 4;
  public const int AK_MIDI_WWISE_CMD_SEEK_SAMPLES = 5;
  ///  Standard speakers (channel mask):
  public const int AK_SPEAKER_FRONT_LEFT = 0x1;
  public const int AK_SPEAKER_FRONT_RIGHT = 0x2;
  public const int AK_SPEAKER_FRONT_CENTER = 0x4;
  public const int AK_SPEAKER_LOW_FREQUENCY = 0x8;
  public const int AK_SPEAKER_BACK_LEFT = 0x10;
  public const int AK_SPEAKER_BACK_RIGHT = 0x20;
  public const int AK_SPEAKER_BACK_CENTER = 0x100;
  public const int AK_SPEAKER_SIDE_LEFT = 0x200;
  public const int AK_SPEAKER_SIDE_RIGHT = 0x400;
  ///  "Height" speakers.
  public const int AK_SPEAKER_TOP = 0x800;
  public const int AK_SPEAKER_HEIGHT_FRONT_LEFT = 0x1000;
  public const int AK_SPEAKER_HEIGHT_FRONT_CENTER = 0x2000;
  public const int AK_SPEAKER_HEIGHT_FRONT_RIGHT = 0x4000;
  public const int AK_SPEAKER_HEIGHT_BACK_LEFT = 0x8000;
  public const int AK_SPEAKER_HEIGHT_BACK_CENTER = 0x10000;
  public const int AK_SPEAKER_HEIGHT_BACK_RIGHT = 0x20000;
  public const int AK_SPEAKER_HEIGHT_SIDE_LEFT = 0x40000;
  public const int AK_SPEAKER_HEIGHT_SIDE_RIGHT = 0x80000;
  public const int AK_SPEAKER_SETUP_MONO = 0x4;
  public const int AK_SPEAKER_SETUP_0POINT1 = 0x8;
  public const int AK_SPEAKER_SETUP_1POINT1 = (0x4|0x8);
  public const int AK_SPEAKER_SETUP_STEREO = (0x1|0x2);
  public const int AK_SPEAKER_SETUP_2POINT1 = ((0x1|0x2)|0x8);
  public const int AK_SPEAKER_SETUP_3STEREO = ((0x1|0x2)|0x4);
  public const int AK_SPEAKER_SETUP_3POINT1 = (((0x1|0x2)|0x4)|0x8);
  public const int AK_SPEAKER_SETUP_4 = ((0x1|0x2)|0x200|0x400);
  public const int AK_SPEAKER_SETUP_4POINT1 = (((0x1|0x2)|0x200|0x400)|0x8);
  public const int AK_SPEAKER_SETUP_5 = (((0x1|0x2)|0x200|0x400)|0x4);
  public const int AK_SPEAKER_SETUP_5POINT1 = ((((0x1|0x2)|0x200|0x400)|0x4)|0x8);
  public const int AK_SPEAKER_SETUP_6 = (((0x1|0x2)|0x200|0x400)|0x10|0x20);
  public const int AK_SPEAKER_SETUP_6POINT1 = ((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x8);
  public const int AK_SPEAKER_SETUP_7 = ((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4);
  public const int AK_SPEAKER_SETUP_7POINT1 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x8);
  public const int AK_SPEAKER_SETUP_SURROUND = ((0x1|0x2)|0x100);
  public const int AK_SPEAKER_SETUP_HEIGHT_2 = (0x1000|0x4000);
  public const int AK_SPEAKER_SETUP_HEIGHT_4 = ((0x1000|0x4000)|0x8000|0x20000);
  public const int AK_SPEAKER_SETUP_HEIGHT_5 = (((0x1000|0x4000)|0x8000|0x20000)|0x2000);
  public const int AK_SPEAKER_SETUP_HEIGHT_ALL = ((((0x1000|0x4000)|0x8000|0x20000)|0x2000)|0x10000);
  public const int AK_SPEAKER_SETUP_HEIGHT_4_TOP = (((0x1000|0x4000)|0x8000|0x20000)|0x800);
  public const int AK_SPEAKER_SETUP_HEIGHT_5_TOP = ((((0x1000|0x4000)|0x8000|0x20000)|0x2000)|0x800);
  public const int AK_SPEAKER_SETUP_AURO_222 = (((0x1|0x2)|0x200|0x400)|0x1000|0x4000);
  public const int AK_SPEAKER_SETUP_AURO_8 = ((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000);
  public const int AK_SPEAKER_SETUP_AURO_9 = (((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000)|0x4);
  public const int AK_SPEAKER_SETUP_AURO_9POINT1 = ((((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000)|0x4)|0x8);
  public const int AK_SPEAKER_SETUP_AURO_10 = ((((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000)|0x4)|0x800);
  public const int AK_SPEAKER_SETUP_AURO_10POINT1 = (((((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000)|0x4)|0x800)|0x8);
  public const int AK_SPEAKER_SETUP_AURO_11 = (((((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000)|0x4)|0x800)|0x2000);
  public const int AK_SPEAKER_SETUP_AURO_11POINT1 = ((((((((0x1|0x2)|0x200|0x400)|0x1000|0x4000)|0x8000|0x20000)|0x4)|0x800)|0x2000)|0x8);
  public const int AK_SPEAKER_SETUP_AURO_11_740 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|((0x1000|0x4000)|0x8000|0x20000));
  public const int AK_SPEAKER_SETUP_AURO_11POINT1_740 = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|((0x1000|0x4000)|0x8000|0x20000))|0x8);
  public const int AK_SPEAKER_SETUP_AURO_13_751 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|(((0x1000|0x4000)|0x8000|0x20000)|0x2000)|0x800);
  public const int AK_SPEAKER_SETUP_AURO_13POINT1_751 = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|(((0x1000|0x4000)|0x8000|0x20000)|0x2000)|0x800)|0x8);
  public const int AK_SPEAKER_SETUP_DOLBY_5_0_2 = ((((0x1|0x2)|0x200|0x400)|0x4)|0x1000|0x4000);
  public const int AK_SPEAKER_SETUP_DOLBY_5_1_2 = (((((0x1|0x2)|0x200|0x400)|0x4)|0x1000|0x4000)|0x8);
  public const int AK_SPEAKER_SETUP_DOLBY_5_0_4 = (((((0x1|0x2)|0x200|0x400)|0x4)|0x1000|0x4000)|0x8000|0x20000);
  public const int AK_SPEAKER_SETUP_DOLBY_5_1_4 = ((((((0x1|0x2)|0x200|0x400)|0x4)|0x1000|0x4000)|0x8000|0x20000)|0x8);
  public const int AK_SPEAKER_SETUP_DOLBY_6_0_2 = ((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x1000|0x4000);
  public const int AK_SPEAKER_SETUP_DOLBY_6_1_2 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x1000|0x4000)|0x8);
  public const int AK_SPEAKER_SETUP_DOLBY_6_0_4 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x1000|0x4000)|0x8000|0x20000);
  public const int AK_SPEAKER_SETUP_DOLBY_6_1_4 = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x1000|0x4000)|0x8000|0x20000)|0x8);
  public const int AK_SPEAKER_SETUP_DOLBY_7_0_2 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x1000|0x4000);
  public const int AK_SPEAKER_SETUP_DOLBY_7_1_2 = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x1000|0x4000)|0x8);
  public const int AK_SPEAKER_SETUP_DOLBY_7_0_4 = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x1000|0x4000)|0x8000|0x20000);
  public const int AK_SPEAKER_SETUP_DOLBY_7_1_4 = (((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x1000|0x4000)|0x8000|0x20000)|0x8);
  public const int AK_SPEAKER_SETUP_ALL_SPEAKERS = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x8)|0x100|((((0x1000|0x4000)|0x8000|0x20000)|0x2000)|0x10000)|0x800);
  public const int AK_IDX_SETUP_FRONT_LEFT = (0);
  public const int AK_IDX_SETUP_FRONT_RIGHT = (1);
  public const int AK_IDX_SETUP_CENTER = (2);
  public const int AK_IDX_SETUP_NOCENTER_BACK_LEFT = (2);
  public const int AK_IDX_SETUP_NOCENTER_BACK_RIGHT = (3);
  public const int AK_IDX_SETUP_NOCENTER_SIDE_LEFT = (4);
  public const int AK_IDX_SETUP_NOCENTER_SIDE_RIGHT = (5);
  public const int AK_IDX_SETUP_WITHCENTER_BACK_LEFT = (3);
  public const int AK_IDX_SETUP_WITHCENTER_BACK_RIGHT = (4);
  public const int AK_IDX_SETUP_WITHCENTER_SIDE_LEFT = (5);
  public const int AK_IDX_SETUP_WITHCENTER_SIDE_RIGHT = (6);
  public const int AK_IDX_SETUP_WITHCENTER_HEIGHT_FRONT_LEFT = (7);
  public const int AK_IDX_SETUP_WITHCENTER_HEIGHT_FRONT_RIGHT = (8);
  public const int AK_IDX_SETUP_WITHCENTER_HEIGHT_BACK_LEFT = (9);
  public const int AK_IDX_SETUP_WITHCENTER_HEIGHT_BACK_RIGHT = (10);
  public const int AK_IDX_SETUP_0_LFE = (0);
  public const int AK_IDX_SETUP_1_CENTER = (0);
  public const int AK_IDX_SETUP_1_LFE = (1);
  public const int AK_IDX_SETUP_2_LEFT = (0);
  public const int AK_IDX_SETUP_2_RIGHT = (1);
  public const int AK_IDX_SETUP_2_LFE = (2);
  public const int AK_IDX_SETUP_3_LEFT = (0);
  public const int AK_IDX_SETUP_3_RIGHT = (1);
  public const int AK_IDX_SETUP_3_CENTER = (2);
  public const int AK_IDX_SETUP_3_LFE = (3);
  public const int AK_IDX_SETUP_4_FRONTLEFT = (0);
  public const int AK_IDX_SETUP_4_FRONTRIGHT = (1);
  public const int AK_IDX_SETUP_4_REARLEFT = (2);
  public const int AK_IDX_SETUP_4_REARRIGHT = (3);
  public const int AK_IDX_SETUP_4_LFE = (4);
  public const int AK_IDX_SETUP_5_FRONTLEFT = (0);
  public const int AK_IDX_SETUP_5_FRONTRIGHT = (1);
  public const int AK_IDX_SETUP_5_CENTER = (2);
  public const int AK_IDX_SETUP_5_REARLEFT = (3);
  public const int AK_IDX_SETUP_5_REARRIGHT = (4);
  public const int AK_IDX_SETUP_5_LFE = (5);
  public const int AK_IDX_SETUP_6_FRONTLEFT = (0);
  public const int AK_IDX_SETUP_6_FRONTRIGHT = (1);
  public const int AK_IDX_SETUP_6_REARLEFT = (2);
  public const int AK_IDX_SETUP_6_REARRIGHT = (3);
  public const int AK_IDX_SETUP_6_SIDELEFT = (4);
  public const int AK_IDX_SETUP_6_SIDERIGHT = (5);
  public const int AK_IDX_SETUP_6_LFE = (6);
  public const int AK_IDX_SETUP_7_FRONTLEFT = (0);
  public const int AK_IDX_SETUP_7_FRONTRIGHT = (1);
  public const int AK_IDX_SETUP_7_CENTER = (2);
  public const int AK_IDX_SETUP_7_REARLEFT = (3);
  public const int AK_IDX_SETUP_7_REARRIGHT = (4);
  public const int AK_IDX_SETUP_7_SIDELEFT = (5);
  public const int AK_IDX_SETUP_7_SIDERIGHT = (6);
  public const int AK_IDX_SETUP_7_LFE = (7);
  public const int AK_SPEAKER_SETUP_0_1 = (0x8);
  public const int AK_SPEAKER_SETUP_1_0_CENTER = (0x4);
  public const int AK_SPEAKER_SETUP_1_1_CENTER = (0x4|0x8);
  public const int AK_SPEAKER_SETUP_2_0 = (0x1|0x2);
  public const int AK_SPEAKER_SETUP_2_1 = (0x1|0x2|0x8);
  public const int AK_SPEAKER_SETUP_3_0 = (0x1|0x2|0x4);
  public const int AK_SPEAKER_SETUP_3_1 = ((0x1|0x2|0x4)|0x8);
  public const int AK_SPEAKER_SETUP_FRONT = ((0x1|0x2|0x4));
  public const int AK_SPEAKER_SETUP_4_0 = (((0x1|0x2)|0x200|0x400));
  public const int AK_SPEAKER_SETUP_4_1 = ((((0x1|0x2)|0x200|0x400)|0x8));
  public const int AK_SPEAKER_SETUP_5_0 = ((((0x1|0x2)|0x200|0x400)|0x4));
  public const int AK_SPEAKER_SETUP_5_1 = (((((0x1|0x2)|0x200|0x400)|0x4)|0x8));
  public const int AK_SPEAKER_SETUP_6_0 = ((((0x1|0x2)|0x200|0x400)|0x10|0x20));
  public const int AK_SPEAKER_SETUP_6_1 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x8));
  public const int AK_SPEAKER_SETUP_7_0 = (((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4));
  public const int AK_SPEAKER_SETUP_7_1 = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x8));
  public const int AK_SPEAKER_SETUP_DEFAULT_PLANE = ((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x8));
  public const int AK_SUPPORTED_STANDARD_CHANNEL_MASK = (((((((0x1|0x2)|0x200|0x400)|0x10|0x20)|0x4)|0x8)|0x100|((((0x1000|0x4000)|0x8000|0x20000)|0x2000)|0x10000)|0x800));
  public const int AK_STANDARD_MAX_NUM_CHANNELS = (8);
  public const int AK_MAX_AMBISONICS_ORDER = (5);
  public const float AK_DEFAULT_HEIGHT_ANGLE = (30.0f);
  ///  Spatial audio data type definitions.
  public const int AK_MAX_NUM_TEXTURE = 4;
  public const int AK_MAX_REFLECT_ORDER = 4;
  public const int AK_MAX_REFLECTION_PATH_LENGTH = (4+4);
  public const int AK_STOCHASTIC_RESERVE_LENGTH = (4+4);
  public const int AK_MAX_SOUND_PROPAGATION_DEPTH = 8;
  public const int AK_MAX_SOUND_PROPAGATION_WIDTH = 32;
  public const float AK_SA_EPSILON = (0.001f);
  public const float AK_SA_DIFFRACTION_EPSILON = (0.01f);
  public const float AK_SA_DIFFRACTION_DOT_EPSILON = (0.00005f);
  public const float AK_SA_PLANE_THICKNESS = (0.01f);
  public const float AK_SA_MIN_ENVIRONMENT_ABSORPTION = (0.01f);
  public const float AK_SA_MIN_ENVIRONMENT_SURFACE_AREA = (1.0f);
  public const double AK_DEFAULT_GEOMETRY_POSITION_X = (0.0);
  public const double AK_DEFAULT_GEOMETRY_POSITION_Y = (0.0);
  public const double AK_DEFAULT_GEOMETRY_POSITION_Z = (0.0);
  public const double AK_DEFAULT_GEOMETRY_FRONT_X = (0.0);
  public const double AK_DEFAULT_GEOMETRY_FRONT_Y = (0.0);
  public const double AK_DEFAULT_GEOMETRY_FRONT_Z = (1.0);
  public const double AK_DEFAULT_GEOMETRY_TOP_X = (0.0);
  public const double AK_DEFAULT_GEOMETRY_TOP_Y = (1.0);
  public const double AK_DEFAULT_GEOMETRY_TOP_Z = (0.0);
}
#endif // #if (UNITY_STANDALONE_OSX && !UNITY_EDITOR) || UNITY_EDITOR_OSX