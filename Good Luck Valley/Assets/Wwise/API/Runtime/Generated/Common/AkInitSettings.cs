#if ! (UNITY_DASHBOARD_WIDGET || UNITY_WEBPLAYER || UNITY_WII || UNITY_WIIU || UNITY_NACL || UNITY_FLASH || UNITY_BLACKBERRY) // Disable under unsupported platforms.
//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

///  Platform-independent initialization settings of the sound engine
/// <seealso cref="
///  - AK.SoundEngine.Init"/>

public class AkInitSettings : global::System.IDisposable {
  private global::System.IntPtr swigCPtr;
  protected bool swigCMemOwn;

  internal AkInitSettings(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  internal static global::System.IntPtr getCPtr(AkInitSettings obj) {
    return (obj == null) ? global::System.IntPtr.Zero : obj.swigCPtr;
  }

  internal virtual void setCPtr(global::System.IntPtr cPtr) {
    Dispose();
    swigCPtr = cPtr;
  }

  ~AkInitSettings() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          AkUnitySoundEnginePINVOKE.CSharp_delete_AkInitSettings(swigCPtr);
        }
        swigCPtr = global::System.IntPtr.Zero;
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

  ///  Maximum number of paths for positioning
  public uint uMaxNumPaths { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uMaxNumPaths_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uMaxNumPaths_get(swigCPtr); } 
  }

  ///  Size of the command queue, in bytes
  public uint uCommandQueueSize { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uCommandQueueSize_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uCommandQueueSize_get(swigCPtr); } 
  }

  ///  Sets to true to enable AK::SoundEngine::PrepareGameSync usage.
  public bool bEnableGameSyncPreparation { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bEnableGameSyncPreparation_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bEnableGameSyncPreparation_get(swigCPtr); } 
  }

  /// Number of quanta ahead when continuous containers should instantiate a new voice before which next sounds should start playing. This look-ahead time allows I/O to occur, and is especially useful to reduce the latency of continuous containers with trigger rate or sample-accurate transitions.
  /// Default is 1 audio quantum, also known as an audio frame. Its size is equal to AkInitSettings::uNumSamplesPerFrame / AkPlatformInitSettings::uSampleRate. For many platforms the default values - which can be overridden - are respectively 1,024 samples and 48 kHz. This gives a default 21.3 ms for an audio quantum, which is adequate if you have a RAM-based streaming device that completes transfers within 20 ms. With 1 look-ahead quantum, voices spawned by continuous containers are more likely to be ready when they are required to play, thereby improving the overall precision of sound scheduling. If your device completes transfers in 30 ms instead, you might consider increasing this value to 2 because it will grant new voices 2 audio quanta (~43 ms) to fetch data.
  public uint uContinuousPlaybackLookAhead { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uContinuousPlaybackLookAhead_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uContinuousPlaybackLookAhead_get(swigCPtr); } 
  }

  ///  Multiplication factor for all streaming look-ahead heuristic values, for music streams.
  public float fStreamingLookAheadRatio { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_fStreamingLookAheadRatio_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_fStreamingLookAheadRatio_get(swigCPtr); } 
  }

  ///  Number of samples per audio frame (256, 512, 1024, or 2048).
  public uint uNumSamplesPerFrame { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uNumSamplesPerFrame_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uNumSamplesPerFrame_get(swigCPtr); } 
  }

  ///  Size of the monitoring queue, in bytes. This parameter is not used in Release build.
  public uint uMonitorQueuePoolSize { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uMonitorQueuePoolSize_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uMonitorQueuePoolSize_get(swigCPtr); } 
  }

  ///  Maximum size of the CPU monitoring queue, per thread, in bytes. This parameter is not used in Release build.
  public uint uCpuMonitorQueueMaxSize { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uCpuMonitorQueueMaxSize_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uCpuMonitorQueueMaxSize_get(swigCPtr); } 
  }

  ///  Main output device settings.
  public AkOutputSettings settingsMainOutput { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_settingsMainOutput_set(swigCPtr, AkOutputSettings.getCPtr(value)); } 
    get {
      global::System.IntPtr cPtr = AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_settingsMainOutput_get(swigCPtr);
      AkOutputSettings ret = (cPtr == global::System.IntPtr.Zero) ? null : new AkOutputSettings(cPtr, false);
      return ret;
    } 
  }

  ///  Amount of time to wait for HW devices to trigger an audio interrupt. If there is no interrupt after that time, the sound engine will revert to  silent mode and continue operating until the HW finally comes back. Default value: 2000 (2 seconds)
  public uint uMaxHardwareTimeoutMs { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uMaxHardwareTimeoutMs_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uMaxHardwareTimeoutMs_get(swigCPtr); } 
  }

  ///  Use a Wwise-owned thread for loading sound banks. If set to false, bank-loading will occur only inside a call to AK::SoundEngine::ProcessBanks().
  /// <seealso cref="\ref goingfurther_bankmgrthread"/>
  public bool bUseSoundBankMgrThread { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bUseSoundBankMgrThread_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bUseSoundBankMgrThread_get(swigCPtr); } 
  }

  ///  Use a Wwise-owned thread for processing audio. If set to false, audio processing will occur only inside a call to AK::SoundEngine::RenderAudio().
  /// <seealso cref="\ref goingfurther_eventmgrthread"/>
  public bool bUseLEngineThread { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bUseLEngineThread_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bUseLEngineThread_get(swigCPtr); } 
  }

  ///  When using DLLs for plugins, specify their path. Leave NULL if DLLs are in the same folder as the game executable.
  public string szPluginDLLPath { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_szPluginDLLPath_set(swigCPtr, value); }  get { return AkUnitySoundEngine.StringFromIntPtrOSString(AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_szPluginDLLPath_get(swigCPtr)); } 
  }

  /// Define the orientation of the the floor plane with respect to the X,Y,Z axes, and which axes represent the side, front and up vectors as a basis for rotations in Wwise.
  /// AkFloorPlane is used in to orient the Game Object 3D Viewer in Wwise, and in the transformation of geometry instances in Wwise Spatial Audio.
  public AkFloorPlane eFloorPlane { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_eFloorPlane_set(swigCPtr, (int)value); }  get { return (AkFloorPlane)AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_eFloorPlane_get(swigCPtr); } 
  }

  /// The number of game units in a meter.
  /// This setting is used to adapt the size of elements in the Authoring's Game Object 3D Viewer and Audio Object 3D Viewer to meters.
  /// This setting is also used to simulate real-world positioning of System Audio Objects, to improve the HRTF in some cases.
  /// Note that for legacy reasons, this setting's name is misleading. Its value should represent the number of game units *per* meter.
  /// For example, if your game engine sends positions in centimeters, the value of fGameUnitsToMeters should be 100.
  public float fGameUnitsToMeters { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_fGameUnitsToMeters_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_fGameUnitsToMeters_get(swigCPtr); } 
  }

  ///  The number of bytes read by the BankReader when new data needs to be loaded from disk during serialization. Increasing this trades memory usage for larger, but fewer, file-read events during bank loading.
  public uint uBankReadBufferSize { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uBankReadBufferSize_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_uBankReadBufferSize_get(swigCPtr); } 
  }

  ///  Debug setting: Only used when bDebugOutOfRangeCheckEnabled is true.  This defines the maximum values samples can have.  Normal audio must be contained within +1/-1.  This limit should be set higher to allow temporary or short excursions out of range.  Default is 16.
  public float fDebugOutOfRangeLimit { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_fDebugOutOfRangeLimit_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_fDebugOutOfRangeLimit_get(swigCPtr); } 
  }

  ///  Debug setting: Enable checks for out-of-range (and NAN) floats in the processing code.  This incurs a small performance hit, but can be enabled in most scenarios.  Will print error messages in the log if invalid values are found at various point in the pipeline. Contact AK Support with the new error messages for more information.
  public bool bDebugOutOfRangeCheckEnabled { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bDebugOutOfRangeCheckEnabled_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bDebugOutOfRangeCheckEnabled_get(swigCPtr); } 
  }

  ///  Enables/disables offline rendering. \ref goingfurther_offlinerendering
  public bool bOfflineRendering { set { AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bOfflineRendering_set(swigCPtr, value); }  get { return AkUnitySoundEnginePINVOKE.CSharp_AkInitSettings_bOfflineRendering_get(swigCPtr); } 
  }

}
#endif // #if ! (UNITY_DASHBOARD_WIDGET || UNITY_WEBPLAYER || UNITY_WII || UNITY_WIIU || UNITY_NACL || UNITY_FLASH || UNITY_BLACKBERRY) // Disable under unsupported platforms.